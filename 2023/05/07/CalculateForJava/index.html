<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CalculateForJava | Freedom Coding</title><meta name="author" content="Satrol_"><meta name="copyright" content="Satrol_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="How to know data structure?">
<meta property="og:type" content="article">
<meta property="og:title" content="CalculateForJava">
<meta property="og:url" content="https://sloplerol.github.io/2023/05/07/CalculateForJava/index.html">
<meta property="og:site_name" content="Freedom Coding">
<meta property="og:description" content="How to know data structure?">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg">
<meta property="article:published_time" content="2023-05-07T07:32:24.000Z">
<meta property="article:modified_time" content="2023-05-16T05:01:22.756Z">
<meta property="article:author" content="Satrol_">
<meta property="article:tag" content="Calculating">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sloplerol.github.io/2023/05/07/CalculateForJava/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CalculateForJava',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-05-16 13:01:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109008086?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Freedom Coding"><span class="site-name">Freedom Coding</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CalculateForJava</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-07T07:32:24.000Z" title="发表于 2023-05-07 15:32:24">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T05:01:22.756Z" title="更新于 2023-05-16 13:01:22">2023-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CalculateForJava"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><center><font face="宋体" color=lightgreen size=6>~Java数据结构与算法～</font></center>

<hr>
<p><font size = 3 color = orange>目录</font></p>
<ul>
<li><p><a href="#1">时间复杂度</a></p>
</li>
<li><p><a href="#2">排序</a></p>
</li>
<li><p><a href="#3">查找</a></p>
</li>
<li><p><a href="#4">哈希表</a></p>
</li>
<li><p><a href="#5">线性表</a></p>
</li>
<li><p><a href="#6">链表</a></p>
</li>
<li><p><a href="#7">队列</a></p>
</li>
<li><p><a href="#8">栈</a></p>
</li>
<li><p><a href="#9">递归</a></p>
</li>
<li><p><a href="#10">树</a></p>
</li>
</ul>
<p id="1"></p>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul>
<li><p>算法函数的常数可以忽略</p>
</li>
<li><p>算法函数幂指数前的常数项可以进行忽略</p>
</li>
<li><p>幂越小说明耗费的时间越少</p>
</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox"> 
常见的时间复杂度</p>
<blockquote>
<p>以下的时间复杂度逐渐变大</p>
</blockquote>
<ul>
<li><p>O(1)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要没有循环时间复杂度就是O(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(log2n)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">		i *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x = log2n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n);</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		j = i;</span><br><span class="line">		j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这段代码会判断n + 1遍 时间复杂度是O(n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>O(nlog2n)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n)里面套了一个O(log2n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n ^ 2)</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O(n)里面套了一个O(n);</span><br></pre></td></tr></table></figure>
</li>
<li><p>O(n ^ 3)</p>
</li>
<li><p>O(n ^ k)</p>
</li>
<li><p>O(2 ^ n)</p>
</li>
</ul>
</li>
</ul>
<p id="2"></p>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul>
<li>原理：俩俩比较，俩俩交换，最后将最大值放到最右边</li>
<li>一共进行了数组-1次大的循环</li>
<li>每一次循环的次数在不断减少</li>
<li>时间复杂度O(n * 2)</li>
<li><strong>优化：可以判断交换次数，如果没有发生交换可以提前结束</strong></li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox"> 
代码实现</p>
<p>  <strong>核心代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;-<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//一次for循环,总共需要四回</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">				arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>成品展示</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>  <strong>优化</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - i - <span class="number">1</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果未发生交换break</span></span><br><span class="line"><span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>原理：从第一个元素开始，与后面的元素进行比对，发现一个最小的将值赋值给他，让最小索引等于他</li>
<li>时间复杂度O(n * 2) —– 时间比冒泡少了很多</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox"> 
代码实现</p>
<p>  <strong>第一次排序</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> + <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(min &gt; arr[i])&#123;</span><br><span class="line">        min = arr[i];</span><br><span class="line">        minIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(minIndex != <span class="number">0</span>)&#123;</span><br><span class="line">    arr[minIndex] = arr[<span class="number">0</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>成品展示</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span>;j++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[j];</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j + <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; arr[i])&#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(minIndex != j)&#123;</span><br><span class="line">        arr[minIndex] = arr[j];</span><br><span class="line">        arr[j] = min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li><p>原理：从第二个元素开始不断的往前面插入合适的位置</p>
</li>
<li><p>代码</p>
<p>  <strong>核心代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//代表的是插入元素的索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex])&#123;</span><br><span class="line">    arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">    insertIndex--;</span><br><span class="line">&#125;</span><br><span class="line">arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="keyword">return</span> arr;</span><br></pre></td></tr></table></figure>

<p>  <strong>成品代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    <span class="comment">//代表的是插入元素的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex])&#123;</span><br><span class="line">        arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">        insertIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><ul>
<li>原理：将一组数&#x2F;2分成多组进行排序，直到最后等于零为止，相当于是插入排序的进阶版</li>
</ul>
<ul>
<li><p><input disabled="" type="checkbox"> 
代码</p>
<p>  <strong>采用交换法的希尔排序</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;h &gt; <span class="number">0</span>;h /= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h;i &lt; arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - h;j &gt;= <span class="number">0</span>;j -= h)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + h])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j + h];</span><br><span class="line">                arr[j + h] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>采用移动法的希尔排序</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>;gap &gt; <span class="number">0</span>;gap /= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> gap;j &lt; arr.length;j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[i - gap])&#123;</span><br><span class="line">            <span class="keyword">while</span>(i - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[i - gap])&#123;</span><br><span class="line">                arr[i] = arr[i - gap];</span><br><span class="line">                i -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><ul>
<li><p>原理：假如比较的是4578 1236将数组分成两半，重新定义一个新数组，首先比较4和1谁小放入到新数组中，然后小的向后移接着进行比较</p>
</li>
<li><p>注意点</p>
<ul>
<li>有n个数进行排序，就合并了n - 1次</li>
</ul>
</li>
<li><p>代码</p>
<p>  <strong>合代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从头到尾将新数组拷贝到原数组中</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">while</span>(tempLeft &lt;= right)&#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            tempLeft++;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>分代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">divideSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//左递归</span></span><br><span class="line">            divideSort(arr,left,mid,temp);</span><br><span class="line">            <span class="comment">//右递归</span></span><br><span class="line">            divideSort(arr,mid + <span class="number">1</span>,right,temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            MergeSort(arr,left,mid,right,temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li><p>原理：以这组数据的中间值为标准，将数据分为左递归和右递归，在左边找到比这个中间值大的和在右边找到比中间值小的进行交换</p>
</li>
<li><p>代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[l] &lt; pivot)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(arr[r] &gt; pivot)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line">            <span class="comment">//两边的值交换完毕</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果发现交换后左边的值等于pivot</span></span><br><span class="line">            <span class="keyword">if</span>(arr[l] == pivot)&#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[r] == pivot)&#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; r)&#123;</span><br><span class="line">            QuickSort(arr,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; l)&#123;</span><br><span class="line">            QuickSort(arr,l,right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><ul>
<li><p>原理：将每一个元素的个位取出并放入0-9对应的桶中，然后是十位，如果没有的话进行补零操作</p>
</li>
<li><p>缺点：不能对负数进行排序，由于有10个桶的原因可能会浪费很多的内存</p>
</li>
<li><p>代码</p>
<p>  <strong>核心代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">digitalEle</span> <span class="operator">=</span> arr[i] / <span class="number">1</span> % <span class="number">10</span>;</span><br><span class="line">            bucket[digitalEle][bucketElement[digitalEle]] = arr[i];</span><br><span class="line">            bucketElement[digitalEle]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucketElement[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; bucketElement[i];l++)&#123;</span><br><span class="line">                    arr[index] = bucket[i][l];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketElement[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>  <strong>完整代码</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">RadixSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//寻找最大数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基数排序是通过空间换时间的排序方法</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] bucketElement = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>,n = <span class="number">1</span>;h &lt; length;h++,n *= <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">digitalEle</span> <span class="operator">=</span> arr[i] / n % <span class="number">10</span>;</span><br><span class="line">                bucket[digitalEle][bucketElement[digitalEle]] = arr[i];</span><br><span class="line">                bucketElement[digitalEle]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bucketElement[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;l &lt; bucketElement[i];l++)&#123;</span><br><span class="line">                        arr[index] = bucket[i][l];</span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bucketElement[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p id="3"></p>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h4 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h4><ul>
<li><p>原理：从头到尾逐一进行比对,将查找值对应的下标进行返回</p>
</li>
<li><p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">LineSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><ul>
<li><p>原理：在一个有序数组里面进行查找,定义left和right通过mid值来判断是left移动还是right移动</p>
</li>
<li><p>代码实现</p>
<p>  <strong>二分查找(当出现重复元素时只返回一个下标)</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midValue &lt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> BinarySearch(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midValue &gt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> BinarySearch(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>二分查找升级版(将出现元素的所有下标放入到数组中)</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">BinarySearch2</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//递归的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midValue &lt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> BinarySearch2(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midValue &gt; value) &#123;</span><br><span class="line">            <span class="keyword">return</span> BinarySearch2(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; <span class="number">0</span> || arr[temp] != value)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line"></span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(temp &gt;= arr.length || arr[temp] != value)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(temp);</span><br><span class="line">                temp += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h4><ul>
<li><p>插值查找什么时候使用合适</p>
<ul>
<li>插值查找要求数组有序</li>
<li>关键字分布比较连续</li>
</ul>
</li>
<li><p>插值查找mid公式</p>
<blockquote>
<p>mid &#x3D; (left) + (right - left) * (findVal - arr[left])  &#x2F; arr[right] - arr[left];</p>
</blockquote>
</li>
<li><p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertSea</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插值查找次数&quot;</span>);</span><br><span class="line">        <span class="comment">//判断第一位大于value和最后一位小于value必须有 否则当value值过大或者过小就会出现越界的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right || arr[<span class="number">0</span>] &gt; value || arr[arr.length - <span class="number">1</span>] &lt; value)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midValue</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span>(midValue &lt; value)&#123;</span><br><span class="line">            <span class="keyword">return</span> insertSea(arr,mid + <span class="number">1</span>,right,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(midValue &gt; value)&#123;</span><br><span class="line">            <span class="keyword">return</span> insertSea(arr,left,mid - <span class="number">1</span>,value);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h4><ul>
<li><p>原理：主要是通过黄金分割点来配合斐波那契数列来进行查找的</p>
</li>
<li><p>代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(fibSearch(arr,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib()&#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; maxSize;i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过mid = low + F(k - 1) - 1来获取到下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//用来斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] f = fib(); <span class="comment">//获取斐波那契数列</span></span><br><span class="line">        <span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>)&#123;</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(arr,f[k]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>;i &lt; temp.length;i++)&#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(key &lt; temp[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key &gt; temp[mid])&#123;</span><br><span class="line">                low = low + <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(mid &lt;= high)&#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p id="4"></p>

<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li><p>简单介绍</p>
<blockquote>
<p>哈希表又称散列表，它通过将关键码值映射到表中某一个位置来访问记录，从而达到加快查找数据的目的，底层还是使用链表来实现的</p>
</blockquote>
</li>
<li><p>哈希表达实现</p>
<ul>
<li><p>提前准备</p>
<p>  <strong>定义一个员工</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Emp&#123;</span><br><span class="line">		public int id;</span><br><span class="line">		public String name;</span><br><span class="line">		public Emp next;</span><br><span class="line">		public Emp(int id,String name)&#123;</span><br><span class="line">				this.id = id;</span><br><span class="line">				this.name = name;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>定义一个链表用来串联员工</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Emp head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        curEmp.next = emp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空链表&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;id = %d name = %s\n&quot;</span>,curEmp.id,curEmp.name);</span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curEmp.id == id)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curEmp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                curEmp = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                cur = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.id == id)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用pre记录cur变化后前一个节点</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>定义一个哈希表用来串联多条链表</strong></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hashtable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">public</span> EmpLinkedList[] empLinkedLists;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="built_in">this</span>.empLinkedLists = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            empLinkedLists[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span>&#123;</span><br><span class="line">        <span class="comment">//通过员工的id来确定所在链表的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> emp.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Hashfun(id);</span><br><span class="line">        empLinkedLists[index].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">            empLinkedLists[i].list();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 先找到该 id 属于那一条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> Hashfun(id);</span><br><span class="line">        <span class="comment">// 先判断边界</span></span><br><span class="line">        <span class="keyword">if</span> (no &gt; size || no &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;id = %d 异常，计算出目标链表为 %d \n&quot;</span>, id, no);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedLists[no].findById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 条链表中未找到 id = %d 的雇员 \n&quot;</span>, no, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 条链表中找到 id = %d 的雇员, name = %s \n&quot;</span>, no, id, emp.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">deleteById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 先找到该 id 属于那一条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> Hashfun(id);</span><br><span class="line">        <span class="comment">// 先判断边界</span></span><br><span class="line">        <span class="keyword">if</span> (no &gt; size || no &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;id = %d 异常，计算出目标链表为 %d \n&quot;</span>, id, no);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedLists[no].deleteById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 条链表中未找到 id = %d 的雇员，删除失败 \n&quot;</span>, no, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;在第 %d 条链表中找到 id = %d 的雇员, name = %s ,删除成功\n&quot;</span>, no, id, emp.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//通过id来获取处于的链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Hashfun</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>​	</p>
<p id="5"></p>

<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h4 id="实现线性表"><a href="#实现线性表" class="headerlink" title="实现线性表"></a>实现线性表</h4><ul>
<li>构建T类存储元素的数组作为线性表的主体</li>
<li>实现方法<ul>
<li>get</li>
<li>getLength</li>
<li>Insert &#x2F; InsetIndex</li>
<li>remove</li>
<li>clear</li>
<li>isEmpty</li>
</ul>
</li>
</ul>
<h4 id="遍历线性表"><a href="#遍历线性表" class="headerlink" title="遍历线性表"></a>遍历线性表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">SIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; N;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> eles[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="对于线性表的容积的改变"><a href="#对于线性表的容积的改变" class="headerlink" title="对于线性表的容积的改变"></a>对于线性表的容积的改变</h4><ul>
<li><p>扩容</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newSize)</span>&#123;</span><br><span class="line">        T[] temp = eles;</span><br><span class="line">        eles = (T[])<span class="keyword">new</span> <span class="title class_">Object</span>[newSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; N;i++)&#123;</span><br><span class="line">            eles[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p id="6"></p>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ul>
<li><p>构成链表的大体操作</p>
<ul>
<li>创建节点</li>
<li>链接节点</li>
</ul>
</li>
<li><p>单向链表</p>
<ul>
<li><p>实现(书写方法)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>实现原理</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>从i开始通过for循环获取item</td>
</tr>
<tr>
<td>clear</td>
<td>head.next &#x3D; null &amp;&amp; N &#x3D; 0</td>
</tr>
<tr>
<td>isEmpty</td>
<td>return this.N &#x3D;&#x3D; 0</td>
</tr>
<tr>
<td>Insert</td>
<td>while(cur.next !&#x3D; null) 遍历完之后向后添加</td>
</tr>
<tr>
<td>insertIndex</td>
<td>pre遍历到前一个元素，newNode.next &#x3D; pre.next;</td>
</tr>
<tr>
<td>remove</td>
<td>Pre.next &#x3D; pre.next.next</td>
</tr>
<tr>
<td>indexOf</td>
<td>for(i &#x3D; 0;n.next !&#x3D; null;i++)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>get,clear,isEmpty,insert,insertInIndex,remove,indexOf</li>
</ul>
</li>
<li><p>实现Iterator接口，方便对元素进行遍历</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LIterator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过重写Iterator来实现遍历的目的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">LIterator</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个头节点 方便进行遍历</span></span><br><span class="line">        <span class="keyword">private</span> Node n;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">LIterator</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.n = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n.next != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            n = n.next;</span><br><span class="line">            <span class="keyword">return</span> n.item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>双向链表</p>
<ul>
<li>在定义节点的时候需要新增一个pre</li>
</ul>
</li>
<li><p>链表的反转</p>
<ul>
<li><p>思路</p>
<p>  <code>将头节点指向尾节点，尾节点依次向前指向</code></p>
</li>
</ul>
</li>
</ul>
<p id="7"></p>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>遵循先进先出的原则</strong></p>
<ul>
<li><p>队列初始化</p>
<ul>
<li>front 代表队列最前的元素 </li>
<li>rear代表队列尾部的元素</li>
<li>通过rear &#x3D;&#x3D; maxSize - 1判断队列是否已经满</li>
<li>提供数组用来存储数据</li>
<li>构造方法front rear初始化为-1</li>
<li>最大容量以及数组的大小都需要外部手动设置</li>
</ul>
</li>
<li><p>部分API实现</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>实现原理</th>
</tr>
</thead>
<tbody><tr>
<td>判断队列是否满</td>
<td>return maxSize - 1 &#x3D;&#x3D; rear</td>
</tr>
<tr>
<td>判断队列是否为空</td>
<td>return front &#x3D;&#x3D; rear</td>
</tr>
<tr>
<td>向队列里面添加数据</td>
<td>需要判断队列是否满arr[++rear] &#x3D; n;</td>
</tr>
<tr>
<td>获取队列的数据</td>
<td>需要判断队列是否为空arr[++front];</td>
</tr>
<tr>
<td>显示队列的所有数据</td>
<td>需要判断队列是否为空遍历数组进行打印</td>
</tr>
<tr>
<td>显示队列的头数据</td>
<td>需要判断队列是否为空return arr[front + 1];</td>
</tr>
</tbody></table>
</li>
<li><p>缺点</p>
<blockquote>
<p>队列rear到头就结束了，无法去使用前面已经空的队列单元</p>
</blockquote>
</li>
</ul>
<h4 id="队列的改进"><a href="#队列的改进" class="headerlink" title="队列的改进"></a>队列的改进</h4><ul>
<li><p>初始化条件变化</p>
<ul>
<li>front 和 rear 初始值为0</li>
<li>front指向第一个元素</li>
<li>rear指向队列的倒数第二个位置</li>
<li>此时队列满的条件发生了变化为(rear + 1) % maxSize &#x3D;&#x3D; front</li>
<li>空的条件还是一样的</li>
<li>队列中有效数据的个数为(rear + maxSize - front ) % maxSize</li>
</ul>
</li>
<li><p>代码实现</p>
<table>
<thead>
<tr>
<th>改动的方法</th>
<th>改动</th>
</tr>
</thead>
<tbody><tr>
<td>向队列里面添加数据</td>
<td>rear向后移动需要取模</td>
</tr>
<tr>
<td>从队列里拿出数据</td>
<td>int value &#x3D; arr[front] front &#x3D; (front + 1) % maxSize;  return value;</td>
</tr>
<tr>
<td>展示队列里的所有数据</td>
<td>for(int i &#x3D; front;i &lt; front + maxSize)  sout(i % maxSize)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<p id="8"></p>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p><strong>遵循先进后出的原理</strong> </p>
<ul>
<li><p>数组模拟栈初始化步骤</p>
<ul>
<li>需要一个栈顶，初始化为-1</li>
<li>栈的大小</li>
<li>模拟一个数组栈</li>
<li>书写一个构造方法指定数组的长度和栈的的大小</li>
</ul>
</li>
<li><p>基本方法实现</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>实现代码</th>
</tr>
</thead>
<tbody><tr>
<td>isFull</td>
<td>return top &#x3D;&#x3D; maxSize - 1</td>
</tr>
<tr>
<td>isEmpty</td>
<td>return top &#x3D;&#x3D; -1</td>
</tr>
<tr>
<td>Push</td>
<td>if(isFull) return; stack[top++] &#x3D; value</td>
</tr>
<tr>
<td>Pop</td>
<td>if(isEmpty) thorw new error; int value &#x3D; stack[top] top–; return value</td>
</tr>
<tr>
<td>list</td>
<td>if(isEmpty) return; for(int i &#x3D; top;j &gt;&#x3D; 0;j–){System.out.printf(“stack[%d]&#x3D;%d\n”),i,stack[i]};</td>
</tr>
</tbody></table>
</li>
<li><p>栈模拟计算器</p>
<ul>
<li><p>数栈</p>
<blockquote>
<p>如果遍历到的是数字直接入数栈</p>
</blockquote>
</li>
<li><p>符号栈</p>
<ul>
<li>如果符号栈内没有内容直接入栈</li>
<li>否则的话比较符号的优先级，如果当前的操作符的优先级大的话就直接入符号栈，否则pop出两个数进行运算</li>
</ul>
</li>
<li><p>main方法书写</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1 + 3 * 2&quot;</span>;</span><br><span class="line"><span class="type">ArrayStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">ArrayStack</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">keetNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		ch = express.charAt(index++);</span><br><span class="line">		<span class="keyword">if</span>(operStack.isOper(ch))&#123;</span><br><span class="line">			<span class="keyword">if</span>(!operStack.isEmpty)&#123;</span><br><span class="line">				<span class="keyword">if</span>(operStack.properties(ch) &lt;= operStack.properties(operStack.peek()))&#123;</span><br><span class="line">						num1 = numStack.pop();</span><br><span class="line">						num2 = numStack.pop();</span><br><span class="line">						oper = operStack.pop();</span><br><span class="line">						res = numStack.cal(num1,num2,oper);</span><br><span class="line">						numStack.push(res);</span><br><span class="line">						operStack.push(ch);</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					operStack.push(ch);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					operStack.push(ch);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//这里面push的数字都是有对应的ASCII值的</span></span><br><span class="line">				<span class="comment">//如果是多位数进行运算的话结果就会出现问题</span></span><br><span class="line">				numStack.push(ch - <span class="number">48</span>);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//通过字符拼接的方式可以解决</span></span><br><span class="line">				keepNum += ch;</span><br><span class="line">				<span class="keyword">if</span>(index == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">						numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span>(operStack.isOper(expression.charAt(index + <span class="number">1</span>)))&#123;</span><br><span class="line">							numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">							keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">		index++;</span><br><span class="line">		<span class="keyword">if</span>(index == expression.length())&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始进行真正的运算</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			num1 = numStack.pop();</span><br><span class="line">			num2 = numStack.pop();</span><br><span class="line">			oper = operStack.pop();</span><br><span class="line">			res = numStack.cal(num1,num2,oper);</span><br><span class="line">			numStack.push(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>栈的三种表达式</p>
<ul>
<li><p>前缀表达式(波兰表达式)</p>
<blockquote>
<p>从右向左扫描，先将数扫描扫描到符号后弹出两个数进行运算</p>
</blockquote>
</li>
<li><p>中缀表达式</p>
<blockquote>
<p>最常见的表达式</p>
</blockquote>
</li>
<li><p>后缀表达式(逆波兰表达式)</p>
<blockquote>
<p>先读取两个数然后读取符号，进行运算，拿着这个运算后的数再读取下一个数，下一个符号，进行运算…..</p>
</blockquote>
</li>
</ul>
</li>
<li><p>逆波兰表达式模拟计算器</p>
<ul>
<li>将字符串中的每一个数据放入到ArrayList中</li>
<li>遍历ArrayList集合，如果是多位数的话直接将其入栈否则的话pop出两个数进行一系列的运算，将计算后的结果入栈</li>
<li>最后将pop出最终的结果</li>
</ul>
</li>
<li><p>中缀表达式转后缀表达式</p>
<ul>
<li><p>大体思路</p>
<ul>
<li>ex:  2 + ((2 + 3) * 5) - 5 &#x3D;&gt; 2 2 3 + 5 * + 5 -</li>
<li>初始化两个栈：符号栈喝存储中间结果的栈</li>
<li>遍历中缀表达式，当遇到运算符的时候比较优先级</li>
<li>如果符号栈为空或者栈顶运算符为( 直接压入栈</li>
<li>如果优先级比较高，直接压入栈</li>
<li>否则的话将s1栈顶的运算符压入s2栈顶 </li>
<li>。。。。。</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将后缀表达式的每一项存放到list当中</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;	</span><br><span class="line">		<span class="comment">//说明是非数字</span></span><br><span class="line">		<span class="keyword">if</span>((c = s.charAt(i)) &gt; <span class="number">57</span> || (c = s.charAt(i)) &lt; <span class="number">48</span>)&#123;</span><br><span class="line">				list.add(<span class="string">&quot; &quot;</span> + s.charAt(i));</span><br><span class="line">				i++;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果是一个数的话</span></span><br><span class="line">				<span class="keyword">while</span>(i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span> || (c = s.charAt(i)) &gt;= <span class="number">48</span>)&#123;</span><br><span class="line">						str += s.charAt(i); <span class="comment">//进行多位数的拼接</span></span><br><span class="line">						i++;</span><br><span class="line">				&#125;</span><br><span class="line">				list.add(str);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; s.length())</span><br><span class="line"><span class="keyword">return</span> ls;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将后缀表达式的List转化为中缀表达式List</span></span><br><span class="line"><span class="type">Stack</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> item : ss)&#123;</span><br><span class="line">		<span class="keyword">if</span>(item.match(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">				s2.add(item);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">				s1.push(item)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&#x27;)&#x27;</span>))&#123;</span><br><span class="line">				<span class="comment">//如果遇到了右括号一次将符号栈内的符号pop直到遇到了(</span></span><br><span class="line">				<span class="keyword">while</span>(!s1.peek().equals(<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">						s2.add(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//消除(括号</span></span><br><span class="line">				s1.pop();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//判断优先级</span></span><br><span class="line">				<span class="keyword">while</span>(s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek() &gt;= Operation.getValue(item)))&#123;</span><br><span class="line">						<span class="comment">//如果item的优先级小于栈顶的优先级的话直接栈顶放入s2</span></span><br><span class="line">						s2.push(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//将最后那个符号放入到符号栈中</span></span><br><span class="line">				s1.push(item);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(s1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">//将s1中的剩余符号压入s2中</span></span><br><span class="line">				s2.add(s1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断符号优先级</span></span><br><span class="line">Class Operation&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String oper)</span>&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">switch</span>&#123;</span><br><span class="line">					<span class="string">&#x27;+&#x27;</span></span><br><span class="line">					<span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">					<span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">					<span class="string">&#x27;/&#x27;</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> res;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p id="9"></p>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul>
<li><p>递归调用规则</p>
<ul>
<li>当程序调用一个方法的时候就会在栈内开辟一段独立的空间</li>
<li>递归必须逐渐与递归结束的条件逼近，否则就会出现栈溢出</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>汉诺塔</li>
<li>迷宫</li>
<li>快排</li>
<li>八皇后</li>
</ul>
</li>
<li><p>迷宫回溯代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构建一个87的迷宫</span></span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">7</span>;i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//        map[1][2] = 1;</span></span><br><span class="line"><span class="comment">//        map[2][2] = 1;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; map.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; map[i].length;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;新构建出来的地图&quot;</span>);</span><br><span class="line">        <span class="comment">//输入新的地图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; map.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; map[i].length;j++)&#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] map,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0点代表没有走过 1代表墙 2代表通路可以走 3代表死路</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(setWay(map,i - <span class="number">1</span>,j))&#123;</span><br><span class="line">                    <span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j + <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//向右走</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i + <span class="number">1</span>,j))&#123;</span><br><span class="line">                    <span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j - <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想要求出最短路径需要分别统计上右下左，上左下右，下左上右，下右上左四种长度</p>
</blockquote>
</li>
<li><p>八皇后问题</p>
<ul>
<li><p>实现思路</p>
<ul>
<li>将第一个皇后放在第一行的第一个位置</li>
<li>第二个皇后放在第二行的第一个位置，如果不合适放到第二行的指定位置，后面都以此类推</li>
<li>当得到一组正确答案后开始将第一个皇后后移，其他的放到合适的位置从而达到多组解</li>
</ul>
</li>
<li><p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue8</span> &#123;</span><br><span class="line">    <span class="comment">//定义有多少个皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//数组用来存放皇后放置的位置</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Queue8</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue8</span>();</span><br><span class="line">        q.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个方法用来放置皇后</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">8</span>)&#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; max;i++)&#123;</span><br><span class="line">            arr[n] = i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(judge(n))&#123;</span><br><span class="line">                <span class="comment">//如果不冲突 往下一个行的第一列开始</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来判断皇后放置的位置是否与前面的位置冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="comment">//如果放入皇后的位置和前面放置皇后的列和对角线一样的话</span></span><br><span class="line">            <span class="comment">//对角线的原理</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[n] || Math.abs(i - n) == Math.abs(arr[i] - arr[n]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p id="10"></p>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h4 id="为什么要引入树的概念"><a href="#为什么要引入树的概念" class="headerlink" title="为什么要引入树的概念"></a>为什么要引入树的概念</h4><blockquote>
<p>树也是用来存储数据的，在之前我们通过数组来存储数据，但是由于数组的增删效率比较低，于是我们又引入了链表，但是查找起来效率又比较低，于是树就诞生了</p>
</blockquote>
<h4 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h4><ul>
<li><p>节点</p>
</li>
<li><p>根结点</p>
</li>
<li><p>父节点</p>
</li>
<li><p>子节点</p>
</li>
<li><p>叶子节点</p>
<blockquote>
<p>没有子节点的节点</p>
</blockquote>
</li>
<li><p>节点的权</p>
<blockquote>
<p>节点的值</p>
</blockquote>
</li>
<li><p>节点的路径</p>
<blockquote>
<p>从root几点开始找到该节点的路线</p>
</blockquote>
</li>
<li><p>层</p>
<blockquote>
<p>root算第一层，依次向下递增</p>
</blockquote>
</li>
<li><p>二叉树</p>
<blockquote>
<p>最多只有两个子节点</p>
</blockquote>
</li>
</ul>
<h4 id="前序查找"><a href="#前序查找" class="headerlink" title="前序查找"></a>前序查找</h4><ul>
<li>先判断当前节点是否是要查找的</li>
<li>如果不是的话再去查找左节点，如果左节点是空的话就通过递归前序查找接着查</li>
<li>左边查完没有的话再去查找右边</li>
<li>如果查找到了直接将值进行返回</li>
</ul>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li>判断当前节点是否要查找的需要写在左查找完事之后</li>
</ul>
<h4 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h4><ul>
<li>判断当前节点是否要查找的需要写在左右查找完事之后</li>
</ul>
<h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><ul>
<li>大体思路<ul>
<li>删除节点需要判断当前节点的子节点点是否是要删除的</li>
<li>如果子节点不为空，那么就是删除该节点，如果不为空的话接着向下进行递归</li>
<li>右子节点也是同理</li>
<li>如果上述步骤没有删除节点的话，需要向左子树进行递归删除</li>
<li>如果还是没有再向右子树进行递归删除</li>
</ul>
</li>
</ul>
<h4 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h4><ul>
<li><p>二叉树的存储特点</p>
<p>  <code>第n个元素的左子节点为2 * n + 1</code></p>
<p>  <code>第n个元素的右子节点为2 * n + 2</code></p>
<p>  <code>第n个元素的父节点为(n - 1) / 2</code></p>
</li>
<li><p>顺序二叉树代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrdered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.preOrdered(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.midOrdered(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lastOrdered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.lastOrdered(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrdered</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，无法进行遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        <span class="comment">//向左进行递归</span></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrdered(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrdered(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            midOrdered(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            midOrdered(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lastOrdered</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length)&#123;</span><br><span class="line">            lastOrdered(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length)&#123;</span><br><span class="line">            lastOrdered(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h4><ul>
<li><p>基本介绍</p>
<blockquote>
<p>n个节点的二叉树链表中含有n + 1 个空指针域,公式为2n - (n - 1) &#x3D; n + 1,存在指向该节点在某种遍历次序下的前驱和后继节点的指针，这种指针称为线索</p>
</blockquote>
</li>
</ul>
<p>​	<code>在这里，left和right分别包含两种情况指向左子树，右子树或者是前驱节点和后继节点</code></p>
<ul>
<li><p>代码实现</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadTree</span><span class="params">(HeroNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先对左子树进行线索化</span></span><br><span class="line">        threadTree(node.getLeft());</span><br><span class="line">        <span class="comment">//线索化当前节点</span></span><br><span class="line">        <span class="comment">//线索化前驱</span></span><br><span class="line">        <span class="keyword">if</span>(node.getLeft() == <span class="literal">null</span>)&#123;</span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//线索化后继</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; node.getRight() == <span class="literal">null</span>)&#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再线索化右子树</span></span><br><span class="line">        threadTree(node.getRight());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历线索化二叉树</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//从root节点开始进行遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"><span class="comment">//        去查找leftType = 1的节点也就是前驱节点</span></span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node.getLeftType() == <span class="number">0</span>)&#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>)&#123;</span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><ul>
<li><p>简单介绍 </p>
<blockquote>
<p>堆排序是选择排序，不稳定，时间复杂度是O(nlogn), 每个节点的值都大于等于左右孩子的值称为大顶堆，每个孩子的值都小于等于左右孩子的值称为小顶堆</p>
</blockquote>
</li>
<li><p>大体思想</p>
<ol>
<li>将待排序序列构建成一个大顶堆，此时最大值就是根结点</li>
<li>将其与末尾元素进行交换，此时末尾就是最大值</li>
<li>然后将剩余的元素重新构建成一个堆，接着上述操作就会得到一个有序的序列了</li>
</ol>
</li>
<li><p>代码实现(升序排序)</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对第一个非叶子节点进行调整</span></span><br><span class="line">        <span class="comment">//adjustHeap(arr,1,arr.length);</span></span><br><span class="line">        <span class="comment">//对第二个非叶子点进行调整</span></span><br><span class="line">        <span class="comment">//adjustHeap(arr,0, arr.length);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.通过非叶子节点对数组进行调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使最大元素沉底</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="comment">//保留最初始的值，因为后面要不断的对arr[i]进行修改</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;k &lt; length;k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//让k指向右子节点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123;</span><br><span class="line">                <span class="comment">//将大值赋值给非叶子节点</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                <span class="comment">//将i指向k接着向下进行该操作</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><ul>
<li><p>概念</p>
<p>  ​	路径的基本概念： 从根结点出发到达孩子或者是孙子节点的通路叫做路径，路径的公式是L - 1</p>
<p>  ​	带权路径的长度(WPL)计算公式: 叶子节点的权 * 路径</p>
<p>  ​	<code>带权路径长度最小的值就是哈夫曼树</code></p>
</li>
<li><p>构建哈夫曼树</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 将数组中的每一个元素放入到集合当中</span></span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : arr)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size() != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//对集合进行排序</span></span><br><span class="line">            Collections.sort(list);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取出两个权值最小的子节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> list.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//计算两个树的和并且将两个子节点挂在到他两边</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node1.val + node2.val);</span><br><span class="line">            parent.left = node1;</span><br><span class="line">            parent.right = node2;</span><br><span class="line"></span><br><span class="line">            list.remove(node1);</span><br><span class="line">            list.remove(node2);</span><br><span class="line"></span><br><span class="line">            list.add(parent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终返回到是哈夫曼树的根结点，通过这个根结点进行前序遍历</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><ul>
<li><p>通信编码发展史</p>
<ul>
<li>通过ASCII码值值转二进制来解决，但是二进制码长度过大，不方便解析</li>
<li>变长编码： 1 : a 01 : b这种方式但是可能会出现解析重码的可能，信息解析错误</li>
<li>哈夫曼编码</li>
</ul>
</li>
<li><p>原理图</p>
<p>  <img src="/Users/satrol_/Desktop/NotepadImg/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="哈夫曼编码"></p>
</li>
<li><p>思路分析</p>
<ul>
<li><p>Node {data(存放数据) ，wieght(存放出现的个数) , left , right}</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HNode</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;HNode&gt;&#123;</span><br><span class="line">    Byte data; <span class="comment">//存放数据本身</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">//数字的权重</span></span><br><span class="line">    HNode left;</span><br><span class="line">    HNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HNode</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//从小到大进行排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(HNode o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>得到字符对应的byte数组</p>
</li>
<li><p>将数据以及个数一块放入到List数组中</p>
</li>
<li><p>通过List创建哈夫曼树</p>
</li>
<li><p>创建一个Map&lt;Byte,String&gt; 从来存储子节点和其对应的哈希编码</p>
</li>
<li><p>创建一个StringBuffer用来拼接路径作为哈希编码</p>
</li>
<li><p>压缩字符串</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="comment">//封装一个方法用来执行整个步骤</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes)&#123;</span><br><span class="line">        <span class="comment">//通过byte创建集合</span></span><br><span class="line">        List&lt;HNode&gt; nodes =  getNodes(bytes);</span><br><span class="line">        <span class="comment">//通过集合构建哈夫曼树</span></span><br><span class="line">        <span class="type">HNode</span> <span class="variable">huffmanTree</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//通过哈夫曼树来获取Map映射</span></span><br><span class="line">        Map&lt;Byte,String&gt; huffCode = getCodes(huffmanTree);</span><br><span class="line">        <span class="comment">//最后进行压缩操作</span></span><br><span class="line">        <span class="type">byte</span>[] res = zip(bytes,huffCode);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//将字符串转化的byte数组通过Map映射</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> List&lt;HNode&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span>&#123;</span><br><span class="line">        List&lt;HNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Byte,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">byte</span> b : bytes)&#123;</span><br><span class="line">            map.put(b,map.getOrDefault(b,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将每一个键值对转化成为一个Node对象，并加入到nodes集合中</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Byte,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HNode</span>(entry.getKey(),entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HNode <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;HNode&gt; nodes)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="type">HNode</span> <span class="variable">node1</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">HNode</span> <span class="variable">node2</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="type">HNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HNode</span>(<span class="literal">null</span>,node1.weight + node2.weight);</span><br><span class="line">            parent.left = node1;</span><br><span class="line">            parent.right = node2;</span><br><span class="line"></span><br><span class="line">            nodes.remove(node1);</span><br><span class="line">            nodes.remove(node2);</span><br><span class="line"></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将哈夫曼编码放入到Map&lt;Byte,String&gt;中</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanCode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Byte,String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成哈夫曼编码需要拼接路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title function_">getCodes</span><span class="params">(HNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root.left,<span class="string">&quot;0&quot;</span>,stringBuilder);</span><br><span class="line">        getCodes(root.right,<span class="string">&quot;1&quot;</span>,stringBuilder); </span><br><span class="line">        <span class="keyword">return</span> huffmanCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取所有node节点的叶子节点，并且放入到huffmanCode集合中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 路径 左子节点 0 右子节点 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用来拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(HNode node,String code,StringBuilder stringBuilder)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        sb.append(code);</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.data == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//当访问的节点是非叶子节点</span></span><br><span class="line">                <span class="comment">//向左进行递归</span></span><br><span class="line">                getCodes(node.left,<span class="string">&quot;0&quot;</span>,sb);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right,<span class="string">&quot;1&quot;</span>,sb);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//叶子节点</span></span><br><span class="line">                huffmanCode.put(node.data,sb.toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//将原来的byte数组根据huffman表进行压缩处理 即二进制转化成十进制进行返回的操作</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zip(<span class="type">byte</span>[] bytes,Map&lt;Byte,String&gt; huffmanCode)&#123;</span><br><span class="line">        <span class="comment">//利用哈夫曼表将原来的byte数组转化成新的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">byte</span> b : bytes)&#123;</span><br><span class="line">            stringBuilder.append(huffmanCode.get(b));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">if</span>(stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建压缩后的byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stringBuilder.length();i += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="comment">//substring(i,i + 8)是可能出现越界的情况</span></span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">8</span> &gt; stringBuilder.length())&#123;</span><br><span class="line">                <span class="comment">//这么写也相当于是从这个点开始截取到最后</span></span><br><span class="line">                str = stringBuilder.substring(i);</span><br><span class="line"><span class="comment">//                str = stringBuilder.substring(i, stringBuilder.length());</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                str = stringBuilder.substring(i,i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将八位二进制转化成十进制放入到byte数组当中</span></span><br><span class="line">            by[index++] = (<span class="type">byte</span>) Integer.parseInt(str,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> by;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压数据代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据的解压</span></span><br><span class="line">    <span class="comment">//对压缩数据进行解压</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCode,<span class="type">byte</span>[] huffmanBytes)&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; huffmanBytes.length;i++)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            stringBuilder.append(byteToBitString(!flag,huffmanBytes[i]));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Byte&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Byte,String&gt; origin : huffmanCode.entrySet())&#123;</span><br><span class="line">            map.put(origin.getValue(),origin.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stringBuilder.length();)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);</span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="keyword">if</span>(b == <span class="literal">null</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            i += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将十进制转化成二进制的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag,<span class="type">byte</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        <span class="comment">//将十进制转化成二进制</span></span><br><span class="line">        <span class="comment">//但是如果传入的是正数的话前面的零会省略掉</span></span><br><span class="line">        <span class="comment">//ex: -1 -&gt; 10000001   1 -&gt; 1</span></span><br><span class="line">        <span class="comment">//我们需要进行补位 |</span></span><br><span class="line">        <span class="comment">//按位与的规则是相同的不变不同的1来覆盖</span></span><br><span class="line">        <span class="comment">//256 -&gt; 100000000 | 00000001 -&gt; 100000001 截取八位就是00000001</span></span><br><span class="line">        <span class="comment">//如果满足八位才进行按位与的操作</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">        <span class="comment">//这也是判断是否有八位的可能</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>使用哈夫曼编码对文件进行压缩</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//srcFile 希望压缩的文件的路径</span></span><br><span class="line">    <span class="comment">//destFile 压缩到那个目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fileZip</span><span class="params">(String srcFile,String destFile)</span>&#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件的输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件一样大小的byte数组</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//将srcFile文件读取到b中</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//对文件进行压缩操作</span></span><br><span class="line">            <span class="type">byte</span>[] res = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流 存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            <span class="comment">//创建一个和输出流相关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//通过对象流的方式写入哈夫曼编码后的字节文件</span></span><br><span class="line">            oos.writeObject(res);</span><br><span class="line">            <span class="comment">//再将哈夫曼编码写入到压缩文件中</span></span><br><span class="line">            oos.writeObject(huffmanCode);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>对文件进行解压</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 需要解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destFile 解压到哪里</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unzip</span><span class="params">(String zipFile,String destFile)</span>&#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            <span class="comment">//创建和is相关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组和哈夫曼表</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[])ois.readObject();</span><br><span class="line">            Map&lt;Byte,String&gt; huffmanCode = (Map&lt;Byte,String&gt;)ois.readObject();</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCode,huffmanBytes);</span><br><span class="line">            <span class="comment">//写入目标文件中</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>哈夫曼编码压缩文件注意事项</p>
<ul>
<li>如果文件本身经过了压缩，压缩效率不会有明显的变化</li>
<li>哈夫曼编码按字节处理，因此可以处理所有的文件</li>
<li>文件内容重复数据不多，压缩内容不明显</li>
</ul>
</li>
</ul>
<h4 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h4><ul>
<li><p>简单介绍</p>
<blockquote>
<p>通过非叶子节点左边比当前值小，右边比当前值大的机制来进行排序</p>
</blockquote>
</li>
<li><p>二叉排序树的创建与遍历</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="comment">//添加节点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) root = node;</span><br><span class="line">        <span class="keyword">else</span> root.addNode(node);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root.midOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加节点的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//判断添加进来的节点和当前节点的大小</span></span><br><span class="line">        <span class="keyword">if</span>(node.val &lt; <span class="built_in">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//如果当前节点的左子姐弟哪为null</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.left.addNode(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.right.addNode(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.left.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.right.midOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li><p>思路分析</p>
<blockquote>
<p>第一种情况 </p>
<p>删除叶子节点</p>
<blockquote>
<p>首先需要找到删除的结点</p>
<p>找到他的父结点，判断是左子结点还是右子结点</p>
<p>通过parent.left &#x3D; null ,parent.right &#x3D; null</p>
</blockquote>
</blockquote>
<blockquote>
<p>第二种情况</p>
<p>删除只有一棵子树的节点</p>
<blockquote>
<p>定义当前节点为curNode 父节点为parent</p>
<p>如果当前节点有左子结点，curNode是父节点的左子节点 </p>
<p>parent.left &#x3D; curNode.left</p>
<p>如果当前节点有右子结点，curNode是父节点的左子节点 </p>
<p>parent.left &#x3D; curNode.right</p>
<p>如果当前节点有右子结点，curNode是父节点的右子节点 </p>
<p>parent.right  &#x3D; curNode.right</p>
<p>如果当前节点有左子结点，curNode是父节点的右子节点 </p>
<p>parent.right &#x3D; curNode.left</p>
</blockquote>
</blockquote>
<blockquote>
<p>第三种情况</p>
<p>删除有两个子树的结点</p>
<blockquote>
<p>找到删除结点的结点curNode</p>
<p>用一个临时变量存储当前结点右子树中最小的结点</p>
<p>curNode.val &#x3D; temp;</p>
</blockquote>
</blockquote>
</li>
<li><p>查找当前节点代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">searchVal</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//如果查找的节点等于当前节点将其进行返回</span></span><br><span class="line">        <span class="keyword">if</span>(val == <span class="built_in">this</span>.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; <span class="built_in">this</span>.val)&#123;</span><br><span class="line">            <span class="comment">//如果查找的节点大于当前节点将其进行返回 往右找</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明找不到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.searchVal(val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.searchVal(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  查找父节点</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找当前节点的父结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.val == val || <span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &lt; <span class="built_in">this</span>.val &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt;= <span class="built_in">this</span>.val &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  删除节点</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除最小节点的代码(用来删除左右都有子节点的节点) </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delMinNode</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        delNode(cur.val);</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 查找删除的节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> searchCur(value);</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果删除当前节点没有父亲那么说明当前节点一定是root节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//代表删除的节点是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(parent.left != <span class="literal">null</span> &amp;&amp; parent.left.val == cur.val )&#123;</span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right != <span class="literal">null</span> &amp;&amp; parent.right.val == cur.val) &#123;</span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.left != <span class="literal">null</span> &amp;&amp; cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//寻找到右子树中最小的值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> delMinNode(cur.right);</span><br><span class="line">                <span class="comment">//让最小的值代替当前值</span></span><br><span class="line">                cur.val = minVal;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果删除的左子节点</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">                        parent.left = cur.left;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.right = cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//删除的如果是右子结点</span></span><br><span class="line">                    <span class="keyword">if</span>(parent.left.val == value)&#123;</span><br><span class="line">                        parent.left = cur.right;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        parent.right = cur.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>  删除二叉树注意点当删除到最后只有两个结点，并且此时可能根结点发生变化的话需要判断parent是否为空</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent.left.val == value) &#123;</span><br><span class="line">            parent.left = cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root = cur.left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(parent != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//删除的如果是右子结点</span></span><br><span class="line">        <span class="keyword">if</span>(parent.left.val == value)&#123;</span><br><span class="line">            parent.left = cur.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h4><ul>
<li><p>简单介绍</p>
<blockquote>
<p>平衡二叉树指的是左子树和右子树高度差的绝对值不超过1</p>
</blockquote>
</li>
<li><p>图解</p>
<p>  <img src="/Users/satrol_/Desktop/NotepadImg/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9B%BE%E8%A7%A3.png"></p>
</li>
<li><p>左高度，右高度求解</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LeftHeight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right.height();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左旋转和右旋转</p>
<blockquote>
<p>目的：为了使保证左子树和右子树的高度差小于等于1，从而实现平衡二叉树</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">       newNode.left = left;</span><br><span class="line">       newNode.right = right.left;</span><br><span class="line">       val = right.val;</span><br><span class="line">       newNode.right = right.right;</span><br><span class="line">       left = newNode;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">       newNode.right = right;</span><br><span class="line">       newNode.left = left.right;</span><br><span class="line">       val = left.val;</span><br><span class="line">       left = left.left;</span><br><span class="line">       right = newNode;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双旋转</p>
<p>  什么时候出现双旋转，当出现子树的左子节点和右子节点相差过大的时候就会需要双旋转来解决实际问题?</p>
<p>  ex : int[] arr &#x3D; {10,11,7,6,8,9}</p>
<p>  <code>双旋转的思路是先将子树左右节点差过大的那个节点进行左旋或者是右旋使该子树平衡再回到根结点接着进行左旋或者右旋使树变为平衡二叉树</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加完节点判断是否要进行左旋转</span></span><br><span class="line"><span class="keyword">if</span>(rightHeight() - LeftHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="literal">null</span> &amp;&amp; right.LeftHeight() &gt; right.rightHeight())&#123;</span><br><span class="line">        right.rightRotate();</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        leftRotate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(LeftHeight() - rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; left.rightHeight() &gt; left.LeftHeight())&#123;</span><br><span class="line">        left.leftRotate();</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        rightRotate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h4><p>B树，B+树</p>
<p><code>每一个节点存储的数据量上升，高度减少，不止有left和right，效率明显提升</code></p>
<p>应用场景：用于制作文件索引系统</p>
<p>B*树：在B+树的基础上在兄弟级节点之间建立了桥梁</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li><p>基本概念</p>
<blockquote>
<p>图是一种数据结构，用来处理多对多的情况</p>
</blockquote>
</li>
<li><p>表达方式</p>
<ul>
<li><p>邻接矩阵</p>
<blockquote>
<p>用来表示两个顶点之间的连通关系</p>
</blockquote>
</li>
<li><p>邻接表</p>
</li>
</ul>
</li>
</ul>
<h4 id="实现图"><a href="#实现图" class="headerlink" title="实现图"></a>实现图</h4><ul>
<li><p>初始化变量</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从来存储顶点的</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义二维数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;</span><br><span class="line">    <span class="comment">//线的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        vertList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义方法</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入结点</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertNode</span><span class="params">(String str)</span>&#123;</span><br><span class="line">       vertList.add(str);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//添加边</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAngle</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       matrix[x][y] = n;</span><br><span class="line">       matrix[y][x] = n;</span><br><span class="line">       num++;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="comment">//返回权值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> matrix[x][y];</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showEdge</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span>[] arr : matrix)&#123;</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示邻接矩阵</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="comment">//将顶点放入集合中</span></span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            g.insertNode(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        g.addAngle(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        g.addAngle(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        g.addAngle(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        g.addAngle(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        g.addAngle(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        g.showEdge();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h4><blockquote>
<p>每一次访问都在访问当前结点的邻接点</p>
</blockquote>
<p>算法实现步骤</p>
<ul>
<li>访问初始结点，标记为已连接</li>
<li>判断当前结点的下一个邻接点是否和当前结点连通，如果连通的话，就以将下一个结点作为起点重复上述操作</li>
<li>如果不连通的话，回到当前结点的上一个结点判断是否和该节点连通</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="comment">//记录结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        String[] str = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">g</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(String s : str)&#123;</span><br><span class="line">            g.insertArrayList(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A-B A-C B-C B-D B-E</span></span><br><span class="line">        g.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        g.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        g.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        g.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        g.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line">        g.showGraph();</span><br><span class="line"></span><br><span class="line">        g.dfs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 第一个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEdge</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2,<span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertArrayList</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        arrayList.add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumOfArrayLength</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getEdgeNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getValueByIndex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showGraph</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span>[] arr : edges)&#123;</span><br><span class="line">           System.out.println(Arrays.toString(arr));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFirstNeighbor</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arrayList.size();j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(edges[index][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> j;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNextNeighbor</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v2 + <span class="number">1</span>;i &lt; arrayList.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[v1][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] isVisited,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        isVisited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span>(w != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[w])&#123;</span><br><span class="line">                dfs(isVisited,w);</span><br><span class="line">            &#125;</span><br><span class="line">            w = getNextNeighbor(i,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; getNumOfArrayLength();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[i])&#123;</span><br><span class="line">                dfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h4><p>ss</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io">Satrol_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io/2023/05/07/CalculateForJava/">https://sloplerol.github.io/2023/05/07/CalculateForJava/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sloplerol.github.io" target="_blank">Freedom Coding</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Calculating/">Calculating</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/07/LeetCode_Note/" title="Leecode Brush Questions Journey"><img class="cover" src="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leecode Brush Questions Journey</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/Linux-Journey/" title="Linux"><img class="cover" src="https://w.wallhaven.cc/full/qz/wallhaven-qz3wel.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.6.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">2.0.7.</span> <span class="toc-text">基数排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">3.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-number">3.0.1.</span> <span class="toc-text">线性查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.0.2.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">3.0.3.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">3.0.4.</span> <span class="toc-text">斐波那契查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">5.0.1.</span> <span class="toc-text">实现线性表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">5.0.2.</span> <span class="toc-text">遍历线性表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%B9%E7%A7%AF%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">5.0.3.</span> <span class="toc-text">对于线性表的容积的改变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">7.0.1.</span> <span class="toc-text">队列的改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">8.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">9.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">10.0.1.</span> <span class="toc-text">为什么要引入树的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-number">10.0.2.</span> <span class="toc-text">常用术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">10.0.3.</span> <span class="toc-text">前序查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">10.0.4.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86"><span class="toc-number">10.0.5.</span> <span class="toc-text">后续遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">10.0.6.</span> <span class="toc-text">删除节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.0.7.</span> <span class="toc-text">顺序存储二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.0.8.</span> <span class="toc-text">线索化二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">10.0.9.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">10.0.10.</span> <span class="toc-text">哈夫曼树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">10.0.11.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91-BST"><span class="toc-number">10.0.12.</span> <span class="toc-text">二叉排序树(BST)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="toc-number">10.0.13.</span> <span class="toc-text">平衡二叉树(AVL树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">10.0.14.</span> <span class="toc-text">多路查找树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%BE"><span class="toc-number">11.0.1.</span> <span class="toc-text">实现图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS"><span class="toc-number">11.0.2.</span> <span class="toc-text">深度优先搜索(DFS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS"><span class="toc-number">11.0.3.</span> <span class="toc-text">广度优先搜索(BFS)</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Satrol_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my site !!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://sloplerol.github.io/2023/05/07/CalculateForJava/'
    this.page.identifier = '/2023/05/07/CalculateForJava/'
    this.page.title = 'CalculateForJava'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>