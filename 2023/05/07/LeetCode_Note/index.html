<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leecode Brush Questions Journey | Freedom Coding</title><meta name="author" content="Satrol_"><meta name="copyright" content="Satrol_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode刷题历程">
<meta property="og:type" content="article">
<meta property="og:title" content="Leecode Brush Questions Journey">
<meta property="og:url" content="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html">
<meta property="og:site_name" content="Freedom Coding">
<meta property="og:description" content="LeetCode刷题历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg">
<meta property="article:published_time" content="2023-05-07T13:06:30.000Z">
<meta property="article:modified_time" content="2023-05-29T14:47:10.428Z">
<meta property="article:author" content="Satrol_">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leecode Brush Questions Journey',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-05-29 22:47:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109008086?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Freedom Coding"><span class="site-name">Freedom Coding</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leecode Brush Questions Journey</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-07T13:06:30.000Z" title="发表于 2023-05-07 21:06:30">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-29T14:47:10.428Z" title="更新于 2023-05-29 22:47:10">2023-05-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leecode Brush Questions Journey"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h4><blockquote>
<p>由于之前做完题后没有进行梳理，作者会尽快再刷一遍，所以这边笔记专注于讲解大致思路，可能有些地方没有给出详细解释，真理蕴藏于代码之中，本片笔记暂时未完善，布局可能也不够完美，作者会尽量将每一个部分完善，请谅解😌</p>
</blockquote>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><blockquote>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
</blockquote>
<p>注意点</p>
<ul>
<li>数组的下标是从0开始的</li>
<li>数组中每一个元素的内存地址是连续的</li>
</ul>
<p>数组对于查找元素很方便，但是增删元素会导致后面元素的内存地址发生后移的效果，所以效率比较低</p>
<p><code>数组中的元素只能被覆盖，不能删除</code></p>
<p>在C++中内存地址是连续的，而在Java中内存地址是交给虚拟机进行寻址操作进行分配的</p>
<p>数组的理论基础介绍到这里，或多或少你也掌握了一些数组的基本知识点了</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>二分查找是对升序的数组进行查找操作，如果在数组中查找到元素，返回下标否则返回-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">2</span>;</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">10</span>;</span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>思路分析</p>
<p>二分查找的难点主要集中在考虑临界点情况 到底是while(left &lt; right) 还是while(left &lt;&#x3D; right)呢</p>
<p>在二分法中区间主要分为两种[left,right] 或者是 [left,right)</p>
<p>第一种写法: [left,right] </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right] 决定left 是否等于 right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">                right = midVal - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法[left,right)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right) 这是后while循环left &lt; right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">              <span class="comment">//因为右边取不到所以直接直接将right赋值为midVal</span></span><br><span class="line">                right = midVal;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">LeetCode链接</a></p>
<p>这道题给我们一个数组，并且给我们target，要求我们返回移除所有该元素后返回的新数组，和长度</p>
<p>暴力算法</p>
<p>思路分析</p>
<blockquote>
<p>对数组进行遍历，如果发现了有一个值和target相等在来一个for循环将数组后的所有元素进行前移操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">             		<span class="comment">//目标元素后面的元素进行操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//将下标前移 接着进行移位后的数组从i开始重复</span></span><br><span class="line">                i--;</span><br><span class="line">              	<span class="comment">//将数组总长度进行减1操作</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针法</p>
<p>思路分析</p>
<blockquote>
<p>定义一个快指针，定义一个慢指针，快指针用来遍历数组中的元素，如果不等于target的值的话才将值赋值给慢指针对应的下标，慢指针再做后移操作</p>
</blockquote>
<img src="/Users/satrol_/Desktop/NotepadImg/删除数组中元素.jpg" style="zoom:25%;" />

<p>如果是在不理解这里有一张我画的图解，fast向后查找如果查找到的目标值为1的话slow不需要进行后移操作，否则需要，最后将slow的大小进行返回即新数组的长度</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//返回慢指针的大小也就是新数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">链接地址</a></p>
<p>题意：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会想到双指针？</p>
<p><code>因为数组是有序的的那么最大值只能出现在两边，于是我们可以通过比较两边值的平方的方法，将大的值放入到新的数组中</code></p>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] newResult = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//一定是&lt;=否则会丢掉中间值的可能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = size;left &lt;= size;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] * nums[right] &gt; nums[left] * nums[left])&#123;</span><br><span class="line">                newResult[size--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//相等的情况放在哪种情况中都可以，就是不能丢掉</span></span><br><span class="line">                newResult[size--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">链接地址</a></p>
<p>题意：给出一个数组和一个target求出数组中长度最小的的连续子数组的和大于等于target的值的元素个数</p>
<p>暴力解法</p>
<blockquote>
<p>双层for循环，第一层for循环设置起始位置第二层for循环从起始位置开始到达终止位置判断是否满足条件，进行返回结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    min = Math.min(min,j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>滑动窗口</p>
<blockquote>
<p>其实还是双指针的想法，只不过左指针是在动态移动的，一层for循环用来移动右指针，发现一个满足条件的，移动左指针，看是否可以缩小范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,sum = <span class="number">0</span>,subLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLen = j - i + <span class="number">1</span>;</span><br><span class="line">                result = Math.min(subLen,result);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">链接地址</a></p>
<p>思路</p>
<blockquote>
<p>每一次循环考虑的只包含单个对角，然后再考虑转了几圈，如果是偶数的话转的圈数必然是n &#x2F; 2但是如果是奇数的话圈数也是n &#x2F; 2中间的那一个点需要单独处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++ &lt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = start;j &lt; n - loop;j++)&#123;</span><br><span class="line">                arr[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = start;i &lt; n - loop;i++)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时i，j已经到arr[n][n]处了</span></span><br><span class="line">            <span class="comment">//这部一定要 &gt;= loop </span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= loop;j--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= loop;i--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转完一圈起始位置会发生变化</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            arr[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><blockquote>
<p>数组往期的做法，很多人都可能采用两个for循环求解题目，上述这些题目带你初步了解如何通过双指针的想法仅仅用一个for循环来求解题目，希望写完题目后的你能自我反思自己是否要改变往常的双for循环的低效方法</p>
</blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是什么？</p>
<blockquote>
<p>每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
</blockquote>
<p>众所周知，链表分为好几大类</p>
<p><strong>单链表</strong>(每一个节点只有一个指向next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>双链表</strong>(每一个节点包含两个指向pre,next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>循环链表</strong>(主要用于解决约瑟夫问题)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png"></p>
<p>链表在内存中存储可不是连续的，所以主要用来进行增删操作</p>
<h4 id="如何定义链表"><a href="#如何定义链表" class="headerlink" title="如何定义链表"></a>如何定义链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">  	ListNode next;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(ListNode next,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8.png"></p>
<p>这里面暗藏了垃圾回收机制，那么什么是垃圾回收呢</p>
<p>见图解当删除D即没有东西指向D的时候D没有了任何作用就会触发垃圾回收机制</p>
<p>C++中需要手动释放，而Java Python中可以自动垃圾回收</p>
<p>添加链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png"></p>
<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/submissions/">链接地址</a></p>
<p>这道题需要考虑两种情况</p>
<ul>
<li>移除头节点 让头节点设置为head.next</li>
<li>移除非头节点 找到上一个节点让他的下一个节点指向当前节点的下一个节点</li>
</ul>
<p>如果想要以统一的方式删除节点就可以引入<code>虚拟头节点的概念</code></p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9.jpg"></p>
<p>先使用传统的方式去移除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果删除的是头节点的话 假如链表中元素都是1的话需要进行全部移除</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果删除的节点不是头节点的话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里面让当前节点指向head的目的是为了获取到删除节点的上一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//避免操作空指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      	<span class="comment">//定义虚拟头节点下一位指向head val设置为什么都可以 因为最后返回值是从head开始的</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">链接地址</a></p>
<p>这道题可以让你熟练的掌握链表的所有基本基本操作</p>
<p>为了迎合增删是否为头节点的问题本题使用虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目入口</a></p>
<p>这道题有两种做法双指针和递归</p>
<p>双指针</p>
<p>思路</p>
<p>我们可以定义一个pre初始化为空，在head的前面，通过双指针的思想不断移动pre和cur</p>
<p>临界条件：当pre为为节点cur为原来的尾节点后的null的时候截止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//临界条件是cur刚好为尾节点后的空节点，此时pre指向的就是为尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//保存cur的下一个值因为现在cur要指向他的前一个值了</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归写法：实际上还是双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre,cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre,ListNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目入口</a></p>
<p>思路</p>
<p>这道题需要使用虚拟头节点，可能有人问为什么使用虚拟头节点，这是因为你要操作head这个元素所以肯定要用到它的前一个节点</p>
<p>图解</p>
<img src="/Users/satrol_/Desktop/NotepadImg/交换节点.jpg" style="zoom:35%;" />

<p><strong>如上图所见dummyhead使用来操作两个节点的每一次都是作为前一个节点的前面的节点</strong></p>
<p>接下来需要考虑临界条件</p>
<p>这里包含两种情况</p>
<ul>
<li><p>偶数的时候 dummyhead.next &#x3D;&#x3D; null</p>
</li>
<li><p>奇数的时候 dummyhead.next.next &#x3D;&#x3D; null </p>
</li>
<li><p>以上两种情况必须同时满足</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//temp 和 temp1需要保存下来因为下面在进行修改</span></span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">           cur.next = cur.next.next;</span><br><span class="line">           cur.next.next = temp;</span><br><span class="line">           temp.next = temp1;</span><br><span class="line">           cur = cur.next.next;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//正如上图所见，head发生了变化所以需要将dummyhead.next作为头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/">题目入口</a></p>
<p>这道题还是一个双指针问题</p>
<p>思路</p>
<blockquote>
<p>定义快慢指针，先让快指针移动n步，再让慢指针跟着慢指针同时进行移动操作，但是这时候你发现了另一个问题，虽让慢指针定位到了要删除的元素身上，当时无法对他进行操作，所以要让快指针移动n + 1步，此时慢指针才会定位到要删除元素的前一个节点的身上</p>
</blockquote>
<p>临界条件判断：当快指针为空的时候结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">题目入口</a></p>
<p>思路</p>
<p>当两条长度不一的情况下求出差值让长链表移动差值次，接着比较每一次的值是否相等，决定返回值是什么</p>
<img src="/Users/satrol_/Desktop/NotepadImg/双链表相交点.jpg" style="zoom:40%;" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>,lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">//获取两条链表的长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//因为curA此时已经为空需要重置</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">				<span class="comment">//让长的链表为curA</span></span><br><span class="line">        <span class="keyword">if</span>(lenB &gt; lenA)&#123;	</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempVal</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = tempVal;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curA;</span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//求差值</span></span><br><span class="line">        cha = lenA - lenB;</span><br><span class="line">     		<span class="comment">//长链表后移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; cha;i++)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">				<span class="comment">//判断是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span> &amp;&amp; curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目入口</a></p>
<p>这道题让我们判断是否能成环，尾部连接到那一个节点</p>
<p>这道题可以使用快慢指针的思路来解决，为什么想到用这种方式来解决呢？</p>
<p><strong>判断是否成环</strong></p>
<blockquote>
<p>因为链表如果成环的话，那么快慢指针能够相遇</p>
<p>那为什么快指针可以和慢指针相遇呢？</p>
<p>比如快指针的速度为2，慢指针的速度为1，那么差值为1，快指针一直以1的速度无限接近于慢指针，肯定是能碰到的</p>
</blockquote>
<p><strong>判断在哪相遇</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/环形链表.jpg" style="zoom:40%;" />



<p>这个图是有很多注意点的</p>
<ul>
<li>由于快指针比慢指针快所以相遇的圈数一定大于等于1</li>
<li>慢指针走过的圈数一定没有1圈，假如快指针速度为2，慢指针速度为1，那么最坏的情况也是在圈中间相遇</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">      	<span class="comment">//fast来判断为null的情况</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">              	<span class="comment">//参考上面图解x = z</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//返回相遇的节点index1和2都行</span></span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到相遇的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>什么是哈希表呢？</p>
<p>哈希表又称散列表，根据关键码的值而直接进行访问的数据结构，数组就是通过下标来进行访问的也就是一张哈希表</p>
<p>哈希表主要使用来干什么的？</p>
<p><strong>用来判断集合中是否出现了某一个元素</strong></p>
<p>将时间复杂度大大的降低了</p>
<p>哈希函数是什么？</p>
<p>比如将每一个人的信息映射到下标索引身上，通过查询下标来判断是谁</p>
<p>注意这里面将每一条数据信息转化为hashCode数值</p>
<p>那么如果hashCode得到的值大于哈希表的长度的话，该如何解决</p>
<p><strong>我们可以通过取模的方式(hashCode &#x2F; HashTable)进行解决</strong></p>
<p><strong>常见的问题：哈希碰撞</strong></p>
<p>什么是哈希碰撞？</p>
<blockquote>
<p>两条数据同时映射到哈希表的同一个位置上</p>
</blockquote>
<ul>
<li><p>解决方法1:  拉链法</p>
<p>  将两条数据同时存储到该位置上</p>
<hr>
<p>  其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
</li>
<li><p>解决方法2: 线性探测法</p>
<p>  前提：hastable足够大，通过空位的方式来存放碰撞的值</p>
</li>
</ul>
<p>常见实用哈希法来完成的三种数据结构</p>
<ul>
<li>Map</li>
<li>Set</li>
<li>数组</li>
</ul>
<h4 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">题目入口</a></p>
<p>思路分析</p>
<p>这道题我们可以使用哈希表+数组的方式来解决，为什么呢？</p>
<blockquote>
<p>因为统计的是小写字母，ASCII码值是连续的，可以将a代表数组下标为0，z对应数组下标为25</p>
</blockquote>
<p>当然Map来解决也是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      	<span class="comment">//通过字符串的toCharArray方法将字符串中的每一个字符拆分开来</span></span><br><span class="line">        <span class="type">char</span>[] c1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = t.toCharArray();</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            arr[c1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; c2.length;j++)&#123;</span><br><span class="line">            arr[c2[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">题目入口</a></p>
<p>为什么我们想到用哈希表来解决这道题？</p>
<p><strong>因为哈希表往往是用来查找集合中是否包含某个元素</strong></p>
<p>三种数据类型我们应该选择哪种，针对于这道题来说，尽量不要选择数组来解决该问题，因为数据够大，使用数组需要开辟很多的内存空间，所以我们优先选择set来解决</p>
<p><code>Set还有一个优势就是可以帮助我们去重数组，放置结果中出现两个重复的元素</code></p>
<p>解题思路</p>
<p>查找两个数组重复元素，我们可以将一个数组放入到集合当中，然后判断另一个数组中的元素是否在当前集合中出现过，如果出现过的话放入到新数组中，最后将集合转化为数组，解决此问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int index = 0;</span></span><br><span class="line">        <span class="comment">//int[] arr = new int[result.size()];</span></span><br><span class="line">        <span class="comment">//for(int i : result)&#123;</span></span><br><span class="line">            <span class="comment">//arr[index++] = i;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return arr;</span></span><br><span class="line">     		<span class="keyword">return</span> result.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>LeetCode中后来将数据改成了1000所以可以使用数组来解决，不过在Java中不用Set没有直接对数组去重的操作，所以不推荐在Java中使用数组使用该题</strong></p>
<p>数组的大体思路是创建一个1010的数组，将num1的值对应的数组下标设置为1，将num2去重，判断在数组中num2下标对应的值是否是1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            arr[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得不重复的nums2</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[list.get(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                res.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size();i++)&#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">题目入口</a></p>
<p>思路</p>
<p>可以拆分出来一个方法专门用来求每一项的平方，可以借助Set集合来判断之前的集合中是否包含之前计算出来过的元素，如果包含说明肯定不是，那么就让他不停的进行循环操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getSum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> digital;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digital = n % <span class="number">10</span>;</span><br><span class="line">            sum += digital * digital;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">题目入口</a></p>
<p>思路分析</p>
<p>这道题如果使用暴力很简单，这里就直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>显然时间复杂度为O(n * 2)不太好</p>
<p>接下来使用哈希法来解决</p>
<p>在写代码之前讲一下大体思路</p>
<p>我们可以通过map的方式来记录每一个下标和他的对应的值，通过查找target - 当前对应的值，返回下标，从而得到两个下标</p>
<p><strong>注意点：不要先把每一个值上来就都放入到map中，如果这样加入nums是[3,3] 返回到下标就是[0,0]，而我们要的结果是[0,1]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">题目入口</a></p>
<p>解题思路</p>
<p>我们可以将四个数组拆分成两对，第一对遍历前两个数组，通过Map的方式来记录a + b的值作为key 出现的次数记为value，再去遍历另一对两个数组记录key为- (c + d) ,因为要使a + b + c + d &#x3D; 0 , a + b &#x3D; - (c + d)</p>
<p>注意点：如果a + b 出现了 - ( c + d)匹配的值的话就加上a + b对应的value值  </p>
<p>ex : a + b : 3 出现了一个- (c + d)匹配那么次数就应该加3</p>
<p>可能有的人认为为什么不将四个数组分成分成1 和 3 因为3的时间复杂度为O(n * 3) 而分成2 * 2 时间复杂度才O(n * 2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                map.put(nums1[i] + nums2[j],map.getOrDefault(nums1[i] + nums2[j],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span> * (nums3[i] + nums4[j]);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">                    count += map.get(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/submissions/">题目链接</a></p>
<p>思路和有效字母异位词一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = ransomNote.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = magazine.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] ch = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c2.length;i++)&#123;</span><br><span class="line">            ch[c2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            ch[c1[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">题目链接</a></p>
<p>思路分析，因为要获取到的是三个数的值，和统计出现的次数可不太一样，使用哈希表的方法来解决是很麻烦的</p>
<p><strong>所以我们能想到双指针的方法来解决，排序数组之后定义第一个数<code>i</code>用来走遍数组，接着定义的两个指针布局于<code>i + 1</code> , <code>len - 1</code>,通过三数之和判断是否等于0移动指针</strong></p>
<p>注意事项</p>
<ul>
<li>如果第一个数大于0那么就不用判断了</li>
<li>判断i 是否重复</li>
<li>判断left 和right 是否重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果发现i重复利用的情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">题目入口</a></p>
<p>思路</p>
<p>延续了三数之和的方法在三数for循环的外面再套一层循环</p>
<p>注意点</p>
<ul>
<li><p>由于可能出现负数的情况所以剪枝操作是不行的,因为两个负数相加变得会越来越小</p>
<blockquote>
<p>剪枝操作就是三数之和判断首位元素 &gt; target 就直接返回</p>
</blockquote>
<p>  如果要做剪枝的话需要判断首位元素是否大于0</p>
</li>
<li><p>去重操作</p>
</li>
<li><p>外层需要剪枝操作和去重操作，内层只需要去重判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) <span class="keyword">return</span> list;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">题目入口</a></p>
<p>思路：</p>
<p>根据题意，返回的还是原数组，所以我们需要通过双指针的方式来交换首尾元素</p>
<p>双指针方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过for循环每一次走过的路径都是2k反转内部长度为k的字符串</p>
<p>注意事项</p>
<blockquote>
<p>需要判断i + k是否超过了整个字符串的长度，如果超过了反转i到字符串长度的字符即可，否则反转i 到i + k范围内的字符</p>
</blockquote>
<p>最直白的写法(时间有点多)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt; len)&#123;</span><br><span class="line">                s = reverse(s,i,i + k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = reverse(s,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来翻转字符串下标从j到k之间的字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧用StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> i + k &gt; len ? len : i + k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondK</span> <span class="operator">=</span> i + <span class="number">2</span> * k &gt; len ? len : i + <span class="number">2</span> * k;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            temp.append(s.substring(i,firstK));</span><br><span class="line">            result.append(temp.reverse());</span><br><span class="line">						<span class="comment">//如果第一个k和第二个k之间有元素的话，需要截取</span></span><br><span class="line">            <span class="keyword">if</span>(firstK &lt; secondK)&#123;</span><br><span class="line">                result.append(s.substring(firstK,secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">题目入口</a></p>
<p>显然这道题肯定不是让你调用库函数的题</p>
<p>可以通过StringBuffer来判断是否是空格，条件判断执行不同的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针通过扩容机制来解决</p>
<p>思路</p>
<p><em><em>我们可以扩容空格的个数</em> 2倍，通过双指针判断是否为空格来进行填充%20操作</em>*</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//扩容两倍</span></span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始定义双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目入口</a></p>
<p>本题思路</p>
<p>先对字符串的前后进行去除空格的操作，然后对中间进行去除空格的操作，最后对整个字符串进行反转操作，通过split方法分割多个字符串，然后对每一个字符串进行反转操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//用来去除两边的空格</span></span><br><span class="line">        <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(right) == <span class="string">&#x27; &#x27;</span>) right--;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span> &amp;&amp; s.charAt(left + <span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] firstReverse = sb.reverse().toString().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; firstReverse.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != firstReverse.length - <span class="number">1</span>)&#123;</span><br><span class="line">                result += reverse(firstReverse[i]) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += reverse(firstReverse[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            temp = ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目入口</a></p>
<p>思路分析</p>
<p>左旋转2翻译人话就是将最左边的两个元素放入到最右边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> s.substring(n,s.length());</span><br><span class="line">        <span class="keyword">return</span> str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><blockquote>
<p>主要解决字符串匹配的问题</p>
</blockquote>
<p>ex : str1 &#x3D; “aabaabaaf” str2 &#x3D; “aabaaf”</p>
<p>判断是否str1中出现了str2 ？</p>
<p>正常来说我们会通过双层for循环的方法逐一进行匹配，但是时间复杂度是两个字符串长度的乘积，效率很low</p>
<p>KMP算法的实现原理</p>
<p>还是以str1和str2为例,我们首先进行逐一匹配发现在b和f的位置上无法匹配了那么就会回到之前匹配过的b上接着进行匹配</p>
<p>如果不太理解可以看这张图</p>
<img src="/Users/satrol_/Desktop/NotepadImg/KMP.jpg" style="zoom:40%;" />

<ul>
<li><p>前缀</p>
<blockquote>
<p>包含首元但不包含尾元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; a，aa，aab，aaba，aabaa</p>
</li>
<li><p>后缀</p>
<blockquote>
<p>包含尾元但不包含首元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; f，af，aaf，baaf，abaaf</p>
</li>
<li><p>通过匹配的字符串获取到的前缀表</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>前缀</th>
<th>后缀</th>
<th>相等前后缀</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a, aa</td>
<td>b, ab</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a, aa, aab</td>
<td>a, ba, aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a, aa, aab,aaba</td>
<td>a, aa, baa, abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a, aa, aab, aabaa</td>
<td>f, af, aaf, baaf,abaaf</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<p>得到前缀表后我们应该去找不匹配元素的前面的一个元素的值，即2，代表了前缀中有一个和后缀相等的字符串，从这个字符串的后面接着开始匹配，这个元素的下标就是最长相等前后缀的值</p>
<p>next数组的不同实现方式</p>
<ul>
<li>原封不动的将前缀表作为next数组</li>
<li>将前缀表右移，将第一个设置为-1，作为新的next数组</li>
<li>将前缀表整体减1，作为next数组</li>
</ul>
<p>next数组实现包含四步</p>
<ul>
<li><p>初始化操作</p>
<p>  定义两个指针i，j分别代表后缀起始位置和前缀起始位置</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure>

<hr>
<p>  这里设置j为-1是因为我们采用的是统一减1的实现方式</p>
</li>
<li><p>判断前后缀不相等的情况</p>
<p>  j里面记录着包括j之前子串中相等前后缀的数量</p>
<p>  当发现前后缀的值不相等的话就需要回退到j + 1的前一个值对应的索引</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>判断前后缀相等的情况</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i)) j++;</span><br></pre></td></tr></table></figure>

</li>
<li><p>更新next数组</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) == s.charAt(j + <span class="number">1</span>))&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>next数组实现完毕，接下来看我们该如何进行使用</p>
<p>我们要在文本串(s)中查找模式串(t)</p>
<p>定义两个指针i从文本串的起始位置开始，j从模式串的起始位置开始</p>
<p>j的初始值是-1 ，i的初始值为1 ，接着对i 和 j + 1进行比较</p>
<p>因为要对模式串和文本串进行一一比较所以i我们要从0开始</p>
<ul>
<li><p>如果文本串和模式串无法匹配</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//j &gt;= 0 是为了防止j = next[-1]的情况</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="comment">//跳转位置</span></span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何匹配了的话</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i和j同时向后移动 因为i在循环中</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>]) j++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断匹配成功了呢</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j指向了模式串的末尾的话即匹配成功</span></span><br><span class="line"><span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> i - t.length() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">				reutrn i - t.length() + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">题目入口</a></p>
<p>最直白的方法indexOf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j + <span class="number">1</span>)) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j + <span class="number">1</span>)) j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == needle.length() - <span class="number">1</span>) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">题目地址</a></p>
<p>移动匹配</p>
<p>思路</p>
<p>如果一个字符串是由重复子串构成的话，那么这个字符串的前半部分和后半部分是相同的，于是我们可以再添加一个这个字符串，截取掉拼接好的字符串的两边，判断中间是否包含原来的字符串 &#x3D;&gt; 前半部分的尾元 + 后半部分的首元</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> concat.substring(<span class="number">1</span>,concat.length() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.indexOf(s) != -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h3 id="栈和队列理论基础"><a href="#栈和队列理论基础" class="headerlink" title="栈和队列理论基础"></a>栈和队列理论基础</h3><blockquote>
<p>栈是先进后出，队列是先进先出</p>
</blockquote>
<p>栈和队列都是属于STL（C++标准库）里面的数据结构</p>
<p>常见的STL版本</p>
<ul>
<li><p>HP STL</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</span><br></pre></td></tr></table></figure>

</li>
<li><p>P.J.Plauger STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>SGI STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">题目入口</a></p>
<p>思路</p>
<p>通过两个栈来实现队列，一个是in栈，还有一个是out栈，将一组数据放入到in栈中，再将这组数据从in栈中弹出放入到out栈中，此时弹出来的顺序就是正确的了</p>
<img src="/Users/satrol_/Desktop/NotepadImg/栈实现队列.jpg" style="zoom:33%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpInStackOut</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//如果out栈为空说明已经将in栈推送到了out栈中 </span></span><br><span class="line">        <span class="keyword">if</span>(!stackOut.empty()) <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">//如果in栈不为空说明需要将内容push到out栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.empty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以通过一个队列或者是两个队列来实现栈</p>
<p>两个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line">    Deque&lt;Integer&gt; que2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//第二个队列主要用来备份除栈中第一个元素外其余的元素</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que2.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> que1.peekFirst();</span><br><span class="line">        que1.pollFirst();</span><br><span class="line">        que1 = que2;</span><br><span class="line">      	<span class="comment">//这种方式来清空que2中残留的数据更加直观</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;	</span><br><span class="line">      	<span class="comment">//队尾即栈顶</span></span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.addLast(que.peekFirst());</span><br><span class="line">            que.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//这里面的栈顶就是队尾</span></span><br><span class="line">        <span class="keyword">return</span> que.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过栈来解决本题，如果遇到了左括号就将与之对应的右括号入栈，当遇到了右括号就可以和之前的右括号进行消除</p>
<p>本题需要考虑三种情况</p>
<ul>
<li>消除到最后栈中包含某个右括号没有被消除</li>
<li>在遇到右括号的时候发现栈顶元素并不是右括号</li>
<li>字符串在遇到右括号需要消除的时候，栈内没有元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.peek() != s.charAt(i))&#123;</span><br><span class="line">              	<span class="comment">//第二种情况和第三种情况放在一起进行考虑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以用栈来解决这道题目</p>
<blockquote>
<p>定义一个栈，遍历字符串添加条件判断语句将重复连续的元素进行去除后，因为栈pop出来的字符串是反序的所以需要我们去反转一下栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == s.charAt(i))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//反转栈的操作</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将字符串作为栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="comment">//重复的情况</span></span><br><span class="line">            <span class="keyword">if</span>(top &gt;= <span class="number">0</span> &amp;&amp; ch == res.charAt(top))&#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(ch);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span></span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目入口</a></p>
<p>什么是逆波兰表达式</p>
<blockquote>
<p>方便计算机计算的表达式</p>
</blockquote>
<p>平常比较常见的是中缀表达式</p>
<p>ex: (1 + 2) * 3</p>
<p>切换成后缀表达式就是</p>
<p>ex : 1 2 + 3 *</p>
<p>思路分析</p>
<p>正常来说如果没有遇到操作符的话，就将其转化为数字放入到栈中，如果遇到了，我们可以pop出两个元素对这两个元素进行运算，最后栈中只留下了一个值，也就是答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">题目入口</a></p>
<p>这道题如果用暴力的话时间复杂度是O(n * k)，很容易就超时</p>
<p>思路</p>
<p>我们可以使用队列来解决本题，每一次滑动窗口移动的时候，我们可以将首元进行pop将新加入的尾元进行push，最后再去获得这组数据中的最大值</p>
<blockquote>
<p>在C++中有优先级队列的概念，但是如果你使用了优先级队列的话，那么每一次数据都是排序好的，你如果pop的话就会将最大值弹出和预期弹出的值不相符</p>
</blockquote>
<p>单调队列模拟</p>
<p>首先确定k的大小，初始化</p>
<p>ex: 1 3 -1 -3 5 3 2 1</p>
<p>根基建立 使元素个数达到k</p>
<p>我们上来将1放入到队列中，接着放入3发现前面的元素比3小，那么就需要将前面的元素全部pop出来，然后加入-1，发现后面的元素比3小push进来</p>
<p>3 -1 &#x3D;&gt; 3</p>
<p>第二次循环：放入-3，发现前面元素都比他大所以直接放入</p>
<p>3 -1 -3 &#x3D;&gt; 3</p>
<p>第三次循环：将3pop出来，放入5，发现前面元素都比5小，将前面的元素全部pop出来</p>
<p>5 &#x3D;&gt; 5</p>
<p>第四次循环：将-1pop出去，由于之前5进来的时候-1已经pop出去了所以不用pop了，将3 放入</p>
<p>5 3 &#x3D;&gt; 5</p>
<p>第五次循环：将-3pop，之前pop过，不用pop，将2放入</p>
<p>5 3 2 &#x3D;&gt; 5</p>
<p>第六次循环：经5pop，将1放入</p>
<p>3 2 1 &#x3D;&gt; 3</p>
<p>result: [3,3,5,5,5,3]</p>
<p>单调队列就好比，一群人加入到一个队伍，每一个加入进来的人能力不一，后进来的人发现自己能力比前面的人高，就想方设法将他从队伍中赶出去，自己作为队长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeque</span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      	<span class="comment">//移除队列的首元</span></span><br><span class="line">        <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; val == que.peek())&#123;</span><br><span class="line">            que.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="comment">//添加元素并且将前面小于该元素的元素一处</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty() &amp;&amp; val &gt; que.getLast())&#123;</span><br><span class="line">            que.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        que.add(val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//获取到每一次的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">MyDeque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDeque</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[num++] = deque.getMax();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将最前面的元素进行移除</span></span><br><span class="line">            deque.poll(nums[i - k]);</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">            res[num++] = deque.getMax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">题目入口</a></p>
<p>思路</p>
<p>本题分为三个步骤</p>
<ul>
<li>统计元素出现的频率</li>
<li>对出现的频率进行排序</li>
<li>找出前K个高频元素</li>
</ul>
<p>在这里面，统计元素出现的频率通过map就可以进行统计</p>
<p>排序出现的频率可以通过优先队列</p>
<p>什么是优先级队列呢？</p>
<p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>这道题是用大顶堆呢还是小顶堆呢，其实两种方式都可以实现</p>
<ul>
<li><p>大顶堆思路</p>
<blockquote>
<p>由于你是大顶堆上面的是最大的那么你最后poll出来的前k个就是出现频率最高的元素</p>
</blockquote>
</li>
<li><p>小顶堆思路</p>
<blockquote>
<p>将最小的在遍历map的时候poll出去，队列中余下的就都是出现频率最高的元素</p>
</blockquote>
</li>
</ul>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<p>通过大顶堆进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  			<span class="comment">//通过map来获取每一个元素出现的次数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//定义优先级队列，定义小顶堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm2[<span class="number">1</span>] - parm1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">          	<span class="comment">//遍历map通过数组出现的频率进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//最后poll出来的k个元素都是出现频率最高的元素</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>小顶堆来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm1[<span class="number">1</span>] - parm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">          </span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Stack</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.isEmpty(); <span class="comment">//true</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.pop(); <span class="comment">//4</span></span><br><span class="line">stack.peek(); <span class="comment">//3</span></span><br><span class="line">stack.isEmpty(); <span class="comment">// false</span></span><br><span class="line">stack.search(<span class="number">4</span>); <span class="comment">// -1 没有返回-1</span></span><br><span class="line">stack.search(<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">stack.search(<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line">stack.search(<span class="number">1</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push</td>
<td></td>
<td>将元素压入栈中</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>从栈顶移除元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>查看栈顶元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>search</td>
<td></td>
<td>查找元素在栈中的位置</td>
</tr>
</tbody></table>
<p><strong>Queue</strong></p>
<p>单项队列，只能够操作入队列的那一边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">que.offer(<span class="number">1</span>);</span><br><span class="line">que.offer(<span class="number">2</span>);</span><br><span class="line">que.offer(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> que.poll();</span><br><span class="line">System.out.println(a); <span class="comment">//1</span></span><br><span class="line">System.out.println(que.peek()); <span class="comment">//2</span></span><br><span class="line">System.out.println(que.pollLast()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td></td>
<td>向队列尾部添加元素</td>
</tr>
<tr>
<td>offer</td>
<td></td>
<td>向队尾添加元素，方法优于add</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>poll</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>获取队列头部元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>size</td>
<td></td>
<td>获得队列的长度</td>
</tr>
</tbody></table>
<p><strong>Deque</strong></p>
<p>简介：又名双向队列，可以从两边操作元素</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>offerFirst</td>
<td></td>
<td>从前面插入元素</td>
</tr>
<tr>
<td>offerLast</td>
<td></td>
<td>从后面插入元素</td>
</tr>
<tr>
<td>pollFirst</td>
<td></td>
<td>从前面获取并移除元素</td>
</tr>
<tr>
<td>pollLast</td>
<td></td>
<td>从后面获取并移除元素</td>
</tr>
<tr>
<td>peekFirst</td>
<td></td>
<td>获取头部元素</td>
</tr>
<tr>
<td>getLast</td>
<td></td>
<td>获取尾部元素</td>
</tr>
<tr>
<td>remove(Object o)</td>
<td></td>
<td>移除指定元素，如果队列中有重复的，移除最先入队列的</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>Size</td>
<td></td>
<td>获取队列长度</td>
</tr>
</tbody></table>
<p><strong>PriorityQueue</strong></p>
<p>优先级队列</p>
<p>默认情况下是升序排序，并不是所有元素都按升序进行排序，只有队列头部是最小的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq); <span class="comment">//[-3, 6, 0, 9]</span></span><br></pre></td></tr></table></figure>

<p>如果想要所有元素都按照升序排序，将每一次排好序的首元素进行poll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> pq.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>); <span class="comment">//-3 0 6 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要降序排序的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>优先队列 大顶堆</p>
<blockquote>
<p>首元素是最大的，其余的都比他小，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<p>小顶堆</p>
<blockquote>
<p>首元素是最小的，其余的都比他大，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><p>二叉树主要以两种形式出现</p>
<ul>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
<p><strong>满二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/满二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>满二叉树每一层每一个节点的位置都占据满了，深度为k，有2^k-1个节点的二叉树。</p>
</blockquote>
<p><strong>完全二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/完全二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>除了最后一层其余每一层的节点都占满了</p>
</blockquote>
<p><strong>二叉搜索树</strong></p>
<ul>
<li>左子树不为空，其左子树上的节点都小于左子树根结点的值</li>
<li>右子树不为空，其右子树上的节点都小于右子树根结点的值</li>
<li>左子树和右子树都会二叉排序树</li>
</ul>
<p><strong>平衡二叉搜索树</strong></p>
<p>又被称为AVL树，他可以是空树或者是左子树和右子树的绝对值不大于1的树</p>
<p>我们平时使用的map和set都是机遇平衡二叉搜索树来实现的</p>
<p><font size = "6">二叉树的存储方式</font></p>
<hr>
<p>存储方式主要分为两种链式存储和顺序存储</p>
<p><strong>链式存储主要用的就是指针，顺序存储主要用的就是数组</strong></p>
<p>链式存储用的左右指针来遍历子元素</p>
<p>那么顺序存储是如何拿到子元素的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<p><font size = "6">二叉树的遍历方式</font></p>
<hr>
<p>二叉树主要有两种遍历方式</p>
<ol>
<li><p>深度优先遍历</p>
<blockquote>
<p>先往深走，遇到叶子节点再往回走</p>
</blockquote>
</li>
<li><p>广度优先遍历</p>
<blockquote>
<p>一层一层的去遍历</p>
</blockquote>
</li>
</ol>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先搜索<ul>
<li>层次遍历</li>
</ul>
</li>
</ul>
<p>如何快速分清前序遍历，中序遍历，后续遍历</p>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong></p>
<p>前序遍历：中左右</p>
<p>中序遍历：左中右</p>
<p>后序遍历：左右中</p>
<p>图解分析</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.png"></p>
<p>在后面的习题中深度优先搜索都会接住递归来完成，广度优先搜索大部分都是借助队列来完成的，这个在后面慢慢说</p>
<p><font size = "6">如何定义二叉树</font></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		TreeNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val&#125;;</span><br><span class="line">		TreeNode(TreeNode left,TreeNode right,<span class="type">int</span> val)&#123;</span><br><span class="line">				<span class="built_in">this</span>.left = left;</span><br><span class="line">				<span class="built_in">this</span>.right = right;</span><br><span class="line">				<span class="built_in">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>递归遍历主要分为三种遍历方式：前序遍历，中序遍历，后续遍历</p>
<p>书写递归要考虑一下三步</p>
<ul>
<li><p>确定递归函数的参数和返回值</p>
</li>
<li><p>确定终止条件</p>
</li>
<li><p>确定单层递归的逻辑</p>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">题目入口</a></p>
<p>思路</p>
<ul>
<li>我们什么是否进行返回(当遍历到的值为空的时候进行返回)</li>
<li>遍历的顺序是什么</li>
</ul>
<p>递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        preOrder(node.left,result);</span><br><span class="line">        preOrder(node.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>思路</p>
<p>我们可以通过栈来实现迭代，首先把根结点放入栈中然后通过stack pop出的根结点来将左右节点放入到栈中，但是一定要先放右后放左，这样pop出来的才是正序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midOrdered(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        midOrdered(root.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将左边的元素全部放入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//接着判断右边是否为空</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LastOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LastOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        LastOrdered(root.left,result);</span><br><span class="line">        LastOrdered(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序迭代</p>
<p>思路</p>
<p>将前序遍历左右进行反转最后将整体进行一个反转效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><hr>
<h4 id="二叉树的层序遍历-1"><a href="#二叉树的层序遍历-1" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">题目入口</a></p>
<p>所谓层序遍历就是图论中的广度优先搜索</p>
<p>思路</p>
<p>我们可以用队列来解决这道题，为什么选择了队列而不是栈呢？</p>
<p>因为结果是从左到右的，队列正好也是先入先出，刚好满足题意</p>
<p><code>我们可以通过size来记录每一层中的元素的个数，记录好后遍历将所有本层中的元素pop出来，在这个过程中我们需要将他的子节点放入到队列中，从而保证下一次队列中的元素都是下一层的</code></p>
<p>广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的层次遍历-II"><a href="#二叉树的层次遍历-II" class="headerlink" title="二叉树的层次遍历 II"></a>二叉树的层次遍历 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">题目入口</a></p>
<p>思路</p>
<p>反转第一道题的二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">题目入口</a></p>
<p>思路分析</p>
<p>使用层序遍历，在遍历到每一层的最后一个元素的时候将他放入到集合当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历将求每一层的和最后求平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>,average = <span class="number">0</span>;;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                sum += temp.val;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            average = sum / size;</span><br><span class="line">            result.add(average);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">题目入口</a></p>
<p>思路</p>
<p>思路和二叉树的层序遍历一样</p>
<p><code>Node里面定义的List&lt;Node&gt; children不是方法，是一个属性</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                List&lt;Node&gt; children = temp.children;</span><br><span class="line">                <span class="keyword">if</span>(children == <span class="literal">null</span> || children.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(Node each : children)&#123;</span><br><span class="line">                        que.offer(each);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">题目入口</a></p>
<p>思路</p>
<p>层序遍历找每一层的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                max = Math.max(max,temp.val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">题目入口</a></p>
<p>思路</p>
<p>由于需要将同层的两个相邻的元素通过next建立联系，所以我们先获取首元素，然后通过size来遍历剩余的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="comment">//获取首元素方便首元素调用next</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="comment">//i初始为不算首元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                <span class="comment">//首元素后移，并不断指向后面的元素</span></span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/submissions/">题目入口</a></p>
<p>一样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历，每遍历一层deep++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>当某一个节点的左右两边都是空的话就可以将高度进行返回了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            deep++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> deep;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑采用哪种遍历方式？</p>
<p>这道题前序遍历和后序遍历都行，中序遍历不行</p>
<p>中序遍历不行一会说</p>
<p>假如我们采取的遍历方式是前序遍历</p>
<p>中 左 右</p>
<p>相当于我们上来交换左子树和右子树，遍历左子树并交换，每一个节点交换左右节点，然后遍历右子树，同样的操作</p>
<p>为什么中序比哪里不行？</p>
<blockquote>
<p>因为如果你采用中序遍历，上来你确实是吧左子树的每一个节点的左右元素进行交换了，但是来到中这一步，我们将左右子树进行了一个交换，现在右子树是交换好的，左子树是没有交换过的，然后接着我们又去交换右子树，又把上来的右子树交换回去了，结果就是整个流程就把左右子树进行了交换其余什么都没有干</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root);</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>广度优先搜索</p>
<p>思路</p>
<p>每poll出一个节点将他的左右子节点进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                swap(temp);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑应该使用哪种遍历方式？</p>
<p>你可以把这道题形象的表达为处理左右两个二叉树的题，将最终的结果返回给中间</p>
<p>所以我们使用的肯定是后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">      	<span class="comment">//四种考虑情况只要有一个不满足结果就是false</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断两边是否相等</span></span><br><span class="line">      	<span class="comment">//判断中间是否相等</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c1</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c2</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> c1 &amp;&amp; c2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>在开始之前简单回顾一下高度和深度的概念</p>
<p><strong>深度</strong></p>
<blockquote>
<p>深度是到根结点的距离叫做深度，根结点的深度为1，依次递增</p>
</blockquote>
<p><strong>高度</strong></p>
<blockquote>
<p>高度是到达叶子节点的距离，和深度恰恰相反</p>
</blockquote>
<p><u>求高度用后续遍历，求深度用前序遍历</u></p>
<p>这道题为什么我们采用后续遍历呢？</p>
<p>因为根结点的高度就是二叉树的最大深度</p>
<p>解题思路</p>
<p>递归：我们可以通过后续遍历统计左孩子和右孩子的最大高度最后再加上根结点即为最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>最小深度的概念是必须对应的那个结点的左右子树都是空，才是最小深度</p>
<p>本题要找的是根结点到最近<code>叶子节点</code>的深度</p>
<p>思路</p>
<p>这道题和最大深度相似，但是其中有坑</p>
<p>我们也采用后续遍历，但是返回的时候，需要考虑有一边为空的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">题目入口</a></p>
<p>普通二叉树处理</p>
<p>思路</p>
<p>使用后序遍历对二叉树左边和右边进行遍历最后加上根结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getNodeNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLenght</span> <span class="operator">=</span> getNodeNum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftLength + rightLenght + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要求满二叉树的数量的话，通过2 ^ n - 1就可以轻松解决</p>
<p>完全二叉树处理</p>
<p>思路</p>
<ul>
<li><p>二叉树是否为空</p>
</li>
<li><p>完全二叉树是否为满二叉树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//考虑完全二叉树为满二叉树的情况</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>,rightLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftLength++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            rightLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftLength == rightLength)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftLength) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getLength(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getLength(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于上述直接处理的情况明显处理的情况变少了，时间复杂度也低了</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">题目入口</a></p>
<p>什么是平衡二叉树？</p>
<p>任何一个节点的左右子树的高度差绝对值小于等于1</p>
<p>思路</p>
<p>递归：我们应该使用哪种遍历方式？</p>
<p>这道题我们可以可以通过遍历二叉树的左子树和右子树，如果不是平衡二叉树返回结果是-1，否则返回结果就是高度的差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getLength(root);</span><br><span class="line">        <span class="keyword">return</span> res != -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//后续遍历</span></span><br><span class="line">        <span class="comment">//递归左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightLength == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">题目入口</a></p>
<p>思路</p>
<p>确定参数： 由于要收集路径，还有每一个节点的值，所以我们要定义三个参数(root,String[] str,int[] arr) ，返回值类型为空</p>
<p>判断终止条件：当遍历到当前节点为叶子节点</p>
<p>确定遍历方式：前序遍历，因为要逐层深入，而不是最终将孩子的数据返回给父亲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getPath(root,res,path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node,List&lt;Integer&gt; res,List&lt;String&gt; path)</span>&#123;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                sb.append(res.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(node.val);</span><br><span class="line">            path.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(node.left,res,path);</span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(node.right,res,path);</span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">题目入口</a></p>
<p>什么是左叶子节点？</p>
<p>必须是叶子节点并且有父级位于父级的右子节点</p>
<p>思路</p>
<p>终止条件：当前节点为叶子节点</p>
<p>遍历方式：后续遍历，因为我们需要获取左子树左叶子节点的个数 + 右子树左叶子节点的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//减少递归的层数，不去进行无用的递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            leftLength = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftLength + rightLength;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">题目入口</a></p>
<p>误区</p>
<p>这里面深度最深左下角的值并不一定是左节点，如果没有左节点的话，可以是最后一层位于右边的节点</p>
<p><strong>所以我们在这里面优先遍历左侧的元素</strong></p>
<p>思路</p>
<p>这道题任何遍历方式都是可以的，为什么呢？</p>
<blockquote>
<p>因为我们只需要处理左右的逻辑，和中间无关</p>
</blockquote>
<p>截止条件：当遍历到的是叶子节点,并且在此刻判断深度是否为最大，将值进行存储</p>
<p>接着进行左递归,右递归，别忘了回溯</p>
<blockquote>
<p>回溯的过程相当于除根结点外，将其余的值全部pop出去</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        getValue(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">(TreeNode node,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//叶子节点为截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deep &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = deep;</span><br><span class="line">                result = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            deep++;</span><br><span class="line">            getValue(node.left,deep);</span><br><span class="line">            deep--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            deep++;</span><br><span class="line">            getValue(node.right,deep);</span><br><span class="line">            deep--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">题目入口</a></p>
<p>目标：求二叉树中的某一条路径上的值相加起来和为target目标值</p>
<p>思路</p>
<p>我们可以递归左子树和右子树，对每一个节点上的数值进行减法操作</p>
<p>截止条件：当当前节点是叶子节点，并且count - 节点的值为0的话返回结果为true</p>
<p>遍历方式：这道题也没有中的处理逻辑，所以哪种遍历方式都是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> JudgePathSum(root,targetSum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">JudgePathSum</span><span class="params">(TreeNode root,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            count -= root.left.val;</span><br><span class="line">          	<span class="comment">//遇到符合条件的返回true</span></span><br><span class="line">            <span class="keyword">if</span>(JudgePathSum(root.left,count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">//回溯</span></span><br><span class="line">            count += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            count -= root.right.val;</span><br><span class="line">            <span class="keyword">if</span>(JudgePathSum(root.right,count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += root.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">题目入口</a></p>
<p>思路分析</p>
<ul>
<li><p>如果后序数组为空说明没有根结点</p>
</li>
<li><p>通过后序数组来确定根结点</p>
</li>
<li><p>借助根结点和中序数组进行切割</p>
</li>
<li><p>然后切割后序数组</p>
</li>
<li><p>递归处理左右区间</p>
</li>
</ul>
<p>易错点</p>
<ul>
<li><p>切割数组：注意是左闭右闭还是左闭右开</p>
</li>
<li><p>如何递归</p>
<blockquote>
<p>将每一次切割出来的左数组和右数组接着通过同样的方法去构建子树</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index &lt; inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割中序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftInOrder = Arrays.copyOfRange(inorder,<span class="number">0</span>,index);</span><br><span class="line">        <span class="type">int</span>[] rightInOrder = Arrays.copyOfRange(inorder,index + <span class="number">1</span>,inorder.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切割后序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftPostOrder = Arrays.copyOfRange(postorder,<span class="number">0</span>,leftInOrder.length);</span><br><span class="line">        <span class="type">int</span>[] rightPostOrder = Arrays.copyOfRange(postorder,leftInOrder.length,leftInOrder.length + rightInOrder.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root.left = buildTree(leftInOrder,leftPostOrder);</span><br><span class="line">        root.right = buildTree(rightInOrder,rightPostOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>我们应该使用哪种遍历方式？</p>
<p>这道题我们优先选择前序遍历，因为构建二叉树需要的前提是先要有根结点然后构建左右子树</p>
<p>这道题还是让我们去找最大值以及对应的下标，通过这个下标来分割数组(需要考虑左右是否有元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//确定根结点的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">				<span class="comment">//判断左子树至少包含一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[] leftArr = Arrays.copyOfRange(nums,<span class="number">0</span>,index);</span><br><span class="line">            root.left = constructMaximumBinaryTree(leftArr);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//判断右子树至少包含一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[] rightArr = Arrays.copyOfRange(nums,index + <span class="number">1</span>,nums.length);</span><br><span class="line">            root.right = constructMaximumBinaryTree(rightArr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">题目入口</a></p>
<p>思路</p>
<p>考虑遍历的顺序？</p>
<p>优先选择前序遍历,从根结点进行构建</p>
<p>确定终止条件</p>
<ul>
<li>如果root2发现是空，返回结果是有值的root1</li>
<li>如果root1是空，返回结果是有值的root2</li>
<li>如果都是空的话返回的结果就是空</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            root1.val += root2.val;</span><br><span class="line">            root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">            root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h3><p>二叉搜索树的概念</p>
<p><code>左子树中的所有元素都小于根结点，右子树中的所有元素都大于根结点，左子树满足该条件，右子树也满足该条件</code></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">题目入口</a></p>
<p>迭代法</p>
<p>通过val值从根结点出发去寻找该值所在的位置，最后进行返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; root.val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root.val) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归法</p>
<ul>
<li><p>确定截止条件</p>
<blockquote>
<p>如果二叉树没有元素，返回null，或者是root的val就是需要查找的值，返回root</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            result = searchBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            result = searchBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">题目入口</a></p>
<p>比较直白的写法</p>
<p><strong>通过中序遍历，将每一个元素放入到数组当中，判断这个数组是否是升序的</strong></p>
<p>这种方式十分的耗时，不太推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        isValidBST(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get(i) &lt;= result.get(i - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归法</p>
<p>遍历方式：由于我们需要从小到大的顺序去进行判断，所以我们采用中序遍历</p>
<p>注意点</p>
<ul>
<li><p>由于数据类型比较大我们需要使用long数据类型来记录数据</p>
</li>
<li><p>为什么我们需要通过maxValue来更新数据？</p>
<p>  <code>如果不通过这种方式来判断很可能写成root.left.val &gt; root.val &amp;&amp; root.right.val &gt; root.val，这样的话只能保证根结点的左右数值满足二叉搜索</code></p>
<p>  图解</p>
  <img src="/Users/satrol_/Desktop/NotepadImg/二叉搜索树.jpg" style="zoom:33%;" /></li>
</ul>
<p>定义maxValue完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxValue</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftBool</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; maxValue)&#123;</span><br><span class="line">            maxValue = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightBool</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftBool &amp;&amp; rightBool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如上方式是不严谨的，因为如果测试数据中有long最小值的话，那么就不好使了</strong></p>
<p>借助pre完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftBool</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightBool</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftBool &amp;&amp; rightBool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">题目入口</a></p>
<p>比较直白的想法，中序遍历将每一个值放入到集合中，进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        filledList(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(result.get(i) - result.get(i - <span class="number">1</span>)) &lt; min)&#123;</span><br><span class="line">                min = Math.abs(result.get(i) - result.get(i - <span class="number">1</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filledList</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        filledList(root.left);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        filledList(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针</p>
<p>实现思路</p>
<p>通过pre记录当前节点的上一个节点，通过比较相邻节点来获取最小绝对值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMinVal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinVal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        getMinVal(root.left);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &gt; pre.val) &#123;</span><br><span class="line">            result = Math.min(result,root.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        getMinVal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>思考这道题选择哪种遍历方式？</p>
<p>因为是二叉搜索树，所以这道题优先选择中序遍历，大小从小到大的顺序</p>
<p>比较直接的思路</p>
<p><code>遍历二叉树结合哈希表统计最大的元素，由于Map不易操作转化比较困难，所以不推荐使用</code></p>
<p>第二种思路</p>
<blockquote>
<p>遍历一边二叉树用来统计出现最高频率的次数，再去遍历一遍二叉树，判断那一个的出现频率等于最大频率</p>
</blockquote>
<p>这种思路其实是可以进行优化的，通过双指针只用一次遍历来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>,maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        FillWithResult(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            res[i] = result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FillWithResult</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        FillWithResult(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">      	<span class="comment">//用来记录出现频率最大的次数</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || node.val != pre.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;	</span><br><span class="line">				<span class="comment">//寻找等于出现次数最大的节点值</span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount) result.add(node.val);</span><br><span class="line">      	<span class="comment">//更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            result.clear();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//双指针用来记录node前一个节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        FillWithResult(node.right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>通过两个子代向上遍历二叉树，发现父亲的值相等进行返回</p>
<p>选择哪种遍历方式？</p>
<p>由于是子类向父类返还数据，和回溯很想，所以这道题我们采用后续遍历，将数据交由中来处理</p>
<p>判断终止条件</p>
<p><code>如果发现p或者是q的话就将当前元素的父元素进行返回，最终返回给root进行处理</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p|| root == q)  <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">题目地址</a></p>
<p>思路</p>
<p>从根结点出发，通过判断两个值和根结点的大小来决定走左子树还是右子树，如果发现遍历过程中有一个值在两个值的中间那么他就是公共祖先</p>
<p>为什么这个节点他就是公共祖先呢?</p>
<p>图解</p>
<img src="/Users/satrol_/Desktop/NotepadImg/最近公共祖先.jpg" style="zoom:33%;" />

<p>假如从根结点进行遍历发现某一个值满足条件，如果往左遍历就不属于大于他的那个值的祖先了，往右遍历就不属于小于他的那个值的祖先了，所以当前结点就是最近公共祖先了</p>
<p>递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果发现p和q的值比当前结点小的话，说明分布在当前结点的左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="comment">//记录左值</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="comment">//如果不为空说明存在最近父节点</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发现p和q的值比当前结点大的话，说明分布在当前结点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当当前结点的值位于p和q之间的话返回当前节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">题目入口</a></p>
<p>插入的节点插入到的是叶子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      	<span class="comment">//如果是叶子节点返回给上一级</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//左叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//右叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">题目入口</a></p>
<p>思路</p>
<p>本题包含五种情况</p>
<ul>
<li><p>没有找到要删除的节点</p>
</li>
<li><p>删除的节点是叶子节点</p>
<p>  <code>易删除，因为并没有破坏二叉树的结构</code></p>
</li>
<li><p>删除的节点左不为空，右为空</p>
<p>  <code>删除节点的父节点指向删除节点的左子节点</code></p>
</li>
<li><p>删除的节点左为空，右不为空</p>
<p>  <code>删除节点的父节点指向删除节点的右子节点</code></p>
</li>
<li><p>删除的节点左不为空，右不为空</p>
<p>  <code>将删除节点的左子树放在删除节点的右节点的左下节点上,即取代删除节点的是删除节点的次大节点</code></p>
<p>  图解</p>
  <img src="/Users/satrol_/Desktop/NotepadImg/二叉树删除节点.jpg" style="zoom:33%;" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">          	<span class="comment">//对应上else if(root.val &gt; key)的情况 如发现root.left.left == null root.left.right == null 将root.left == null</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">              	<span class="comment">//如果左为空，右不为空，将root.right = root.right.right</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//如果左不为空，右为空，将root.left = root.left.left;</span></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//判断左不为空，右不为空的情况</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">          	<span class="comment">//向左遍历</span></span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">//向右遍历</span></span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码(以上五种情况都是迎合这串代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">  	<span class="comment">//向左遍历</span></span><br><span class="line">    root.left = deleteNode(root.left,key);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  	<span class="comment">//向右遍历</span></span><br><span class="line">    root.right = deleteNode(root.right,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>判断root的值是否超出了裁剪的范围，如果当前节点比low小的话，那么去遍历右边，接着将low小的修剪掉，如果当前节点比high大的话，那么去遍历左边，将比high大的修剪掉</p>
<p>先看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解(举例说明)</p>
<img src="/Users/satrol_/Desktop/NotepadImg/裁剪二叉树.jpg" style="zoom:40%;" />





<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>因为数组是有序的，我们可以将数组的中间节点作为根结点，将左部分的中间节点作为根结点的左子节点，将右部分的中间节点作为根结点的右子节点，以这样的规律下去，就能保证二叉树的平衡性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BanlanceTree(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">BanlanceTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right]</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = BanlanceTree(nums,left,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = BanlanceTree(nums,mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">题目入口</a></p>
<p>思路</p>
<p>本题要求的累加数是从右到左的顺序进行相加的，我们可以通过双指针来快速解决这道问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traversel(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversel</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        traversel(cur.right);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        cur.val += pre;</span><br><span class="line">        pre = cur.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        traversel(cur.left);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><h3 id="回溯理论基础"><a href="#回溯理论基础" class="headerlink" title="回溯理论基础"></a>回溯理论基础</h3><p>什么是回溯？</p>
<blockquote>
<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
</blockquote>
<p><code>只要有递归，就一定有回溯</code></p>
<p>回溯法的应用场景</p>
<ul>
<li>排列</li>
<li>组合</li>
<li>切割</li>
<li>子集</li>
<li>棋盘问题</li>
</ul>
<p>回溯算法的模版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">题目入口</a></p>
<p>思路</p>
<p>这道题是一道经典的回溯题目</p>
<p>我们可以套用模版，通过树状图的方式来解决</p>
<img src="/Users/satrol_/Desktop/NotepadImg/组合.jpg" style="zoom:33%;" />



<p>确定截止条件：当数组的长度等于组合大小的时候</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        FillWithArr(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FillWithArr</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> firstIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == k)&#123;</span><br><span class="line">          	<span class="comment">//需要new出来一个新的集合存放list</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//这一步的执行顺序是先添加1 然后不断递归加回溯，12 13 14 循环到头，递归结束将1 remove，将2加入，重复前面的过程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt;= n;i++)&#123;</span><br><span class="line">    </span><br><span class="line">            list.add(i);</span><br><span class="line">            FillWithArr(n,k,i + <span class="number">1</span>);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了深入了解，我将调试后的每一步都书写一遍</p>
<ul>
<li>向list中添加1，然后进入递归，别忘了最终会执行递归下面的remove语句，将1进行remove</li>
<li>第一次递归，将i + 1   —&gt; 2传入，发现长度够了，return，接着执行remove语句将2移除</li>
<li>第二次递归将3传入，添加到二维数组，return，remove</li>
<li>第三次递归将4传入，最终将4移除，此时i ++ 变成了5不满足条件，退出循环，第一次递归结束执行我刚开始说的remove语句，将1移除，放入2同样的流程</li>
</ul>
<p><strong>剪枝操作优化</strong></p>
<p>为什么可以进行剪枝操作？</p>
<p>刚刚的代码是对整个树进行了一个搜索的操作，但是假如n &#x3D; 4，k &#x3D; 4，那么刚开始取1，剩余元素为2，3，4是可以凑成四个数的，但是后面取2，3和4的时候剩余元素的个数都不到3是不可能凑成组合大小为4的，所以这时候剪枝操作就派上用场了</p>
<p>如果要减少搜索的次数那么一定是在for循环内做修改</p>
<p>如何做修改呢？</p>
<ul>
<li>已知list里面存放选取的元素个数list.size()</li>
<li>还剩下k - list.size()的元素等待被选取</li>
<li>列表中剩余元素的个数为n - i</li>
<li>n - i &gt;&#x3D; k - list.size()   —–&gt;   i &lt;&#x3D; n - (k - list.size())</li>
<li>不过需要包含起始位置所以i &lt;&#x3D; n - (k - list.size()) + 1;</li>
</ul>
<blockquote>
<p>为什么要做加1操作可以通过举例子解决，就比如n &#x3D; 4, k &#x3D; 4 此时list中没有存放元素最终i &lt;&#x3D; 1,i起始也是1，只进行一次操作，4 4 本来不也只能执行一次嘛，因为当起始取2的时候 234不够4个组合元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        FillWithArr(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FillWithArr</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> firstIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt;= n - (k - list.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            FillWithArr(n,k,i + <span class="number">1</span>);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">题目入口</a></p>
<p>为什么我们会想到回溯算法？</p>
<p>因为这道题给出的两个参数是总和<code>m</code>和个数<code>n</code>，如果用暴力的话需要嵌套<code>n</code>层循环，无法进行处理，这个时候就可以通过递归内套for循环结合回溯实现目的</p>
<p>思路</p>
<p>本题代码和组合的代码差不多</p>
<p>关键在于sum操作这里我们需要在添加二维数组的时候进行判断，还有回溯的记得将sum减回去，其余的代码都一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTracking(k,n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - list.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            list.add(i);</span><br><span class="line"></span><br><span class="line">            backTracking(k,n,sum,i + <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">题目入口</a></p>
<p>为什么会想到使用回溯来解决本道题目？</p>
<p>因为这道题目是根据数字来确定字母的组合，如果n个数字就需要嵌套n层for循环，比较麻烦，所以才想到了回溯</p>
<p>思路</p>
<p>确定截止条件</p>
<p>当组合的长度大小到达了digits的长度的时候截止</p>
<p>套用模版，递归加上回溯来解决本道题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">    String[] map = &#123;</span><br><span class="line">        <span class="string">&quot; &quot;</span>,</span><br><span class="line">        <span class="string">&quot; &quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span> || digits == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapRef</span> <span class="operator">=</span> map[digit];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; mapRef.length();i++)&#123;</span><br><span class="line">            sb.append(mapRef.charAt(i));</span><br><span class="line">            backTracking(digits,index + <span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>这道题和之前<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">组合求和III</a>差不多，唯一不同点在于本身的元素是可以重复的，假如canadiate &#x3D; [2,3,4] target &#x3D; 4,result &#x3D; [[2,2],[4]]</p>
<p>思路</p>
<p>确定截止条件，如果发现求和后大于目标值的话说明不是，直接返回</p>
<p>如果求和后等于的话，那么将该一维数组放入到二维数组中</p>
<p>其余的代码套用模版即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        backTracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backTracking(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/submissions/">题目入口</a></p>
<p>思路</p>
<p>这道题相比于前面的两道题需要考虑的是去重操作</p>
<p>比如candidates: [1,1,7] ，target &#x3D; 8 </p>
<p>有两个1 7需要进行去重操作，如何进行去重操作呢？</p>
<p>我们需要对数组进行排序，是重复元素相邻，</p>
<p>定义一个boolean类型的数组，用来记录sum内部是否加过，拿刚才的例子来举例的话</p>
<p>1 1 7  –&gt; 1 0 1 \ 0 1 1这两种情况如果我们想要排除第二种情况的话，可以通过出现过的第一位元素是否为0来判断 ，再加上i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]来去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] isUsed;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[candidates.length];</span><br><span class="line">        backTracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backTracking(candidates,target,i + <span class="number">1</span>);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/submissions/">题目入口</a></p>
<p>思路</p>
<p>这道题为什么会想到回溯？</p>
<p>根据题意这道题其实还是一道组合题目，只不过需要将每一个组合可能判断是否是回文字母</p>
<p>回溯三部曲</p>
<ul>
<li><p>确定终止条件</p>
<p>  <code>我们可以设置一个firstIndex用于切割字符串，不断的向后推移，因为有判断回文数的条件，如果满足条件才进行切割操作，如果能够在最后进行了切割的话说明这一次是满足条件的，放入到二维数组中，</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s,<span class="type">int</span> firstIndex)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件:当字符串可以切割到最后说明存在满足条件的可能</span></span><br><span class="line">        <span class="keyword">if</span>(firstIndex &gt;= s.length()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindromes(s,firstIndex,i))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(firstIndex,i + <span class="number">1</span>);</span><br><span class="line">                list.add(str);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            backTracking(s,i + <span class="number">1</span>);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindromes</span><span class="params">(String s,<span class="type">int</span> first,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(first) != s.charAt(end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            first++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">题目入口</a></p>
<p>思路</p>
<p>本题和分割字符串差不多，需要书写一个方法用来判断截取的字符串是否满足ip地址的条件</p>
<p>回溯函数代码</p>
<p>参数</p>
<p>原字符串，截取的位置，打点数</p>
<p>主要代码</p>
<p>截止条件：当点数到达3点时候需要对剩余的字符串进行判断</p>
<p>在截取的终止的位置上添加点，同时添加点数，由于添加了点，所以需要后移两位，同时点数++</p>
<p>回溯，将点删除掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      	<span class="comment">//剪枝操作</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        backTracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s,<span class="type">int</span> firstIndex,<span class="type">int</span> pointNum)</span>&#123;</span><br><span class="line">      	<span class="comment">//当打点到达3，判断最后一段是否满足条件</span></span><br><span class="line">        <span class="keyword">if</span>(pointNum == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judgeCritertion(s,firstIndex,s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                result.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judgeCritertion(s,firstIndex,i))&#123;</span><br><span class="line">              	</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                backTracking(s,i + <span class="number">2</span>,pointNum);</span><br><span class="line">                pointNum--;</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeCritertion</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; end + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">题目入口</a></p>
<p>思路</p>
<p>本题和之前的题不太一样，这道题不是在叶子节点中收获结果，而是每一次添加到list中，就可以作为一次结果</p>
<p>终止条件：当startIndex(用于定位初始位置)到达nums.length的时候结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;    </span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">				<span class="comment">//这个判断条件可写可不写，因为当startIndex == nums.length 循环结sf束 执行下面添加的return</span></span><br><span class="line">      	<span class="keyword">if</span>(startIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">题目入口</a></p>
<p>思路</p>
<p>这道题和子集1一样可以不用书写判断条件，但是需要在for循环外面书写return</p>
<p>本题需要考虑重复子集的可能，我们需要对数层进行去重操作，我们可以定义一个isUsed数组用来记录是否被使用了 </p>
<blockquote>
<p>ex: 1 2 2 当数层已经到达第二个2的时候isUsed记录的结果是0 0 1 但是2这种情况之前在第一个2的时候已经收集到了，所以我们可以判前第一个元素如果没有被使用过，那就说明本次重复的元素已经被记录过了，continue</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] isUsed;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">题目入口</a></p>
<p>思路分析</p>
<p>根据题意，nums[i]的取值在-100 到 100 之间，所以我们只需要定义一个空间大小为201到数组，为什么要定义这个数组呢？</p>
<p><code>因为这个数组是用来记录本树层上已经取过的值，在下一次取到时候会出现重复的结果</code></p>
<p>那么这道题的截止条件是什么呢？</p>
<p>这道题因为是递增子集，想要凸显出递增那么数组的长度一定至少是2，所以我们判断当长度&gt;&#x3D;2的时候收集list</p>
<p>判断是否是升序子集</p>
<p>在list不为空的情况下进行判断，如果当前选取的数比list末尾的元素小的话说明不是升序的不满足条件，continue，为什么要continue？</p>
<p><strong>因为你当前这个子集不满足条件不代表后面的元素不满足条件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> firstIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.isEmpty() &amp;&amp; nums[i] &lt; list.get(list.size() - <span class="number">1</span>) || arr[<span class="number">100</span> + nums[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//每一树层记录的值，不需要进行回溯</span></span><br><span class="line">            arr[<span class="number">100</span> + nums[i]] = <span class="number">1</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>如果这里不想用数组用set集合收集已经取出的元素也可以</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.isEmpty() &amp;&amp; nums[i] &lt; list.get(list.size() - <span class="number">1</span>) || set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//每一树层记录的值，不需要进行回溯</span></span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">题目入口</a></p>
<p>排列和组合的区别是什么？</p>
<p>简单举一个例子</p>
<p>[1,2] [2,1] 属于一个组合，但是是两个排列</p>
<p>思路</p>
<p>由于本题是排列问题，我们并不是在取一个元素后前面的元素无法进行选取，所以我们for循环应该是从0开始进行的</p>
<p>如何收获结果</p>
<p>当发现排列元素的长度等于nums的长度的时候进行返回</p>
<p>used数组用来记录某些元素是否已经被取，如果取过了，那么就跳过这个元素，接着向下取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used,<span class="literal">false</span>);</span><br><span class="line">        backTracking(nums,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] used)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTracking(nums,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">题目入口</a></p>
<p>思路</p>
<p>这道题相比于全排列需要考虑去重问题</p>
<p>如何进行去重操作呢？</p>
<p>去重操作我们需要考虑，两个相邻的数大小如果相等，并且前面一个数的isUsed对应的值为false的话说明出现重复结果，这里说了一个大概因为前面有好几道题都进行了说明</p>
<p>收获结果</p>
<p>当发现list的长度等于nums的长度的时候进行收集</p>
<p>本题没有什么要求去重<code>需要进行排序</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(isUsed,<span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums,isUsed);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>] || isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            backTracking(nums,isUsed);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">题目入口</a></p>
<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">题目入口</a></p>
<p>思路</p>
<p>步骤主要分为三步</p>
<ul>
<li>定义N皇后的规则</li>
<li>定义棋盘，对棋盘进行一次填充</li>
<li>深搜的过程</li>
</ul>
<p><strong>定义N皇后规则</strong></p>
<p>由于我们深搜是对每一行里面的每一个数据进行遍历，判断那一个符合条件，即每一行我们只选择一个符合规则的解，所以我们不需要考虑每一列重复的可能</p>
<ul>
<li>每一行重复</li>
<li>45度角重复</li>
<li>135度角重复</li>
</ul>
<p>这里考虑的范围是包括传入进来的这个点的，并且方向都是向上一层去做考虑的</p>
<p>那45度来举例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//45度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们想要看的之前的每一行中是否有和这个元素不满足规则的，45度方向是向左上角的，chessboard【row - 1】【col - 1】 判断左45的是否满足条件</p>
<p><strong>定义棋盘</strong></p>
<p>棋盘是由字符来构成的，并且是一个二维数组所以我们需要定义一个char类型的二维数组，需要对char数组每一个值进行填充操作，根据题目要求需要填充为点</p>
<p><strong>深搜 + 回溯</strong></p>
<p>判断终止条件：当row到达最后一层的时候说明，每一层都找到符合条件的情况进行返回</p>
<p>for循环遍历每一行中每一列的元素，如果发现满足条件就将其设置为皇后</p>
<p>递归加回溯考虑所有情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : chessboard)&#123;</span><br><span class="line">            Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(chessboard,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] chessboard,<span class="type">int</span> n,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            result.add(TwoArrConvertToString(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(row,i,n,chessboard))&#123;</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backTracking(chessboard,n,row + <span class="number">1</span>);</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">TwoArrConvertToString</span><span class="params">(<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : chessboard)&#123;</span><br><span class="line">            list.add(String.copyValueOf(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> n,<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">        <span class="comment">//只判断行的原因是进行递归操作的时候每一行只放入一个元素，不需要考虑每一列出现重复的现象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; row;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//45度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//145度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">题目入口</a></p>
<p>思路</p>
<p>本题回溯算法返回的结果是布尔类型，为什么呢？</p>
<p><code>因为我们只需要返回一个结果，而不是获取到散落在树形结构中的每一个结果</code></p>
<p>这道题相比于N皇后有一些不同点</p>
<p>这道题需要先嵌套两层for循环用来遍历棋盘上的每一个元素，查找是空的位置，向空位上添加合适的元素，在里面进行递归和回溯操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backTracking(board);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;k &lt;= <span class="string">&#x27;9&#x27;</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVaild(board,i,j,k))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(backTracking(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有找到合适的元素</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时数独已经填满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == v)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == v)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//由于棋盘的每一块都是3 3，所以我们可以使用这种方法来获取每一块棋盘左上角的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startRow</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startCol</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startRow;i &lt; startRow + <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startCol;j &lt; startCol + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == v)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="贪心算法理论基础"><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h3><p><code>目的：通过局部最优推出全局最优</code></p>
<h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">题目入口</a></p>
<p>思路</p>
<p><code>如果是从后面进行比较的，拿着最大饼干和最大胃进行比较，如果如果发现胃较大，那么不用移动饼干的指针</code></p>
<p><code>如果是从前进行比较的，拿着最小饼干和最小胃进行比较，如果发现胃比较大，那么需要后移饼干的指针来找到最小适配当前胃的饼干的值</code></p>
<p>最大饼干适配最大孩子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 优先考虑孩子胃口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> g.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(start &gt;= <span class="number">0</span> &amp;&amp; g[index] &lt;= s[start]) &#123;</span><br><span class="line">                start--;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最小饼干适配最小孩子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">//优先考虑饼干</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length &amp;&amp; start &lt; g.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[start]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">题目入口</a></p>
<p>思路</p>
<p>我们可以将序列中递增超过1的情况删除掉，剩下的就是摆动序列了</p>
<p>我们先考虑没有平坡的情况</p>
<p>假如三个数分别是2 3 4，我们如何判断他是一个摆动的数列？</p>
<p><code>通过判断prediff = nums[i] - nums[i - 1] 和curdiff = nums[i + 1] - nums[i]如果是相反数的话那说明这就是一个摆动序列</code></p>
<p>考虑平坡</p>
<p>如果这组数是2 3 3 3 4 那么返回的结果是3，所以我嗯需要在最后一个3那里进行计数，即prediff &#x3D;&#x3D; curdiff &amp;&amp; curdiff &lt; 0和prediff &#x3D;&#x3D; curdiff &amp;&amp; curdiff &gt; 0这两种情况</p>
<p>如果数组的长度是1的话，说明这个摆动序列只有头部，计数为1</p>
<p>考虑数组长度不够3，如果数组长度为2的话，我们可以初始化prediff &#x3D; 0，方便后面比对prediff 和curdiff</p>
<p>结果默认情况下为1，因为所有的序列都是建立在长度为1的基础上的</p>
<p>考虑单调平坡</p>
<p>当出现 1 2 2 2 3 3这一组数的时候，如果按我们直接prediff &#x3D; curdiff这么更新的话，那么在后面两个3的时候都会进行加1操作，这是不正确的，只有我们的坡度发生了变化的时候我们再去更新prediff，就能避免这种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prediff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curdiff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            curdiff = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(prediff &gt;= <span class="number">0</span> &amp;&amp; curdiff &lt; <span class="number">0</span> || prediff &lt;= <span class="number">0</span> &amp;&amp; curdiff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="comment">//当坡度发生了变化的时候才去更新prediff</span></span><br><span class="line">                prediff = curdiff;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">题目入口</a></p>
<p>这道题有两种求解的思路</p>
<p>暴力法</p>
<p>两个for循环一个用来遍历数组中的每一个元素，另一个从当前元素的后面作为起始位置，接着去遍历剩余的元素，统计连续值的最大值</p>
<p>很明显Java中暴力法超时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ;j &lt; nums.length;j++)&#123;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">                result = Math.max(temp,result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>贪心算法</p>
<p>思路</p>
<p>我们从头到位遍历，遍历以为加到temp中，如果发现temp小于0的话我们需要将temp清空，然后下一次循环上来就加上了下一位的值，为什么要清空，因为如果保留这个temp负数那么加上下一位只会拖累下一位的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(count &gt; result) result = count;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; <span class="number">0</span>) count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">题目入口</a></p>
<p>思路</p>
<p>我们需要计算出所有正利润差值的可能，很简单，遍历每一天，如果当前减去前一天的差值 &gt; 0 的话那么我们相当于是在前一天买，当天去卖，收获这比利润</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">             count += diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">题目入口</a></p>
<p>思路</p>
<p>这道题我们不应该考虑每一次该去跳几步</p>
<p>我们应该考虑的是跳跃的范围，如果最大范围大于等于nums长度话返回true</p>
<p>每一次跳跃都是在更新覆盖范围<code>i + nums[i]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= cover;i++)&#123;</span><br><span class="line">            cover = Math.max(cover,i + nums[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">题目地址</a></p>
<p>思路</p>
<p>本题要求我们统计最少的跳跃次数</p>
<p>我们可以根据统计每一次可跳跃元素中最大的值，每一次跳最大值，统计个数</p>
<p>maxCover用来统计跳跃的最大区域</p>
<p>如果最大区域大于已经超过了数组的长度说明已经到达了末尾了，result++结束循环</p>
<p>如果发现走到了当前所在的最大区域，更新当前区域为最大区域，result++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义当前最大区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMaxCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义最大区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            maxCover = Math.max(maxCover,i + nums[i]);</span><br><span class="line">            <span class="comment">//如果最大区域已经超过了数组的范围，</span></span><br><span class="line">            <span class="keyword">if</span>(maxCover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当你走到了最大区域的时候更新你当前所在的最大区域</span></span><br><span class="line">            <span class="keyword">if</span>(i == curMaxCover)&#123;</span><br><span class="line">                curMaxCover = maxCover;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">题目入口</a></p>
<p>贪心思路</p>
<p>第一次贪心，我们可以优先对绝对值最大的负数进行取反，接着对其余的负数进行取反，使数组中的元素尽可能都是正数</p>
<p>第二次贪心，当全是正数了，但是k没有用完我们优先对正数中最小的数进行取反操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        nums = IntStream.of(nums)</span><br><span class="line">                .boxed()</span><br><span class="line">                .sorted((o1, o2) -&gt; Math.abs(o1) - Math.abs(o2))</span><br><span class="line">                .mapToInt(Integer::intValue).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">题目入口</a></p>
<p>题意</p>
<blockquote>
<p>题目给出了两个数组让我们求从哪个索引出发，在保证油量充足的情况下，最终能够到达原点</p>
</blockquote>
<p>贪心思路</p>
<p>我们生成一个新的数组用来存放每一次补充的油量和消耗的油量差值，遍历数组如果发现当前油量为负的话，那么就从他的下一位开始,同时将临时统计的油量和进行清空操作</p>
<p>为什么发现curSum小于0要从下一位开始？</p>
<p>curSum统计的是从起始位置开始到达i这个位置的和，如果发现curSum 小于零，说明[0,i]这个区间内都不能作为起始点，因为无论你选择这段区间内的哪，到i这个位置的时候都会使curSum&lt;0，所以起始位置从i + 1开始</p>
<p>当curSum为负数的时候，如果后面还有更大的负数呢？</p>
<p>如果这个负数比较大的话，那么加到这个更大负数的时候curSum会小于零start的起始位置也会更新</p>
<p>如果数组够长那么前面数组和 + 当前消耗的油量大于0，那么起始位置不是从前面开始吗？</p>
<img src="/Users/satrol_/Desktop/NotepadImg/加油站.jpg" style="zoom:33%;" />



<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; gas.length;i++)&#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                result = i + <span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">题目入口</a></p>
<p>题意</p>
<p>每一个孩子至少一个糖果，相邻两个孩子，得分高的比得分低的多分配糖果，糖果的数量你随意，但是要求最终分配的糖果数量是最少的</p>
<p>思路</p>
<p>我们不应该同时考虑某个孩子两边的情况</p>
<p>首先将每一个孩子手中的糖果默认为-1</p>
<p>我们首先从左向右进行比较，如果发现右边的人分数高于左边，那么就在左边糖果的基础上加1操作</p>
<p>然后我们从右向左遍历，如果发现左边糖果数量高于右边的话，在右边糖果的基础上加1操作</p>
<p><code>由于要同时满足两种情况所以需要在两者中进行一次取值，即取两数组的最大值</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] Candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(Candy,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                Candy[i] = Candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                Candy[i] = Math.max(Candy[i + <span class="number">1</span>] + <span class="number">1</span>,Candy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(Candy).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">题目入口</a></p>
<p>题意</p>
<p>开始你是没有钱的，通过客户来获取钱，如果你能给客户找零，那么返回true否则返回false，只有5 15 20三张面额的钞票</p>
<p>如果客户给你5元，那么正好</p>
<p>如果客户给你10元，你需要返还给他5元</p>
<p>如果客户给你20元，你需要返还10 + 5 或者是5 + 5 + 5元</p>
<p>思路</p>
<p>我们定义三个变量用来统计我手中每一张钞票的数量</p>
<p>如果是5元，那么5的钞票数量 + 1</p>
<p>如果是10元，判断是否有5元，5的数量- 1，10的数量 + 1</p>
<p>如果是20元，先判断10有没有，如果没有再去考虑全是5的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>,ten = <span class="number">0</span>,twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/submissions/">题目入口</a></p>
<p>思路</p>
<p>这道题和分发糖果那道题很像，本题可以按照k从小到大的顺序，或者是h从大到小的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]] </span><br></pre></td></tr></table></figure>



<p>按照k从小到大的顺序进行排列，身高按照从低到高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>



<p>身高按照从低到高，k按照从低到高的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>

<p>正确的排序顺序是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>



<p>可以发现和第二种有联系，将每一次的值移动到k下标到位置，结果刚好贴合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">				</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//LinkedList集合可以将值添加到指定下标下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i : people)&#123;</span><br><span class="line">            que.add(i[<span class="number">1</span>],i);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//集合转化成数组</span></span><br><span class="line">        <span class="keyword">return</span> que.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">题目入口</a></p>
<p>思路</p>
<p>当一个气球的左边界大于上一个气球的右边界的时候，说明两个气球的范围并没有重合，我们需要添加一个弓箭</p>
<p>如果发现重合的可能如何接着判断下一个是否也重合了呢？</p>
<p>我们需要更新我们的右端点，如果下一次的左端点没有上两次的右端点的最小值小的话说明并没有和上两次重合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        Arrays.sort(points, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/submissions/">题目入口</a></p>
<p>本题和上面哪道题基本一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">题目入口</a></p>
<p>思路</p>
<p>我们可以统计字符串中所有元素的最远出现的位置，遍历字符串，不断更新最大值，如果i到达了最大值的话，将其放入到集合当中，以同样的方式接着进行统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] hashArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计每个元素出现的最远位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hashArr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            right = Math.max(hashArr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>],right);</span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                result.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">题目入口</a></p>
<p>思路</p>
<p>这道题还是一道重叠的题</p>
<p>但是这道题需要在重叠的同时进行数组合并操作</p>
<p>比较当前数组的第一位和上一个数组的第二位</p>
<ol>
<li><p>如果当前数组的第一位比上一个数组的第二位小的话，需要进行合并</p>
</li>
<li><p>否则的话，直接将数组传入结果集当中</p>
</li>
</ol>
<p>两个区域进行合并左右边界都是在不断发生变化的，我们可以分别定义左右区域</p>
<p>因为我们需要比较前一个区域，所以我们从1开始，leftArea，rightArea定义为刚开始的</p>
<p>无论是否合并，rightArea都会发生动态变化，leftArea只有在不进行合并的时候才会进行合并</p>
<p>因为我们先将数据添加到result中，然后再去更新左右区域，所以我们需要将最后的区域进行加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightArea</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftArea</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; rightArea)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftArea,rightArea&#125;);</span><br><span class="line">                leftArea = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightArea = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rightArea = Math.max(rightArea,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftArea, rightArea&#125;);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">题目入口</a></p>
<p>题意分析</p>
<p>本题要求获取一个小于等于输入值的最大元素，并且保证这个元素每一位都是单调递增的</p>
<p>思路</p>
<p>由于本题需要获取一个小于等于输入值的元素，例如300 —-&gt; 299 ，如果使用暴力的话，我们从输入的元素开始到0，接着对单调递增进行处理，时间复杂度是O(n * m)，很容易超时</p>
<p>如果要实现单调递增需要判断字符串当前位和前一位的大小</p>
<p>如果要获取小于等于输入元素的话，我们需要在i - 1位做减1操作，同时让第i位保证是最大数9</p>
<p>Coding time</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = (n + <span class="string">&quot;&quot;</span>).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; s[i - <span class="number">1</span>])&#123;</span><br><span class="line">                s[i - <span class="number">1</span>] = (<span class="type">char</span>)(s[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag;i &lt; s.length;i++)&#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">题目入口</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划理论"><a href="#动态规划理论" class="headerlink" title="动态规划理论"></a>动态规划理论</h3><p>动态规划常见题型</p>
<ul>
<li>背包问题</li>
<li>打家劫舍</li>
<li>股票问题</li>
<li>子序列问题</li>
</ul>
<p>动态规划五部曲</p>
<ul>
<li><p>理解dp数组的含义</p>
</li>
<li><p>递推公式</p>
</li>
<li><p>dp数组如何初始化</p>
</li>
<li><p>遍历顺序</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>动态规划代码书写顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line"></span><br><span class="line">确定遍历顺序</span><br><span class="line"></span><br><span class="line">递推公式</span><br><span class="line"></span><br><span class="line">打印dp数组</span><br></pre></td></tr></table></figure>



<p><strong>顺序是这样的，但是我们还是按照五部曲进行分析，更加的直观</strong></p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">题目入口</a></p>
<p>特点：每一个数等于前两个数的和</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="comment">//递推公式</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">题目入口</a></p>
<p>本题按照递归五部曲来推导</p>
<p>dp数组代表了什么？</p>
<p><code>dp[i]代表每一阶需要走的步数</code></p>
<p>递推公式</p>
<blockquote>
<p>dp[1] &#x3D; 1，dp[2] &#x3D; 2，dp[3] &#x3D; 3，dp[4] &#x3D; 5</p>
<p>可以得到递推公式为dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p>
</blockquote>
<p>初始化</p>
<p><code>dp[1] = 1, dp[2] = 2</code></p>
<p>遍历顺序：从前至后进行遍历</p>
<p>最终输出结果</p>
<p>dp法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量替换数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">题目入口</a></p>
<p>题目分析</p>
<p>本题需要求的是到达顶部所需要消耗的最少体力值，并且初始位置下标可以是0或者是1，每一次只能跳1或者是2层台阶</p>
<p>思路</p>
<p>dp数组每一个元素代表的含义</p>
<p><code>dp[i]代表在从初始位置调到i消耗的体力</code></p>
<p>递推公式</p>
<blockquote>
<p>我们已知台阶一次只能跳一个或者是两个，所以我们不得不从当前台阶的前两个台阶计算，从i - 2计算dp[i - 2] + cost[i - 2]，从i - 1计算dp[i - 1] + cost[i - 1]，由于我们最终需要的是消耗的最少体力，所以我们需要在这两个中取得最小值Math.min()</p>
</blockquote>
<p>初始化</p>
<p>题目给出描述，初始位置下标可以是0或者是1，即初始化如下</p>
<p><code>dp[0] = 0,dp[1] = 1</code></p>
<p>遍历顺序，从前向后遍历</p>
<p>最后输出dp数组验证结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">题目入口</a></p>
<p>题意</p>
<p>从左上角做到右下角有多少条路径,每次移动只能向左或者是向下</p>
<p>思路</p>
<p><code>dp[i][j]的含义?</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j]代表了走到这个点共有多少条路径</span><br></pre></td></tr></table></figure>

<p>递推公式</p>
<blockquote>
<p>我们如果想要从左上角的某点走到右下角点某点，最后一步无疑不是走到目标点的左边或者是走到目标点的上面，分别统计走到这两点的路径，加起来就是最终结果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>我们可以对第一行和第一列进行初始化，因为二维数组上的所有点都是基于这两行进行推导的</p>
<p>初始化的值为1，因为移动只能向右或者是向下，所以到达这些点的路径只能为1</p>
<p>如何进行遍历？</p>
<p>从左往右遍历，从上往下遍历</p>
<p>打印数组验证结果</p>
<p>深搜写法(时间复杂度是2 ^ (m + n - 1) - 1，明显会发现超时了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dfs(<span class="number">1</span>,<span class="number">1</span>,m,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; m || j &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == m || j == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i + <span class="number">1</span>,j,m,n) + dfs(i,j + <span class="number">1</span>,m,n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>dp写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">题目入口</a></p>
<p>题意</p>
<p>相比于不同路径I 多了一个障碍物，求有多少种路径</p>
<p>思路</p>
<p>dp数组的含义</p>
<p><code>dp数组代表了到达二维数组中某一个点的路径</code></p>
<p>递推公式</p>
<p><code>还是一样的，不过需要考虑遍历过程中是否出现过障碍物的情况</code></p>
<p>初始化</p>
<blockquote>
<p>可能在第一行或者是第一列中出现过障碍物的情况，障碍物后面的情况都无法遍历到，所以只需要我们对障碍物前面的每一个位置进行赋1操作</p>
</blockquote>
<p>遍历从左到右，从上到下</p>
<p>打印数组验证结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">题目入口</a></p>
<p>题意</p>
<p>本题要求拆分一个整数，使得最终的乘积是最大的</p>
<p>思路</p>
<p>dp[i]数组含义</p>
<p>dp数组记录着最大乘积</p>
<p>递推公式</p>
<p>我们需要考虑两个数乘积，和多个数乘积在其中取最大值</p>
<p>我们需要固定一个值，接着拆分另一个值</p>
<p>这里面不拆分前面的值是因为后面的值拆分后已经包含了前面的值拆分的情况</p>
<p>两个值的乘积：j * (i - j)</p>
<p>多个值的乘积：j * dp[i - j]</p>
<p>获取乘积的最大值，这里也需要比较dp[i]的值，因为dp[i]的值也是在不断变大的</p>
<p>初始化</p>
<p>初始化0 1 都是没有意义的，因为0 1最大的乘积是0，所以我们应该从2开始进行初始化</p>
<p>遍历顺序</p>
<p>固然是从前向后进行遍历，j是依赖于i的值，需要现有i，再有j，正常来说，j是固定值，不能超过i，j从1开始遍历到达i - 1，但是这其中会出现很多重复的情况，所以我们只需要将j的上限设置为i - j即可</p>
<p>打印dp数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i - j;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(Math.max(j * (i - j),j * dp[i - j]),dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">题目入口</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io">Satrol_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/">https://sloplerol.github.io/2023/05/07/LeetCode_Note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sloplerol.github.io" target="_blank">Freedom Coding</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/10/Nodejs/" title="Exploit node flexible"><img class="cover" src="https://w.wallhaven.cc/full/rr/wallhaven-rrodj7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Exploit node flexible</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/CalculateForJava/" title="CalculateForJava"><img class="cover" src="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CalculateForJava</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E5%89%8D%E9%A1%BB%E7%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">看前须知</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">数组理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number"></span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number"></span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-number"></span> <span class="toc-text">螺旋矩阵II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">总结篇</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">链表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">如何定义链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number"></span> <span class="toc-text">链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">环形链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.</span> <span class="toc-text">有效的字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">快乐数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">赎金信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="toc-number">8.</span> <span class="toc-text">四数之和</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="toc-number"></span> <span class="toc-text">反转字符串II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number"></span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number"></span> <span class="toc-text">翻转字符串里的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">KMP算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-strStr"><span class="toc-number"></span> <span class="toc-text">实现 strStr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">重复的子字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">栈和队列理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">用栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number"></span> <span class="toc-text">用队列实现栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number"></span> <span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number"></span> <span class="toc-text">删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">逆波兰表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">前 K 个高频元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">二叉树理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II"><span class="toc-number">2.</span> <span class="toc-text">二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">二叉树的层平均值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">N叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">在每个树行中找最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II"><span class="toc-number">8.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">二叉树的最小深度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最小深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">左叶子之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number"></span> <span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number"></span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number"></span> <span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">修剪二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">把二叉搜索树转换为累加树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">回溯理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number"></span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII"><span class="toc-number"></span> <span class="toc-text">组合总和III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number"></span> <span class="toc-text">电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII"><span class="toc-number"></span> <span class="toc-text">组合总和II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number"></span> <span class="toc-text">复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number"></span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86II"><span class="toc-number"></span> <span class="toc-text">子集II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number"></span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number"></span> <span class="toc-text">全排列 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">重新安排行程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number"></span> <span class="toc-text">N皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number"></span> <span class="toc-text">解数独</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">贪心算法理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number"></span> <span class="toc-text">分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">摆动序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number"></span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII"><span class="toc-number"></span> <span class="toc-text">跳跃游戏II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">K次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number"></span> <span class="toc-text">加油站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number"></span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number"></span> <span class="toc-text">柠檬水找零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">根据身高重建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number"></span> <span class="toc-text">用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">划分字母区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number"></span> <span class="toc-text">单调递增的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">监控二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number"></span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA"><span class="toc-number"></span> <span class="toc-text">动态规划理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number"></span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number"></span> <span class="toc-text">使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number"></span> <span class="toc-text">不同路径 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number"></span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">不同的二叉搜索树</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Satrol_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my site !!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://sloplerol.github.io/2023/05/07/LeetCode_Note/'
    this.page.identifier = '/2023/05/07/LeetCode_Note/'
    this.page.title = 'Leecode Brush Questions Journey'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>