<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leecode Brush Questions Journey | Freedom Coding</title><meta name="author" content="Satrol_"><meta name="copyright" content="Satrol_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode刷题历程">
<meta property="og:type" content="article">
<meta property="og:title" content="Leecode Brush Questions Journey">
<meta property="og:url" content="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html">
<meta property="og:site_name" content="Freedom Coding">
<meta property="og:description" content="LeetCode刷题历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg">
<meta property="article:published_time" content="2023-05-07T13:06:30.000Z">
<meta property="article:modified_time" content="2023-06-09T15:34:29.990Z">
<meta property="article:author" content="Satrol_">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leecode Brush Questions Journey',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-06-09 23:34:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109008086?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Freedom Coding"><span class="site-name">Freedom Coding</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leecode Brush Questions Journey</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-07T13:06:30.000Z" title="发表于 2023-05-07 21:06:30">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T15:34:29.990Z" title="更新于 2023-06-09 23:34:29">2023-06-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leecode Brush Questions Journey"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h4><blockquote>
<p>目前学习进度：动态规划，本篇文章通过分析思路，让你更加快速的理解代码</p>
</blockquote>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><blockquote>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
</blockquote>
<p>注意点</p>
<ul>
<li>数组的下标是从0开始的</li>
<li>数组中每一个元素的内存地址是连续的</li>
</ul>
<p>数组对于查找元素很方便，但是增删元素会导致后面元素的内存地址发生后移的效果，所以效率比较低</p>
<p><code>数组中的元素只能被覆盖，不能删除</code></p>
<p>在C++中内存地址是连续的，而在Java中内存地址是交给虚拟机进行寻址操作进行分配的</p>
<p>数组的理论基础介绍到这里，或多或少你也掌握了一些数组的基本知识点了</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>二分查找是对升序的数组进行查找操作，如果在数组中查找到元素，返回下标否则返回-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">2</span>;</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">10</span>;</span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>思路分析</p>
<p>二分查找的难点主要集中在考虑临界点情况 到底是while(left &lt; right) 还是while(left &lt;&#x3D; right)呢</p>
<p>在二分法中区间主要分为两种[left,right] 或者是 [left,right)</p>
<p>第一种写法: [left,right] </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right] 决定left 是否等于 right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">                right = midVal - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法[left,right)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right) 这是后while循环left &lt; right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">              <span class="comment">//因为右边取不到所以直接直接将right赋值为midVal</span></span><br><span class="line">                right = midVal;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">LeetCode链接</a></p>
<p>这道题给我们一个数组，并且给我们target，要求我们返回移除所有该元素后返回的新数组，和长度</p>
<p>暴力算法</p>
<p>思路分析</p>
<blockquote>
<p>对数组进行遍历，如果发现了有一个值和target相等在来一个for循环将数组后的所有元素进行前移操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">             		<span class="comment">//目标元素后面的元素进行操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//将下标前移 接着进行移位后的数组从i开始重复</span></span><br><span class="line">                i--;</span><br><span class="line">              	<span class="comment">//将数组总长度进行减1操作</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针法</p>
<p>思路分析</p>
<blockquote>
<p>定义一个快指针，定义一个慢指针，快指针用来遍历数组中的元素，如果不等于target的值的话才将值赋值给慢指针对应的下标，慢指针再做后移操作</p>
</blockquote>
<img src="/Users/satrol_/Desktop/NotepadImg/删除数组中元素.jpg" style="zoom:25%;" />

<p>如果是在不理解这里有一张我画的图解，fast向后查找如果查找到的目标值为1的话slow不需要进行后移操作，否则需要，最后将slow的大小进行返回即新数组的长度</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//返回慢指针的大小也就是新数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">链接地址</a></p>
<p>题意：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会想到双指针？</p>
<p><code>因为数组是有序的的那么最大值只能出现在两边，于是我们可以通过比较两边值的平方的方法，将大的值放入到新的数组中</code></p>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] newResult = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//一定是&lt;=否则会丢掉中间值的可能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = size;left &lt;= size;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] * nums[right] &gt; nums[left] * nums[left])&#123;</span><br><span class="line">                newResult[size--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//相等的情况放在哪种情况中都可以，就是不能丢掉</span></span><br><span class="line">                newResult[size--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">链接地址</a></p>
<p>题意：给出一个数组和一个target求出数组中长度最小的的连续子数组的和大于等于target的值的元素个数</p>
<p>暴力解法</p>
<blockquote>
<p>双层for循环，第一层for循环设置起始位置第二层for循环从起始位置开始到达终止位置判断是否满足条件，进行返回结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    min = Math.min(min,j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>滑动窗口</p>
<blockquote>
<p>其实还是双指针的想法，只不过左指针是在动态移动的，一层for循环用来移动右指针，发现一个满足条件的，移动左指针，看是否可以缩小范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,sum = <span class="number">0</span>,subLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLen = j - i + <span class="number">1</span>;</span><br><span class="line">                result = Math.min(subLen,result);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">链接地址</a></p>
<p>思路</p>
<blockquote>
<p>每一次循环考虑的只包含单个对角，然后再考虑转了几圈，如果是偶数的话转的圈数必然是n &#x2F; 2但是如果是奇数的话圈数也是n &#x2F; 2中间的那一个点需要单独处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++ &lt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = start;j &lt; n - loop;j++)&#123;</span><br><span class="line">                arr[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = start;i &lt; n - loop;i++)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时i，j已经到arr[n][n]处了</span></span><br><span class="line">            <span class="comment">//这部一定要 &gt;= loop </span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= loop;j--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= loop;i--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转完一圈起始位置会发生变化</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            arr[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><blockquote>
<p>数组往期的做法，很多人都可能采用两个for循环求解题目，上述这些题目带你初步了解如何通过双指针的想法仅仅用一个for循环来求解题目，希望写完题目后的你能自我反思自己是否要改变往常的双for循环的低效方法</p>
</blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是什么？</p>
<blockquote>
<p>每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
</blockquote>
<p>众所周知，链表分为好几大类</p>
<p><strong>单链表</strong>(每一个节点只有一个指向next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>双链表</strong>(每一个节点包含两个指向pre,next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>循环链表</strong>(主要用于解决约瑟夫问题)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png"></p>
<p>链表在内存中存储可不是连续的，所以主要用来进行增删操作</p>
<h4 id="如何定义链表"><a href="#如何定义链表" class="headerlink" title="如何定义链表"></a>如何定义链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">  	ListNode next;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(ListNode next,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8.png"></p>
<p>这里面暗藏了垃圾回收机制，那么什么是垃圾回收呢</p>
<p>见图解当删除D即没有东西指向D的时候D没有了任何作用就会触发垃圾回收机制</p>
<p>C++中需要手动释放，而Java Python中可以自动垃圾回收</p>
<p>添加链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png"></p>
<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/submissions/">链接地址</a></p>
<p>这道题需要考虑两种情况</p>
<ul>
<li>移除头节点 让头节点设置为head.next</li>
<li>移除非头节点 找到上一个节点让他的下一个节点指向当前节点的下一个节点</li>
</ul>
<p>如果想要以统一的方式删除节点就可以引入<code>虚拟头节点的概念</code></p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9.jpg"></p>
<p>先使用传统的方式去移除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果删除的是头节点的话 假如链表中元素都是1的话需要进行全部移除</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果删除的节点不是头节点的话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里面让当前节点指向head的目的是为了获取到删除节点的上一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//避免操作空指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      	<span class="comment">//定义虚拟头节点下一位指向head val设置为什么都可以 因为最后返回值是从head开始的</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">链接地址</a></p>
<p>这道题可以让你熟练的掌握链表的所有基本基本操作</p>
<p>为了迎合增删是否为头节点的问题本题使用虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目入口</a></p>
<p>这道题有两种做法双指针和递归</p>
<p>双指针</p>
<p>思路</p>
<p>我们可以定义一个pre初始化为空，在head的前面，通过双指针的思想不断移动pre和cur</p>
<p>临界条件：当pre为为节点cur为原来的尾节点后的null的时候截止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//临界条件是cur刚好为尾节点后的空节点，此时pre指向的就是为尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//保存cur的下一个值因为现在cur要指向他的前一个值了</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归写法：实际上还是双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre,cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre,ListNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目入口</a></p>
<p>思路</p>
<p>这道题需要使用虚拟头节点，可能有人问为什么使用虚拟头节点，这是因为你要操作head这个元素所以肯定要用到它的前一个节点</p>
<p>图解</p>
<img src="/Users/satrol_/Desktop/NotepadImg/交换节点.jpg" style="zoom:35%;" />

<p><strong>如上图所见dummyhead使用来操作两个节点的每一次都是作为前一个节点的前面的节点</strong></p>
<p>接下来需要考虑临界条件</p>
<p>这里包含两种情况</p>
<ul>
<li><p>偶数的时候 dummyhead.next &#x3D;&#x3D; null</p>
</li>
<li><p>奇数的时候 dummyhead.next.next &#x3D;&#x3D; null </p>
</li>
<li><p>以上两种情况必须同时满足</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//temp 和 temp1需要保存下来因为下面在进行修改</span></span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">           cur.next = cur.next.next;</span><br><span class="line">           cur.next.next = temp;</span><br><span class="line">           temp.next = temp1;</span><br><span class="line">           cur = cur.next.next;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//正如上图所见，head发生了变化所以需要将dummyhead.next作为头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/">题目入口</a></p>
<p>这道题还是一个双指针问题</p>
<p>思路</p>
<blockquote>
<p>定义快慢指针，先让快指针移动n步，再让慢指针跟着慢指针同时进行移动操作，但是这时候你发现了另一个问题，虽让慢指针定位到了要删除的元素身上，当时无法对他进行操作，所以要让快指针移动n + 1步，此时慢指针才会定位到要删除元素的前一个节点的身上</p>
</blockquote>
<p>临界条件判断：当快指针为空的时候结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">题目入口</a></p>
<p>思路</p>
<p>当两条长度不一的情况下求出差值让长链表移动差值次，接着比较每一次的值是否相等，决定返回值是什么</p>
<img src="/Users/satrol_/Desktop/NotepadImg/双链表相交点.jpg" style="zoom:40%;" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>,lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">//获取两条链表的长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//因为curA此时已经为空需要重置</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">				<span class="comment">//让长的链表为curA</span></span><br><span class="line">        <span class="keyword">if</span>(lenB &gt; lenA)&#123;	</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempVal</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = tempVal;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curA;</span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//求差值</span></span><br><span class="line">        cha = lenA - lenB;</span><br><span class="line">     		<span class="comment">//长链表后移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; cha;i++)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">				<span class="comment">//判断是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span> &amp;&amp; curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目入口</a></p>
<p>这道题让我们判断是否能成环，尾部连接到那一个节点</p>
<p>这道题可以使用快慢指针的思路来解决，为什么想到用这种方式来解决呢？</p>
<p><strong>判断是否成环</strong></p>
<blockquote>
<p>因为链表如果成环的话，那么快慢指针能够相遇</p>
<p>那为什么快指针可以和慢指针相遇呢？</p>
<p>比如快指针的速度为2，慢指针的速度为1，那么差值为1，快指针一直以1的速度无限接近于慢指针，肯定是能碰到的</p>
</blockquote>
<p><strong>判断在哪相遇</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/环形链表.jpg" style="zoom:40%;" />



<p>这个图是有很多注意点的</p>
<ul>
<li>由于快指针比慢指针快所以相遇的圈数一定大于等于1</li>
<li>慢指针走过的圈数一定没有1圈，假如快指针速度为2，慢指针速度为1，那么最坏的情况也是在圈中间相遇</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">      	<span class="comment">//fast来判断为null的情况</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">              	<span class="comment">//参考上面图解x = z</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//返回相遇的节点index1和2都行</span></span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到相遇的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>什么是哈希表呢？</p>
<p>哈希表又称散列表，根据关键码的值而直接进行访问的数据结构，数组就是通过下标来进行访问的也就是一张哈希表</p>
<p>哈希表主要使用来干什么的？</p>
<p><strong>用来判断集合中是否出现了某一个元素</strong></p>
<p>将时间复杂度大大的降低了</p>
<p>哈希函数是什么？</p>
<p>比如将每一个人的信息映射到下标索引身上，通过查询下标来判断是谁</p>
<p>注意这里面将每一条数据信息转化为hashCode数值</p>
<p>那么如果hashCode得到的值大于哈希表的长度的话，该如何解决</p>
<p><strong>我们可以通过取模的方式(hashCode &#x2F; HashTable)进行解决</strong></p>
<p><strong>常见的问题：哈希碰撞</strong></p>
<p>什么是哈希碰撞？</p>
<blockquote>
<p>两条数据同时映射到哈希表的同一个位置上</p>
</blockquote>
<ul>
<li><p>解决方法1:  拉链法</p>
<p>  将两条数据同时存储到该位置上</p>
<hr>
<p>  其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
</li>
<li><p>解决方法2: 线性探测法</p>
<p>  前提：hastable足够大，通过空位的方式来存放碰撞的值</p>
</li>
</ul>
<p>常见实用哈希法来完成的三种数据结构</p>
<ul>
<li>Map</li>
<li>Set</li>
<li>数组</li>
</ul>
<h4 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">题目入口</a></p>
<p>思路分析</p>
<p>这道题我们可以使用哈希表+数组的方式来解决，为什么呢？</p>
<blockquote>
<p>因为统计的是小写字母，ASCII码值是连续的，可以将a代表数组下标为0，z对应数组下标为25</p>
</blockquote>
<p>当然Map来解决也是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      	<span class="comment">//通过字符串的toCharArray方法将字符串中的每一个字符拆分开来</span></span><br><span class="line">        <span class="type">char</span>[] c1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = t.toCharArray();</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            arr[c1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; c2.length;j++)&#123;</span><br><span class="line">            arr[c2[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">题目入口</a></p>
<p>为什么我们想到用哈希表来解决这道题？</p>
<p><strong>因为哈希表往往是用来查找集合中是否包含某个元素</strong></p>
<p>三种数据类型我们应该选择哪种，针对于这道题来说，尽量不要选择数组来解决该问题，因为数据够大，使用数组需要开辟很多的内存空间，所以我们优先选择set来解决</p>
<p><code>Set还有一个优势就是可以帮助我们去重数组，放置结果中出现两个重复的元素</code></p>
<p>解题思路</p>
<p>查找两个数组重复元素，我们可以将一个数组放入到集合当中，然后判断另一个数组中的元素是否在当前集合中出现过，如果出现过的话放入到新数组中，最后将集合转化为数组，解决此问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int index = 0;</span></span><br><span class="line">        <span class="comment">//int[] arr = new int[result.size()];</span></span><br><span class="line">        <span class="comment">//for(int i : result)&#123;</span></span><br><span class="line">            <span class="comment">//arr[index++] = i;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return arr;</span></span><br><span class="line">     		<span class="keyword">return</span> result.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>LeetCode中后来将数据改成了1000所以可以使用数组来解决，不过在Java中不用Set没有直接对数组去重的操作，所以不推荐在Java中使用数组使用该题</strong></p>
<p>数组的大体思路是创建一个1010的数组，将num1的值对应的数组下标设置为1，将num2去重，判断在数组中num2下标对应的值是否是1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            arr[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得不重复的nums2</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[list.get(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                res.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size();i++)&#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">题目入口</a></p>
<p>思路</p>
<p>可以拆分出来一个方法专门用来求每一项的平方，可以借助Set集合来判断之前的集合中是否包含之前计算出来过的元素，如果包含说明肯定不是，那么就让他不停的进行循环操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getSum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> digital;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digital = n % <span class="number">10</span>;</span><br><span class="line">            sum += digital * digital;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">题目入口</a></p>
<p>思路分析</p>
<p>这道题如果使用暴力很简单，这里就直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>显然时间复杂度为O(n * 2)不太好</p>
<p>接下来使用哈希法来解决</p>
<p>在写代码之前讲一下大体思路</p>
<p>我们可以通过map的方式来记录每一个下标和他的对应的值，通过查找target - 当前对应的值，返回下标，从而得到两个下标</p>
<p><strong>注意点：不要先把每一个值上来就都放入到map中，如果这样加入nums是[3,3] 返回到下标就是[0,0]，而我们要的结果是[0,1]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">题目入口</a></p>
<p>解题思路</p>
<p>我们可以将四个数组拆分成两对，第一对遍历前两个数组，通过Map的方式来记录a + b的值作为key 出现的次数记为value，再去遍历另一对两个数组记录key为- (c + d) ,因为要使a + b + c + d &#x3D; 0 , a + b &#x3D; - (c + d)</p>
<p>注意点：如果a + b 出现了 - ( c + d)匹配的值的话就加上a + b对应的value值  </p>
<p>ex : a + b : 3 出现了一个- (c + d)匹配那么次数就应该加3</p>
<p>可能有的人认为为什么不将四个数组分成分成1 和 3 因为3的时间复杂度为O(n * 3) 而分成2 * 2 时间复杂度才O(n * 2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                map.put(nums1[i] + nums2[j],map.getOrDefault(nums1[i] + nums2[j],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span> * (nums3[i] + nums4[j]);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">                    count += map.get(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/submissions/">题目链接</a></p>
<p>思路和有效字母异位词一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = ransomNote.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = magazine.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] ch = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c2.length;i++)&#123;</span><br><span class="line">            ch[c2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            ch[c1[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">题目链接</a></p>
<p>思路分析，因为要获取到的是三个数的值，和统计出现的次数可不太一样，使用哈希表的方法来解决是很麻烦的</p>
<p><strong>所以我们能想到双指针的方法来解决，排序数组之后定义第一个数<code>i</code>用来走遍数组，接着定义的两个指针布局于<code>i + 1</code> , <code>len - 1</code>,通过三数之和判断是否等于0移动指针</strong></p>
<p>注意事项</p>
<ul>
<li>如果第一个数大于0那么就不用判断了</li>
<li>判断i 是否重复</li>
<li>判断left 和right 是否重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果发现i重复利用的情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">题目入口</a></p>
<p>思路</p>
<p>延续了三数之和的方法在三数for循环的外面再套一层循环</p>
<p>注意点</p>
<ul>
<li><p>由于可能出现负数的情况所以剪枝操作是不行的,因为两个负数相加变得会越来越小</p>
<blockquote>
<p>剪枝操作就是三数之和判断首位元素 &gt; target 就直接返回</p>
</blockquote>
<p>  如果要做剪枝的话需要判断首位元素是否大于0</p>
</li>
<li><p>去重操作</p>
</li>
<li><p>外层需要剪枝操作和去重操作，内层只需要去重判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) <span class="keyword">return</span> list;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">题目入口</a></p>
<p>思路：</p>
<p>根据题意，返回的还是原数组，所以我们需要通过双指针的方式来交换首尾元素</p>
<p>双指针方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过for循环每一次走过的路径都是2k反转内部长度为k的字符串</p>
<p>注意事项</p>
<blockquote>
<p>需要判断i + k是否超过了整个字符串的长度，如果超过了反转i到字符串长度的字符即可，否则反转i 到i + k范围内的字符</p>
</blockquote>
<p>最直白的写法(时间有点多)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt; len)&#123;</span><br><span class="line">                s = reverse(s,i,i + k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = reverse(s,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来翻转字符串下标从j到k之间的字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧用StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> i + k &gt; len ? len : i + k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondK</span> <span class="operator">=</span> i + <span class="number">2</span> * k &gt; len ? len : i + <span class="number">2</span> * k;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            temp.append(s.substring(i,firstK));</span><br><span class="line">            result.append(temp.reverse());</span><br><span class="line">						<span class="comment">//如果第一个k和第二个k之间有元素的话，需要截取</span></span><br><span class="line">            <span class="keyword">if</span>(firstK &lt; secondK)&#123;</span><br><span class="line">                result.append(s.substring(firstK,secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">题目入口</a></p>
<p>显然这道题肯定不是让你调用库函数的题</p>
<p>可以通过StringBuffer来判断是否是空格，条件判断执行不同的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针通过扩容机制来解决</p>
<p>思路</p>
<p><em><em>我们可以扩容空格的个数</em> 2倍，通过双指针判断是否为空格来进行填充%20操作</em>*</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//扩容两倍</span></span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始定义双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目入口</a></p>
<p>本题思路</p>
<p>先对字符串的前后进行去除空格的操作，然后对中间进行去除空格的操作，最后对整个字符串进行反转操作，通过split方法分割多个字符串，然后对每一个字符串进行反转操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//用来去除两边的空格</span></span><br><span class="line">        <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(right) == <span class="string">&#x27; &#x27;</span>) right--;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span> &amp;&amp; s.charAt(left + <span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] firstReverse = sb.reverse().toString().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; firstReverse.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != firstReverse.length - <span class="number">1</span>)&#123;</span><br><span class="line">                result += reverse(firstReverse[i]) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += reverse(firstReverse[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            temp = ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目入口</a></p>
<p>思路分析</p>
<p>左旋转2翻译人话就是将最左边的两个元素放入到最右边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> s.substring(n,s.length());</span><br><span class="line">        <span class="keyword">return</span> str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><blockquote>
<p>主要解决字符串匹配的问题</p>
</blockquote>
<p>ex : str1 &#x3D; “aabaabaaf” str2 &#x3D; “aabaaf”</p>
<p>判断是否str1中出现了str2 ？</p>
<p>正常来说我们会通过双层for循环的方法逐一进行匹配，但是时间复杂度是两个字符串长度的乘积，效率很low</p>
<p>KMP算法的实现原理</p>
<p>还是以str1和str2为例,我们首先进行逐一匹配发现在b和f的位置上无法匹配了那么就会回到之前匹配过的b上接着进行匹配</p>
<p>如果不太理解可以看这张图</p>
<img src="/Users/satrol_/Desktop/NotepadImg/KMP.jpg" style="zoom:40%;" />

<ul>
<li><p>前缀</p>
<blockquote>
<p>包含首元但不包含尾元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; a，aa，aab，aaba，aabaa</p>
</li>
<li><p>后缀</p>
<blockquote>
<p>包含尾元但不包含首元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; f，af，aaf，baaf，abaaf</p>
</li>
<li><p>通过匹配的字符串获取到的前缀表</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>前缀</th>
<th>后缀</th>
<th>相等前后缀</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a, aa</td>
<td>b, ab</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a, aa, aab</td>
<td>a, ba, aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a, aa, aab,aaba</td>
<td>a, aa, baa, abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a, aa, aab, aabaa</td>
<td>f, af, aaf, baaf,abaaf</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<p>得到前缀表后我们应该去找不匹配元素的前面的一个元素的值，即2，代表了前缀中有一个和后缀相等的字符串，从这个字符串的后面接着开始匹配，这个元素的下标就是最长相等前后缀的值</p>
<p>next数组的不同实现方式</p>
<ul>
<li>原封不动的将前缀表作为next数组</li>
<li>将前缀表右移，将第一个设置为-1，作为新的next数组</li>
<li>将前缀表整体减1，作为next数组</li>
</ul>
<p>next数组实现包含四步</p>
<ul>
<li><p>初始化操作</p>
<p>  定义两个指针i，j分别代表后缀起始位置和前缀起始位置</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure>

<hr>
<p>  这里设置j为-1是因为我们采用的是统一减1的实现方式</p>
</li>
<li><p>判断前后缀不相等的情况</p>
<p>  j里面记录着包括j之前子串中相等前后缀的数量</p>
<p>  当发现前后缀的值不相等的话就需要回退到j + 1的前一个值对应的索引</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>判断前后缀相等的情况</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i)) j++;</span><br></pre></td></tr></table></figure>

</li>
<li><p>更新next数组</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) == s.charAt(j + <span class="number">1</span>))&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>next数组实现完毕，接下来看我们该如何进行使用</p>
<p>我们要在文本串(s)中查找模式串(t)</p>
<p>定义两个指针i从文本串的起始位置开始，j从模式串的起始位置开始</p>
<p>j的初始值是-1 ，i的初始值为1 ，接着对i 和 j + 1进行比较</p>
<p>因为要对模式串和文本串进行一一比较所以i我们要从0开始</p>
<ul>
<li><p>如果文本串和模式串无法匹配</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//j &gt;= 0 是为了防止j = next[-1]的情况</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="comment">//跳转位置</span></span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何匹配了的话</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i和j同时向后移动 因为i在循环中</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>]) j++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断匹配成功了呢</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j指向了模式串的末尾的话即匹配成功</span></span><br><span class="line"><span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> i - t.length() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">				reutrn i - t.length() + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">题目入口</a></p>
<p>最直白的方法indexOf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j + <span class="number">1</span>)) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j + <span class="number">1</span>)) j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == needle.length() - <span class="number">1</span>) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">题目地址</a></p>
<p>移动匹配</p>
<p>思路</p>
<p>如果一个字符串是由重复子串构成的话，那么这个字符串的前半部分和后半部分是相同的，于是我们可以再添加一个这个字符串，截取掉拼接好的字符串的两边，判断中间是否包含原来的字符串 &#x3D;&gt; 前半部分的尾元 + 后半部分的首元</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> concat.substring(<span class="number">1</span>,concat.length() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.indexOf(s) != -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h3 id="栈和队列理论基础"><a href="#栈和队列理论基础" class="headerlink" title="栈和队列理论基础"></a>栈和队列理论基础</h3><blockquote>
<p>栈是先进后出，队列是先进先出</p>
</blockquote>
<p>栈和队列都是属于STL（C++标准库）里面的数据结构</p>
<p>常见的STL版本</p>
<ul>
<li><p>HP STL</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</span><br></pre></td></tr></table></figure>

</li>
<li><p>P.J.Plauger STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>SGI STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">题目入口</a></p>
<p>思路</p>
<p>通过两个栈来实现队列，一个是in栈，还有一个是out栈，将一组数据放入到in栈中，再将这组数据从in栈中弹出放入到out栈中，此时弹出来的顺序就是正确的了</p>
<img src="/Users/satrol_/Desktop/NotepadImg/栈实现队列.jpg" style="zoom:33%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpInStackOut</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//如果out栈为空说明已经将in栈推送到了out栈中 </span></span><br><span class="line">        <span class="keyword">if</span>(!stackOut.empty()) <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">//如果in栈不为空说明需要将内容push到out栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.empty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以通过一个队列或者是两个队列来实现栈</p>
<p>两个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line">    Deque&lt;Integer&gt; que2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//第二个队列主要用来备份除栈中第一个元素外其余的元素</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que2.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> que1.peekFirst();</span><br><span class="line">        que1.pollFirst();</span><br><span class="line">        que1 = que2;</span><br><span class="line">      	<span class="comment">//这种方式来清空que2中残留的数据更加直观</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;	</span><br><span class="line">      	<span class="comment">//队尾即栈顶</span></span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.addLast(que.peekFirst());</span><br><span class="line">            que.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//这里面的栈顶就是队尾</span></span><br><span class="line">        <span class="keyword">return</span> que.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过栈来解决本题，如果遇到了左括号就将与之对应的右括号入栈，当遇到了右括号就可以和之前的右括号进行消除</p>
<p>本题需要考虑三种情况</p>
<ul>
<li>消除到最后栈中包含某个右括号没有被消除</li>
<li>在遇到右括号的时候发现栈顶元素并不是右括号</li>
<li>字符串在遇到右括号需要消除的时候，栈内没有元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.peek() != s.charAt(i))&#123;</span><br><span class="line">              	<span class="comment">//第二种情况和第三种情况放在一起进行考虑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以用栈来解决这道题目</p>
<blockquote>
<p>定义一个栈，遍历字符串添加条件判断语句将重复连续的元素进行去除后，因为栈pop出来的字符串是反序的所以需要我们去反转一下栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == s.charAt(i))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//反转栈的操作</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将字符串作为栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="comment">//重复的情况</span></span><br><span class="line">            <span class="keyword">if</span>(top &gt;= <span class="number">0</span> &amp;&amp; ch == res.charAt(top))&#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(ch);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span></span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目入口</a></p>
<p>什么是逆波兰表达式</p>
<blockquote>
<p>方便计算机计算的表达式</p>
</blockquote>
<p>平常比较常见的是中缀表达式</p>
<p>ex: (1 + 2) * 3</p>
<p>切换成后缀表达式就是</p>
<p>ex : 1 2 + 3 *</p>
<p>思路分析</p>
<p>正常来说如果没有遇到操作符的话，就将其转化为数字放入到栈中，如果遇到了，我们可以pop出两个元素对这两个元素进行运算，最后栈中只留下了一个值，也就是答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">题目入口</a></p>
<p>这道题如果用暴力的话时间复杂度是O(n * k)，很容易就超时</p>
<p>思路</p>
<p>我们可以使用队列来解决本题，每一次滑动窗口移动的时候，我们可以将首元进行pop将新加入的尾元进行push，最后再去获得这组数据中的最大值</p>
<blockquote>
<p>在C++中有优先级队列的概念，但是如果你使用了优先级队列的话，那么每一次数据都是排序好的，你如果pop的话就会将最大值弹出和预期弹出的值不相符</p>
</blockquote>
<p>单调队列模拟</p>
<p>首先确定k的大小，初始化</p>
<p>ex: 1 3 -1 -3 5 3 2 1</p>
<p>根基建立 使元素个数达到k</p>
<p>我们上来将1放入到队列中，接着放入3发现前面的元素比3小，那么就需要将前面的元素全部pop出来，然后加入-1，发现后面的元素比3小push进来</p>
<p>3 -1 &#x3D;&gt; 3</p>
<p>第二次循环：放入-3，发现前面元素都比他大所以直接放入</p>
<p>3 -1 -3 &#x3D;&gt; 3</p>
<p>第三次循环：将3pop出来，放入5，发现前面元素都比5小，将前面的元素全部pop出来</p>
<p>5 &#x3D;&gt; 5</p>
<p>第四次循环：将-1pop出去，由于之前5进来的时候-1已经pop出去了所以不用pop了，将3 放入</p>
<p>5 3 &#x3D;&gt; 5</p>
<p>第五次循环：将-3pop，之前pop过，不用pop，将2放入</p>
<p>5 3 2 &#x3D;&gt; 5</p>
<p>第六次循环：经5pop，将1放入</p>
<p>3 2 1 &#x3D;&gt; 3</p>
<p>result: [3,3,5,5,5,3]</p>
<p>单调队列就好比，一群人加入到一个队伍，每一个加入进来的人能力不一，后进来的人发现自己能力比前面的人高，就想方设法将他从队伍中赶出去，自己作为队长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeque</span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      	<span class="comment">//移除队列的首元</span></span><br><span class="line">        <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; val == que.peek())&#123;</span><br><span class="line">            que.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="comment">//添加元素并且将前面小于该元素的元素一处</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty() &amp;&amp; val &gt; que.getLast())&#123;</span><br><span class="line">            que.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        que.add(val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//获取到每一次的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">MyDeque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDeque</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[num++] = deque.getMax();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将最前面的元素进行移除</span></span><br><span class="line">            deque.poll(nums[i - k]);</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">            res[num++] = deque.getMax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">题目入口</a></p>
<p>思路</p>
<p>本题分为三个步骤</p>
<ul>
<li>统计元素出现的频率</li>
<li>对出现的频率进行排序</li>
<li>找出前K个高频元素</li>
</ul>
<p>在这里面，统计元素出现的频率通过map就可以进行统计</p>
<p>排序出现的频率可以通过优先队列</p>
<p>什么是优先级队列呢？</p>
<p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>这道题是用大顶堆呢还是小顶堆呢，其实两种方式都可以实现</p>
<ul>
<li><p>大顶堆思路</p>
<blockquote>
<p>由于你是大顶堆上面的是最大的那么你最后poll出来的前k个就是出现频率最高的元素</p>
</blockquote>
</li>
<li><p>小顶堆思路</p>
<blockquote>
<p>将最小的在遍历map的时候poll出去，队列中余下的就都是出现频率最高的元素</p>
</blockquote>
</li>
</ul>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<p>通过大顶堆进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  			<span class="comment">//通过map来获取每一个元素出现的次数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//定义优先级队列，定义小顶堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm2[<span class="number">1</span>] - parm1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">          	<span class="comment">//遍历map通过数组出现的频率进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//最后poll出来的k个元素都是出现频率最高的元素</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>小顶堆来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm1[<span class="number">1</span>] - parm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">          </span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Stack</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.isEmpty(); <span class="comment">//true</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.pop(); <span class="comment">//4</span></span><br><span class="line">stack.peek(); <span class="comment">//3</span></span><br><span class="line">stack.isEmpty(); <span class="comment">// false</span></span><br><span class="line">stack.search(<span class="number">4</span>); <span class="comment">// -1 没有返回-1</span></span><br><span class="line">stack.search(<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">stack.search(<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line">stack.search(<span class="number">1</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push</td>
<td></td>
<td>将元素压入栈中</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>从栈顶移除元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>查看栈顶元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>search</td>
<td></td>
<td>查找元素在栈中的位置</td>
</tr>
</tbody></table>
<p><strong>Queue</strong></p>
<p>单项队列，只能够操作入队列的那一边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">que.offer(<span class="number">1</span>);</span><br><span class="line">que.offer(<span class="number">2</span>);</span><br><span class="line">que.offer(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> que.poll();</span><br><span class="line">System.out.println(a); <span class="comment">//1</span></span><br><span class="line">System.out.println(que.peek()); <span class="comment">//2</span></span><br><span class="line">System.out.println(que.pollLast()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td></td>
<td>向队列尾部添加元素</td>
</tr>
<tr>
<td>offer</td>
<td></td>
<td>向队尾添加元素，方法优于add</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>poll</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>获取队列头部元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>size</td>
<td></td>
<td>获得队列的长度</td>
</tr>
</tbody></table>
<p><strong>Deque</strong></p>
<p>简介：又名双向队列，可以从两边操作元素</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>offerFirst</td>
<td></td>
<td>从前面插入元素</td>
</tr>
<tr>
<td>offerLast</td>
<td></td>
<td>从后面插入元素</td>
</tr>
<tr>
<td>pollFirst</td>
<td></td>
<td>从前面获取并移除元素</td>
</tr>
<tr>
<td>pollLast</td>
<td></td>
<td>从后面获取并移除元素</td>
</tr>
<tr>
<td>peekFirst</td>
<td></td>
<td>获取头部元素</td>
</tr>
<tr>
<td>getLast</td>
<td></td>
<td>获取尾部元素</td>
</tr>
<tr>
<td>remove(Object o)</td>
<td></td>
<td>移除指定元素，如果队列中有重复的，移除最先入队列的</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>Size</td>
<td></td>
<td>获取队列长度</td>
</tr>
</tbody></table>
<p><strong>PriorityQueue</strong></p>
<p>优先级队列</p>
<p>默认情况下是升序排序，并不是所有元素都按升序进行排序，只有队列头部是最小的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq); <span class="comment">//[-3, 6, 0, 9]</span></span><br></pre></td></tr></table></figure>

<p>如果想要所有元素都按照升序排序，将每一次排好序的首元素进行poll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> pq.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>); <span class="comment">//-3 0 6 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要降序排序的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>优先队列 大顶堆</p>
<blockquote>
<p>首元素是最大的，其余的都比他小，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<p>小顶堆</p>
<blockquote>
<p>首元素是最小的，其余的都比他大，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><p>二叉树主要以两种形式出现</p>
<ul>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
<p><strong>满二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/满二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>满二叉树每一层每一个节点的位置都占据满了，深度为k，有2^k-1个节点的二叉树。</p>
</blockquote>
<p><strong>完全二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/完全二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>除了最后一层其余每一层的节点都占满了</p>
</blockquote>
<p><strong>二叉搜索树</strong></p>
<ul>
<li>左子树不为空，其左子树上的节点都小于左子树根结点的值</li>
<li>右子树不为空，其右子树上的节点都小于右子树根结点的值</li>
<li>左子树和右子树都会二叉排序树</li>
</ul>
<p><strong>平衡二叉搜索树</strong></p>
<p>又被称为AVL树，他可以是空树或者是左子树和右子树的绝对值不大于1的树</p>
<p>我们平时使用的map和set都是机遇平衡二叉搜索树来实现的</p>
<p><font size = "6">二叉树的存储方式</font></p>
<hr>
<p>存储方式主要分为两种链式存储和顺序存储</p>
<p><strong>链式存储主要用的就是指针，顺序存储主要用的就是数组</strong></p>
<p>链式存储用的左右指针来遍历子元素</p>
<p>那么顺序存储是如何拿到子元素的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<p><font size = "6">二叉树的遍历方式</font></p>
<hr>
<p>二叉树主要有两种遍历方式</p>
<ol>
<li><p>深度优先遍历</p>
<blockquote>
<p>先往深走，遇到叶子节点再往回走</p>
</blockquote>
</li>
<li><p>广度优先遍历</p>
<blockquote>
<p>一层一层的去遍历</p>
</blockquote>
</li>
</ol>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先搜索<ul>
<li>层次遍历</li>
</ul>
</li>
</ul>
<p>如何快速分清前序遍历，中序遍历，后续遍历</p>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong></p>
<p>前序遍历：中左右</p>
<p>中序遍历：左中右</p>
<p>后序遍历：左右中</p>
<p>图解分析</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.png"></p>
<p>在后面的习题中深度优先搜索都会接住递归来完成，广度优先搜索大部分都是借助队列来完成的，这个在后面慢慢说</p>
<p><font size = "6">如何定义二叉树</font></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		TreeNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val&#125;;</span><br><span class="line">		TreeNode(TreeNode left,TreeNode right,<span class="type">int</span> val)&#123;</span><br><span class="line">				<span class="built_in">this</span>.left = left;</span><br><span class="line">				<span class="built_in">this</span>.right = right;</span><br><span class="line">				<span class="built_in">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>递归遍历主要分为三种遍历方式：前序遍历，中序遍历，后续遍历</p>
<p>书写递归要考虑一下三步</p>
<ul>
<li><p>确定递归函数的参数和返回值</p>
</li>
<li><p>确定终止条件</p>
</li>
<li><p>确定单层递归的逻辑</p>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">题目入口</a></p>
<p>思路</p>
<ul>
<li>我们什么是否进行返回(当遍历到的值为空的时候进行返回)</li>
<li>遍历的顺序是什么</li>
</ul>
<p>递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        preOrder(node.left,result);</span><br><span class="line">        preOrder(node.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>思路</p>
<p>我们可以通过栈来实现迭代，首先把根结点放入栈中然后通过stack pop出的根结点来将左右节点放入到栈中，但是一定要先放右后放左，这样pop出来的才是正序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midOrdered(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        midOrdered(root.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将左边的元素全部放入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//接着判断右边是否为空</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LastOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LastOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        LastOrdered(root.left,result);</span><br><span class="line">        LastOrdered(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序迭代</p>
<p>思路</p>
<p>将前序遍历左右进行反转最后将整体进行一个反转效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><hr>
<h4 id="二叉树的层序遍历-1"><a href="#二叉树的层序遍历-1" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">题目入口</a></p>
<p>所谓层序遍历就是图论中的广度优先搜索</p>
<p>思路</p>
<p>我们可以用队列来解决这道题，为什么选择了队列而不是栈呢？</p>
<p>因为结果是从左到右的，队列正好也是先入先出，刚好满足题意</p>
<p><code>我们可以通过size来记录每一层中的元素的个数，记录好后遍历将所有本层中的元素pop出来，在这个过程中我们需要将他的子节点放入到队列中，从而保证下一次队列中的元素都是下一层的</code></p>
<p>广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的层次遍历-II"><a href="#二叉树的层次遍历-II" class="headerlink" title="二叉树的层次遍历 II"></a>二叉树的层次遍历 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">题目入口</a></p>
<p>思路</p>
<p>反转第一道题的二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">题目入口</a></p>
<p>思路分析</p>
<p>使用层序遍历，在遍历到每一层的最后一个元素的时候将他放入到集合当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历将求每一层的和最后求平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>,average = <span class="number">0</span>;;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                sum += temp.val;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            average = sum / size;</span><br><span class="line">            result.add(average);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">题目入口</a></p>
<p>思路</p>
<p>思路和二叉树的层序遍历一样</p>
<p><code>Node里面定义的List&lt;Node&gt; children不是方法，是一个属性</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                List&lt;Node&gt; children = temp.children;</span><br><span class="line">                <span class="keyword">if</span>(children == <span class="literal">null</span> || children.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(Node each : children)&#123;</span><br><span class="line">                        que.offer(each);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">题目入口</a></p>
<p>思路</p>
<p>层序遍历找每一层的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                max = Math.max(max,temp.val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">题目入口</a></p>
<p>思路</p>
<p>由于需要将同层的两个相邻的元素通过next建立联系，所以我们先获取首元素，然后通过size来遍历剩余的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="comment">//获取首元素方便首元素调用next</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="comment">//i初始为不算首元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                <span class="comment">//首元素后移，并不断指向后面的元素</span></span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/submissions/">题目入口</a></p>
<p>一样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历，每遍历一层deep++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>当某一个节点的左右两边都是空的话就可以将高度进行返回了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            deep++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> deep;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑采用哪种遍历方式？</p>
<p>这道题前序遍历和后序遍历都行，中序遍历不行</p>
<p>中序遍历不行一会说</p>
<p>假如我们采取的遍历方式是前序遍历</p>
<p>中 左 右</p>
<p>相当于我们上来交换左子树和右子树，遍历左子树并交换，每一个节点交换左右节点，然后遍历右子树，同样的操作</p>
<p>为什么中序比哪里不行？</p>
<blockquote>
<p>因为如果你采用中序遍历，上来你确实是吧左子树的每一个节点的左右元素进行交换了，但是来到中这一步，我们将左右子树进行了一个交换，现在右子树是交换好的，左子树是没有交换过的，然后接着我们又去交换右子树，又把上来的右子树交换回去了，结果就是整个流程就把左右子树进行了交换其余什么都没有干</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root);</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>广度优先搜索</p>
<p>思路</p>
<p>每poll出一个节点将他的左右子节点进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                swap(temp);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑应该使用哪种遍历方式？</p>
<p>你可以把这道题形象的表达为处理左右两个二叉树的题，将最终的结果返回给中间</p>
<p>所以我们使用的肯定是后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">      	<span class="comment">//四种考虑情况只要有一个不满足结果就是false</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断两边是否相等</span></span><br><span class="line">      	<span class="comment">//判断中间是否相等</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c1</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c2</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> c1 &amp;&amp; c2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>在开始之前简单回顾一下高度和深度的概念</p>
<p><strong>深度</strong></p>
<blockquote>
<p>深度是到根结点的距离叫做深度，根结点的深度为1，依次递增</p>
</blockquote>
<p><strong>高度</strong></p>
<blockquote>
<p>高度是到达叶子节点的距离，和深度恰恰相反</p>
</blockquote>
<p><u>求高度用后续遍历，求深度用前序遍历</u></p>
<p>这道题为什么我们采用后续遍历呢？</p>
<p>因为根结点的高度就是二叉树的最大深度</p>
<p>解题思路</p>
<p>递归：我们可以通过后续遍历统计左孩子和右孩子的最大高度最后再加上根结点即为最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>最小深度的概念是必须对应的那个结点的左右子树都是空，才是最小深度</p>
<p>本题要找的是根结点到最近<code>叶子节点</code>的深度</p>
<p>思路</p>
<p>这道题和最大深度相似，但是其中有坑</p>
<p>我们也采用后续遍历，但是返回的时候，需要考虑有一边为空的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">题目入口</a></p>
<p>普通二叉树处理</p>
<p>思路</p>
<p>使用后序遍历对二叉树左边和右边进行遍历最后加上根结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getNodeNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLenght</span> <span class="operator">=</span> getNodeNum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftLength + rightLenght + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要求满二叉树的数量的话，通过2 ^ n - 1就可以轻松解决</p>
<p>完全二叉树处理</p>
<p>思路</p>
<ul>
<li><p>二叉树是否为空</p>
</li>
<li><p>完全二叉树是否为满二叉树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//考虑完全二叉树为满二叉树的情况</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>,rightLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftLength++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            rightLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftLength == rightLength)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftLength) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getLength(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getLength(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于上述直接处理的情况明显处理的情况变少了，时间复杂度也低了</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">题目入口</a></p>
<p>什么是平衡二叉树？</p>
<p>任何一个节点的左右子树的高度差绝对值小于等于1</p>
<p>思路</p>
<p>递归：我们应该使用哪种遍历方式？</p>
<p>这道题我们可以可以通过遍历二叉树的左子树和右子树，如果不是平衡二叉树返回结果是-1，否则返回结果就是高度的差值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> getLength(root);</span><br><span class="line">        <span class="keyword">return</span> res != -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//后续遍历</span></span><br><span class="line">        <span class="comment">//递归左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="keyword">if</span>(leftLength == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//递归右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        <span class="keyword">if</span>(rightLength == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(Math.abs(leftLength - rightLength) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">题目入口</a></p>
<p>思路</p>
<p>确定参数： 由于要收集路径，还有每一个节点的值，所以我们要定义三个参数(root,String[] str,int[] arr) ，返回值类型为空</p>
<p>判断终止条件：当遍历到当前节点为叶子节点</p>
<p>确定遍历方式：前序遍历，因为要逐层深入，而不是最终将孩子的数据返回给父亲</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getPath(root,res,path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node,List&lt;Integer&gt; res,List&lt;String&gt; path)</span>&#123;</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                sb.append(res.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(node.val);</span><br><span class="line">            path.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(node.left,res,path);</span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            getPath(node.right,res,path);</span><br><span class="line">            res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">题目入口</a></p>
<p>什么是左叶子节点？</p>
<p>必须是叶子节点并且有父级位于父级的右子节点</p>
<p>思路</p>
<p>终止条件：当前节点为叶子节点</p>
<p>遍历方式：后续遍历，因为我们需要获取左子树左叶子节点的个数 + 右子树左叶子节点的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//减少递归的层数，不去进行无用的递归</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            leftLength = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> leftLength + rightLength;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">题目入口</a></p>
<p>误区</p>
<p>这里面深度最深左下角的值并不一定是左节点，如果没有左节点的话，可以是最后一层位于右边的节点</p>
<p><strong>所以我们在这里面优先遍历左侧的元素</strong></p>
<p>思路</p>
<p>这道题任何遍历方式都是可以的，为什么呢？</p>
<blockquote>
<p>因为我们只需要处理左右的逻辑，和中间无关</p>
</blockquote>
<p>截止条件：当遍历到的是叶子节点,并且在此刻判断深度是否为最大，将值进行存储</p>
<p>接着进行左递归,右递归，别忘了回溯</p>
<blockquote>
<p>回溯的过程相当于除根结点外，将其余的值全部pop出去</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDepth</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        getValue(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">(TreeNode node,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//叶子节点为截止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deep &gt; maxDepth)&#123;</span><br><span class="line">                maxDepth = deep;</span><br><span class="line">                result = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            deep++;</span><br><span class="line">            getValue(node.left,deep);</span><br><span class="line">            deep--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            deep++;</span><br><span class="line">            getValue(node.right,deep);</span><br><span class="line">            deep--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">题目入口</a></p>
<p>目标：求二叉树中的某一条路径上的值相加起来和为target目标值</p>
<p>思路</p>
<p>我们可以递归左子树和右子树，对每一个节点上的数值进行减法操作</p>
<p>截止条件：当当前节点是叶子节点，并且count - 节点的值为0的话返回结果为true</p>
<p>遍历方式：这道题也没有中的处理逻辑，所以哪种遍历方式都是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> JudgePathSum(root,targetSum - root.val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">JudgePathSum</span><span class="params">(TreeNode root,<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            count -= root.left.val;</span><br><span class="line">          	<span class="comment">//遇到符合条件的返回true</span></span><br><span class="line">            <span class="keyword">if</span>(JudgePathSum(root.left,count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          	<span class="comment">//回溯</span></span><br><span class="line">            count += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            count -= root.right.val;</span><br><span class="line">            <span class="keyword">if</span>(JudgePathSum(root.right,count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += root.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">题目入口</a></p>
<p>思路分析</p>
<ul>
<li><p>如果后序数组为空说明没有根结点</p>
</li>
<li><p>通过后序数组来确定根结点</p>
</li>
<li><p>借助根结点和中序数组进行切割</p>
</li>
<li><p>然后切割后序数组</p>
</li>
<li><p>递归处理左右区间</p>
</li>
</ul>
<p>易错点</p>
<ul>
<li><p>切割数组：注意是左闭右闭还是左闭右开</p>
</li>
<li><p>如何递归</p>
<blockquote>
<p>将每一次切割出来的左数组和右数组接着通过同样的方法去构建子树</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index &lt; inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index] == root.val) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//切割中序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftInOrder = Arrays.copyOfRange(inorder,<span class="number">0</span>,index);</span><br><span class="line">        <span class="type">int</span>[] rightInOrder = Arrays.copyOfRange(inorder,index + <span class="number">1</span>,inorder.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//切割后序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftPostOrder = Arrays.copyOfRange(postorder,<span class="number">0</span>,leftInOrder.length);</span><br><span class="line">        <span class="type">int</span>[] rightPostOrder = Arrays.copyOfRange(postorder,leftInOrder.length,leftInOrder.length + rightInOrder.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        root.left = buildTree(leftInOrder,leftPostOrder);</span><br><span class="line">        root.right = buildTree(rightInOrder,rightPostOrder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>我们应该使用哪种遍历方式？</p>
<p>这道题我们优先选择前序遍历，因为构建二叉树需要的前提是先要有根结点然后构建左右子树</p>
<p>这道题还是让我们去找最大值以及对应的下标，通过这个下标来分割数组(需要考虑左右是否有元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//确定根结点的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxValue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">				<span class="comment">//判断左子树至少包含一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[] leftArr = Arrays.copyOfRange(nums,<span class="number">0</span>,index);</span><br><span class="line">            root.left = constructMaximumBinaryTree(leftArr);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//判断右子树至少包含一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[] rightArr = Arrays.copyOfRange(nums,index + <span class="number">1</span>,nums.length);</span><br><span class="line">            root.right = constructMaximumBinaryTree(rightArr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">题目入口</a></p>
<p>思路</p>
<p>考虑遍历的顺序？</p>
<p>优先选择前序遍历,从根结点进行构建</p>
<p>确定终止条件</p>
<ul>
<li>如果root2发现是空，返回结果是有值的root1</li>
<li>如果root1是空，返回结果是有值的root2</li>
<li>如果都是空的话返回的结果就是空</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            root1.val += root2.val;</span><br><span class="line">            root1.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">            root1.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h3><p>二叉搜索树的概念</p>
<p><code>左子树中的所有元素都小于根结点，右子树中的所有元素都大于根结点，左子树满足该条件，右子树也满足该条件</code></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">题目入口</a></p>
<p>迭代法</p>
<p>通过val值从根结点出发去寻找该值所在的位置，最后进行返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val &gt; root.val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(val &lt; root.val) root = root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归法</p>
<ul>
<li><p>确定截止条件</p>
<blockquote>
<p>如果二叉树没有元素，返回null，或者是root的val就是需要查找的值，返回root</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            result = searchBST(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            result = searchBST(root.right,val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            result = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">题目入口</a></p>
<p>比较直白的写法</p>
<p><strong>通过中序遍历，将每一个元素放入到数组当中，判断这个数组是否是升序的</strong></p>
<p>这种方式十分的耗时，不太推荐</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        isValidBST(root.left);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get(i) &lt;= result.get(i - <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归法</p>
<p>遍历方式：由于我们需要从小到大的顺序去进行判断，所以我们采用中序遍历</p>
<p>注意点</p>
<ul>
<li><p>由于数据类型比较大我们需要使用long数据类型来记录数据</p>
</li>
<li><p>为什么我们需要通过maxValue来更新数据？</p>
<p>  <code>如果不通过这种方式来判断很可能写成root.left.val &gt; root.val &amp;&amp; root.right.val &gt; root.val，这样的话只能保证根结点的左右数值满足二叉搜索</code></p>
<p>  图解</p>
  <img src="/Users/satrol_/Desktop/NotepadImg/二叉搜索树.jpg" style="zoom:33%;" /></li>
</ul>
<p>定义maxValue完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">maxValue</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftBool</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; maxValue)&#123;</span><br><span class="line">            maxValue = root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightBool</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftBool &amp;&amp; rightBool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如上方式是不严谨的，因为如果测试数据中有long最小值的话，那么就不好使了</strong></p>
<p>借助pre完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftBool</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightBool</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftBool &amp;&amp; rightBool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">题目入口</a></p>
<p>比较直白的想法，中序遍历将每一个值放入到集合中，进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        filledList(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Math.abs(result.get(i) - result.get(i - <span class="number">1</span>)) &lt; min)&#123;</span><br><span class="line">                min = Math.abs(result.get(i) - result.get(i - <span class="number">1</span>));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">filledList</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        filledList(root.left);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        result.add(root.val);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        filledList(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针</p>
<p>实现思路</p>
<p>通过pre记录当前节点的上一个节点，通过比较相邻节点来获取最小绝对值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMinVal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinVal</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        getMinVal(root.left);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &gt; pre.val) &#123;</span><br><span class="line">            result = Math.min(result,root.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        getMinVal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>思考这道题选择哪种遍历方式？</p>
<p>因为是二叉搜索树，所以这道题优先选择中序遍历，大小从小到大的顺序</p>
<p>比较直接的思路</p>
<p><code>遍历二叉树结合哈希表统计最大的元素，由于Map不易操作转化比较困难，所以不推荐使用</code></p>
<p>第二种思路</p>
<blockquote>
<p>遍历一边二叉树用来统计出现最高频率的次数，再去遍历一遍二叉树，判断那一个的出现频率等于最大频率</p>
</blockquote>
<p>这种思路其实是可以进行优化的，通过双指针只用一次遍历来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>,maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        FillWithResult(root);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[result.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; result.size();i++)&#123;</span><br><span class="line">            res[i] = result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FillWithResult</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        FillWithResult(node.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">      	<span class="comment">//用来记录出现频率最大的次数</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span> || node.val != pre.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;	</span><br><span class="line">				<span class="comment">//寻找等于出现次数最大的节点值</span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount) result.add(node.val);</span><br><span class="line">      	<span class="comment">//更新最大值</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            result.clear();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//双指针用来记录node前一个节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        FillWithResult(node.right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>通过两个子代向上遍历二叉树，发现父亲的值相等进行返回</p>
<p>选择哪种遍历方式？</p>
<p>由于是子类向父类返还数据，和回溯很想，所以这道题我们采用后续遍历，将数据交由中来处理</p>
<p>判断终止条件</p>
<p><code>如果发现p或者是q的话就将当前元素的父元素进行返回，最终返回给root进行处理</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root == p|| root == q)  <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉搜索树的最近公共祖先"><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">题目地址</a></p>
<p>思路</p>
<p>从根结点出发，通过判断两个值和根结点的大小来决定走左子树还是右子树，如果发现遍历过程中有一个值在两个值的中间那么他就是公共祖先</p>
<p>为什么这个节点他就是公共祖先呢?</p>
<p>图解</p>
<img src="/Users/satrol_/Desktop/NotepadImg/最近公共祖先.jpg" style="zoom:33%;" />

<p>假如从根结点进行遍历发现某一个值满足条件，如果往左遍历就不属于大于他的那个值的祖先了，往右遍历就不属于小于他的那个值的祖先了，所以当前结点就是最近公共祖先了</p>
<p>递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果发现p和q的值比当前结点小的话，说明分布在当前结点的左子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="comment">//记录左值</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">            <span class="comment">//如果不为空说明存在最近父节点</span></span><br><span class="line">            <span class="keyword">if</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果发现p和q的值比当前结点大的话，说明分布在当前结点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">            <span class="keyword">if</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当当前结点的值位于p和q之间的话返回当前节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">题目入口</a></p>
<p>插入的节点插入到的是叶子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      	<span class="comment">//如果是叶子节点返回给上一级</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//左叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left,val);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//右叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">题目入口</a></p>
<p>思路</p>
<p>本题包含五种情况</p>
<ul>
<li><p>没有找到要删除的节点</p>
</li>
<li><p>删除的节点是叶子节点</p>
<p>  <code>易删除，因为并没有破坏二叉树的结构</code></p>
</li>
<li><p>删除的节点左不为空，右为空</p>
<p>  <code>删除节点的父节点指向删除节点的左子节点</code></p>
</li>
<li><p>删除的节点左为空，右不为空</p>
<p>  <code>删除节点的父节点指向删除节点的右子节点</code></p>
</li>
<li><p>删除的节点左不为空，右不为空</p>
<p>  <code>将删除节点的左子树放在删除节点的右节点的左下节点上,即取代删除节点的是删除节点的次大节点</code></p>
<p>  图解</p>
  <img src="/Users/satrol_/Desktop/NotepadImg/二叉树删除节点.jpg" style="zoom:33%;" /></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">          	<span class="comment">//对应上else if(root.val &gt; key)的情况 如发现root.left.left == null root.left.right == null 将root.left == null</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">              	<span class="comment">//如果左为空，右不为空，将root.right = root.right.right</span></span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//如果左不为空，右为空，将root.left = root.left.left;</span></span><br><span class="line">              </span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//判断左不为空，右不为空的情况</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">          	<span class="comment">//向左遍历</span></span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">//向右遍历</span></span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码(以上五种情况都是迎合这串代码)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">  	<span class="comment">//向左遍历</span></span><br><span class="line">    root.left = deleteNode(root.left,key);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  	<span class="comment">//向右遍历</span></span><br><span class="line">    root.right = deleteNode(root.right,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>判断root的值是否超出了裁剪的范围，如果当前节点比low小的话，那么去遍历右边，接着将low小的修剪掉，如果当前节点比high大的话，那么去遍历左边，将比high大的修剪掉</p>
<p>先看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; low)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> trimBST(root.right,low,high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> trimBST(root.left,low,high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解(举例说明)</p>
<img src="/Users/satrol_/Desktop/NotepadImg/裁剪二叉树.jpg" style="zoom:40%;" />





<h3 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">题目入口</a></p>
<p>思路</p>
<p>因为数组是有序的，我们可以将数组的中间节点作为根结点，将左部分的中间节点作为根结点的左子节点，将右部分的中间节点作为根结点的右子节点，以这样的规律下去，就能保证二叉树的平衡性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BanlanceTree(nums,<span class="number">0</span>,nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">BanlanceTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right]</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        root.left = BanlanceTree(nums,left,mid - <span class="number">1</span>);</span><br><span class="line">        root.right = BanlanceTree(nums,mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">题目入口</a></p>
<p>思路</p>
<p>本题要求的累加数是从右到左的顺序进行相加的，我们可以通过双指针来快速解决这道问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traversel(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversel</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        traversel(cur.right);</span><br><span class="line">        <span class="comment">//中</span></span><br><span class="line">        cur.val += pre;</span><br><span class="line">        pre = cur.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        traversel(cur.left);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p><strong>可以将回溯抽象成一个树形结构，递归的深度代表了树的深度，集合的个数代表了树的宽度</strong></p>
<p>回溯题目统一的模版</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(参数)</span>&#123;	</span><br><span class="line">		<span class="keyword">if</span>(截止条件)&#123;</span><br><span class="line">			收集结果</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(遍历集合)&#123;</span><br><span class="line">				处理数据</span><br><span class="line">				递归</span><br><span class="line">				回溯</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>题意</p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>注意事项</p>
<p>组合中不能出现重复的元素和顺序颠倒的元素</p>
<p>例如: <code>22</code>  <code>23 32</code></p>
<p>初始化操作</p>
<p>定义一个一维数组<code>path</code>用来存放集合中的元素来构建组合</p>
<p>定义一个二维数组<code>result</code>用来存放组合</p>
<p>确定参数</p>
<p>参数包括集合中的元素的个数，组合的大小，startIndex(每一次递归搜索的起始位置)</p>
<p>确定终止条件</p>
<p>当我们组合的大小等于k的时候，我们就可以将结果进行收集</p>
<p>单层循环的逻辑</p>
<p>遍历集合，for循环收集集合中的元素，当我们收集一个元素后，我们需要接着遍历剩余的元素，所以我们需要使用递归，接着遍历剩余的情况，递归函数传入的i + 1作为下一次遍历的起始位置</p>
<p>回溯，在递归操作执行后将每一次执行后的结果pop出来</p>
<p>这里可能有疑问，为什么我元素刚加入进去，怎么又pop出来了？</p>
<p>因为递归执行后，组合的大小已经达到了题目要求的大小，将组合进行收集，return，接着将最外层的元素进行pop，接着再去进入下一次递归操作</p>
<p>本题大体思路已经描述完毕，看一看是否可以优化？</p>
<p>实际上是可以的，因为如果k的要求过大，你就会发现取完一个元素剩余元素的个数加上当前这元素也无法凑成k，那么这次循环及以后是没有意义的，完全可以删除掉</p>
<p>在哪里进行优化呢？</p>
<p>刚刚我们说了这次循环及以后是没有意义的，所以我们需要在for循环上面动手脚</p>
<p>我们已经选取的元素是<code>path.size()</code> ，我们需要的元素是k个，那么剩余需要的元素是<code>k - path.size()</code></p>
<p>至多从这个位置开始：n - (k - path.size()) + 1&#96;我们才能满足条件</p>
<p>至多从哪个位置开始什么意思？</p>
<p>假如<code>n = 4 k = 3 没选元素</code></p>
<p>计算之后等于2</p>
<p>我们可以从1位置开始，也可以从2位置开始</p>
<p>这里面的1实际上算上的是startIndex</p>
<p>如果没有理解这个公式怎么来的，我们可以通过列举例子来解决</p>
<p><code>n = 4 k = 4 此时我们path中并没有选取元素</code> </p>
<p><code>4 - (4 - 0) + 1 = 1</code>  <strong>我们至多需要从1开始才能满足组合中包含四个元素</strong></p>
<p>本例中，for循环横向仅仅遍历了一次，正常来说1，2，3，4四个元素当选择1的时候才能出现四个元素的组合，如果选择2，剩余的选项只有3和4凑不成4个，所以遍历一次是正确的</p>
<p>如果上面看懂的话，下面的每一步其实都是很清晰的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backTracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= n - (k - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(n,k,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h3><p>题意</p>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>初始化操作</p>
<p>和上一道题一样我们需要定义一个二维数组<code>result</code>和一个一维数组<code>path</code></p>
<p>函数的参数</p>
<p>参数有n，k，目标sum，用来记值的sum，startIndex</p>
<p>截止条件</p>
<p>还是一样当<code>path.size() == k</code>，return</p>
<p>收集结果是当<code>sum == targetSum</code>的时候收集</p>
<p>单层循环逻辑</p>
<p>for循环遍历集合中的元素</p>
<p>存入path中，接着进行递归选取其余的元素</p>
<p>回溯</p>
<p>代码优化</p>
<p>本题和上一道题一样</p>
<p>可以对元素的剩余个数不满足k进行一个剪枝</p>
<p><code>9 - (k - path.size()) + 1</code></p>
<p>还有一个剪枝操作是当sum已经大于目标值当时候，就已经不用接着向下进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(sum &gt; targetSum) return;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backTracking(k,n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(path.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum == n) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backTracking(k,n,sum,i + <span class="number">1</span>);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p>题意</p>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p>初始化</p>
<p>由于最终是要将字符串放入到集合当中所以我们需要定义<code>String s</code>和<code>result</code>集合</p>
<p>确定参数</p>
<p>参数包含输入到字符串，index索引用来记录字符串对应的字符</p>
<p>确定终止条件</p>
<p>当我们index指向字符串最后一个元素的后一个元素的时候结束，并且此时将s放入到result集合中</p>
<p>单层循环的逻辑</p>
<p>我们需要通过index对应的字符串的下标获取到map数组中的字母串，遍历这个字母串，接着递归进入下一层，将index + 1传入</p>
<p>回溯 </p>
<p>这里面回溯的过程可以带入到递归中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">backTracking(digits,index + <span class="number">1</span>,s + letter[i]);</span><br></pre></td></tr></table></figure>

<p>将组合后的结果传入到下一层中，但是本质上s并没有发生改变也就不用remove了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    String[] mapTable = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span> || digits == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        backTracking(digits,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String digits,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.length()) &#123;</span><br><span class="line">            result.add(s.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mapTable[num];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; str.length();i++)&#123;</span><br><span class="line">            s.append(str.charAt(i));</span><br><span class="line">            backTracking(digits,index + <span class="number">1</span>);</span><br><span class="line">            s.deleteCharAt(s.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题意</p>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>本题和组合3不同点</p>
<p>本题中的元素是可以重复使用的，并且给出的数组没有重复的元素，不需要进行去重操作，无法确定树的深度</p>
<p>构建树形结构</p>
<p>在选取完当前元素的时候，还是可以选当前元素的</p>
<p>初始化</p>
<p>同理，一个二维数组<code>result</code>，一个一维数组<code>path</code></p>
<p>确定递归函数参数</p>
<p>candidates数组，targetSum，sum，startIndex</p>
<p>确定终止条件</p>
<p>如果发现sum的值已经大于targetSum的话，直接返回结果</p>
<p>如果等于的话，将其放入到二维数组中，然后再返回</p>
<p>单层循环</p>
<p>遍历数组，将每一次遍历到的数值放入到path中，sum统计数值的和，递归传的还是当前的i，因为元素可以无限选择</p>
<p>回溯</p>
<p>本题其实还是可以进行剪枝优化的</p>
<p>如果在选取元素的过程中发现了sum已经大于目标值的话，break</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        backTracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            backTracking(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h3><p>题意</p>
<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>本题相比于之前的题，不同之处在于需要进行去重操作</p>
<p>本题需要对什么进行去重？</p>
<p>ex: canadiate &#x3D; [1,1,6] target &#x3D; 7</p>
<p>首先了解一下树枝去重和树层去重</p>
<p>树枝去重，在树形结构每一个线路进行去重</p>
<p>树层去重，在树形结构的统一层中进行去重</p>
<p>针对于本题可以出现[1,1,6]的情况，所以树枝是不用进行去重操作的</p>
<p>树层去重，针对本题会出现两个[1,6]此时就需要对它进行去重操作</p>
<p>初始化操作</p>
<p>明确函数的参数</p>
<p>candidates数组，target，sum，startIndex，isUsed(用来进行去重操作)</p>
<p>函数的终止条件</p>
<p>如果发现<code>sum &gt; target</code> 直接return</p>
<p>如果发现<code>sum == target</code> 那么将组合进行存储，return</p>
<p>isUsed如何进行去重操作</p>
<p>我们可以先对元素进行排序使得相同的元素临近</p>
<p>如果发现前一个相同元素对应的isUsed的值是0的话，那么就可以对树层上的元素进行去重操作</p>
<p>continue跳过这种情况 </p>
<p>单层递归的逻辑</p>
<p>for循环遍历数组，判断如果是否出现了需要去重的情况</p>
<p>更新sum和isUsed，递归，回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backTracking(candidates,target,<span class="number">0</span>,<span class="number">0</span>,isUsed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startIndex,<span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            backTracking(candidates,target,sum,i + <span class="number">1</span>,isUsed);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p>题意</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p>初始化</p>
<p>本题还是一样初始化一个二维数组result，初始化一个一维数组path</p>
<p>确定函数的参数</p>
<p>函数的参数包括传入的字符串，startIndex用来定义下次选取的起始位置</p>
<p>确定终止条件</p>
<p>当我们切割到了字符串的末尾的时候，也就是树的叶子节点就可以将path添加到result中</p>
<p>单层遍历逻辑</p>
<p>for循环遍历字符串，我们需要获取切割好的子串判断它是否是回文的，我们如何获取切割好的子串呢？</p>
<p>其实<code>[startIndex,i]</code>这个区间就是子串的区间，因为i是在不断的进行变化的，而startIndex是固定的</p>
<p>接着我们需要书写一个方法用来判断字符串从start开始到end结束这个子串是否是回文的</p>
<p>如果是回文的用path来收集这种可能，如果不是跳过这种情况接着进行切割</p>
<p>递归 + 回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindromes(s,startIndex,i))&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> s.substring(startIndex,i + <span class="number">1</span>);</span><br><span class="line">                path.add(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            backTracking(s,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindromes</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != s.charAt(end)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><p>题意</p>
<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#57;&#x32;&#46;&#49;&#54;&#56;&#x40;&#x31;&#46;&#49;">&#x31;&#57;&#x32;&#46;&#49;&#54;&#56;&#x40;&#x31;&#46;&#49;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>
<p>初始化</p>
<p>由于本题需要收集每一个ip段，所以我们需要定义一个集合用来存放</p>
<p>函数的参数</p>
<p>传入的字符串，startIndex，pointSum(用来作为截止条件)</p>
<p>函数的截止条件</p>
<p>如果<code>pointSum == 3</code>说明字符串已经被我们切割成四个字串，由于我们只对前面三个进行了切割判断，最后一个字串没有进行判断，所以我们需要对其进行判断，<code>isVaild(startIndex,s.length())</code>如果合理将其放入到集合中，return</p>
<p>单层遍历</p>
<p>遍历字符串，切割字符串，如果满足条件，那么就将<code>.</code>进行插入，pointSum数量++</p>
<p>递归，传入下一层选取的值是i + 2，因为先前插入了一个逗点</p>
<p>回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backTracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s,<span class="type">int</span> startIndex,<span class="type">int</span> pointSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pointSum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(s,startIndex,s.length() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.add(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(s,startIndex,i))&#123;</span><br><span class="line">                s = s.substring(<span class="number">0</span>,i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            pointSum++;</span><br><span class="line">            backTracking(s,i + <span class="number">2</span>,pointSum);</span><br><span class="line">            pointSum--;</span><br><span class="line">            s = s.substring(<span class="number">0</span>,i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start != end &amp;&amp; s.charAt(start) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt;= end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>) &#123; <span class="comment">// 遇到⾮数字字符不合法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>题意</p>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p>根据树形结构</p>
<p>我们会发现这道题和之前的题的区别就是，在每一个节点的位置都需要收集结果</p>
<p>初始化</p>
<p>一样的还是初始化一个二维数组，一个一维数组</p>
<p>确定函数的参数</p>
<p>传入数组，startIndex</p>
<p>确定函数的终止条件</p>
<p>当<code>startIndex == nums.length</code>终止条件，起始不写终止条件也会自动终止，因为for循环<code>i &lt; nums.length</code></p>
<p>单层遍历</p>
<p>添加每一次的值到path中，递归 + 回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span>(startIndex == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><p>题意</p>
<p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p>
<p>本题相比于子集1唯一的不同点在于元素需要进行去重去重操作，我们是要对树层进行去重，而不是树枝进行去重</p>
<p>初始化</p>
<blockquote>
<p>去重问题需要对数组进行排序，再判断是否出现重复的可能</p>
</blockquote>
<p>定义一个二维集合<code>result</code>和一个一维集合<code>path</code></p>
<p>明确函数的参数</p>
<p>传入的数组，startIndex，isUsed进行去重操作</p>
<p>函数终止条件</p>
<p>子集问题可以不用写终止条件，因为它需要收集每一个节点上的结果</p>
<p>单层循环</p>
<p>for循环遍历数组，判断是否出现了重复的情况，如果没有收集数据，递归，回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums,<span class="number">0</span>,isUsed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> firstIndex,<span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>,isUsed);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h3><p>题意</p>
<p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p>注意点</p>
<p>本题不能对nums数组进行排序，根据题目给出的例子是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums = [4,4,3,2,1] 输出：[[4,4]]</span><br></pre></td></tr></table></figure>

<p> 如果排序之后出现了很多中可能，所以不能进行排序</p>
<p>初始化</p>
<p>定义一个二维集合<code>result</code>和一个一维集合<code>path</code></p>
<p>确定函数的参数</p>
<p>传入的数组，startIndex</p>
<p>确定函数的终止条件</p>
<p>子集问题可以不写终止条件，但是递增子序列的长度至少是2，所以我们需要定义一个<code>path.size() &gt; 2</code>的条件</p>
<p>单层循环的逻辑</p>
<p>遍历数组，添加元素判断该元素是否比之前的元素大，同时判断是否之前已经选取了该元素，如果满足条件，放入到path数组中，递归 + 回溯</p>
<p><strong>重点讲一下，set去重的逻辑</strong></p>
<p>set用来记录每一层是否选取了某元素，如果已经选取了该元素直接跳过以免出现重复的可能</p>
<p><code>Ex: 4 7 6 7</code> 在第一层for循环遍历的时候会出现两次[7]</p>
<p>这里面set是不用回溯的，为什么呢？</p>
<p>因为去重操作只会出现在每一个树层中，没到达一个树层就会初始化一个新的set集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backTracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> firstIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstIndex;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || set.contains(nums[i])) <span class="keyword">continue</span>; </span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            backTracking(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>题意</p>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<p>首先理清一个概念，什么是排列，排列和组合的区别在哪里？</p>
<p>[1,2]和[2,1]属于一个组合，但是这是两个排列</p>
<p>初始化</p>
<p>定义一个二维集合<code>result</code>和一个一维集合<code>path</code></p>
<p>确认函数的参数</p>
<p>传入的数组</p>
<p>由于本题是排列问题可以取到[2,1]这种情况，所以我们并不需要设置firstIndex</p>
<p>但是我们需要isUsed数组用来记录元素是否被使用过</p>
<p>确定终止条件</p>
<p>如果path的长度等于提供的数组的长度的话，就可以使用reuslt进行收集</p>
<p>单层遍历</p>
<p>for循环遍历数组，此时并不需要从firstIndex开始进行遍历了，从0开始即可</p>
<p>如果发现isUsed数组中某一位已经被使用了那么就跳过这种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backTracking(nums,isUsed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums,isUsed);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h3><p>题意</p>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列</p>
<p>和上一道题不同点就是需要进行去重操作，比如[1,1,2]如果按照上一题的思路来做的话，会出现两个[1,1,2]，第一种情况是先取第一个1，再取第二个1，第二种情况是先取第二个1再取第一个1</p>
<p>初始化</p>
<p>定义一个二维集合<code>result</code>和一个一维集合<code>path</code></p>
<p>确定函数参数</p>
<p>传入的数组，isUsed数组</p>
<p>确定终止条件</p>
<p>如果发现path的长度等于传入数组的长度，result收集path</p>
<p>单层遍历</p>
<p><code>去重操作一定要先进行排序操作，方便nums进行比较</code></p>
<p>for循环遍历数组，判断是否出现出现重复的可能，如果不重复，接着需要判断是否当前是否已经被使用过了，如果没有的话，接着进行path收集数据，递归回溯的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(nums,isUsed);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(nums,isUsed);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><p>题意</p>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>本题相比于之前的题处理的是二维的数组</p>
<p>树形结构，每一次递归取的是每一行，每一次遍历遍历的是每一行的每一个元素</p>
<p>初始化</p>
<p>定义的result是一个三维数组，因为要存放的是若干个棋盘</p>
<p>确定函数的参数</p>
<p>一个二维的棋盘，n代表棋盘的大小，row代表行数</p>
<p>确定函数的终止条件</p>
<p><code>row == n</code>，当遍历到最后一行到时候收获合适的棋盘，return</p>
<p>单层循环</p>
<p>for循环遍历棋盘，判断棋盘上的点是否满足条件，如果满足条件，通过递归判断下一行中满足条件的位置，回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] chessboard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : chessboard)&#123;</span><br><span class="line">            Arrays.fill(ch,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(chessboard,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">charConvertor</span><span class="params">(<span class="type">char</span>[][] chessboard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] ch : chessboard)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] chessboard,<span class="type">int</span> n,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            result.add(charConvertor(chessboard));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; chessboard.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVaild(row,i,chessboard,n))&#123;</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                backTracking(chessboard,n,row + <span class="number">1</span>);</span><br><span class="line">                chessboard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">char</span>[][] chessboard,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//45</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col - <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>;i--,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>,j = col + <span class="number">1</span>;i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n;i--,j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p>题意</p>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 遵循如下规则：</p>
<p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>
<p>本题如果还是用N皇后的思路是无法解决的，因为它相比于N皇后其实多了一个维度</p>
<p>我们通过for循环遍历棋盘，查看哪个点是空缺的，然后接着判断这个这个位置放什么合适</p>
<p>函数返回值</p>
<p>返回值为bool类型，只要在树枝上发现了合适的结果立马向上一层做出一次反馈 </p>
<p>遍历的逻辑</p>
<p>我们首先需要使用两个for循环去寻找数独上的空位，然后依次填入字符1到9的数，判断是否满足条件，如果满足条件，递归，由于递归返回的结果是一个bool类型，如果递归返回的结果是true说明数独上的数很合适，返回true，回溯</p>
<p>for循环在填入数的时候如果发现所有数都不合适，那么直接return false</p>
<p>如果每一个填入的数都合适的话，两层for循环将会结束，最终返回结果true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backTracking(board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;k &lt;= <span class="string">&#x27;9&#x27;</span>;k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isVaild(i,j,k,board))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(backTracking(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col,<span class="type">int</span> val,<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">9</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][j] == val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> row / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> col / <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r;i &lt; r + <span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l;j &lt; l + <span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == val)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p><strong>局部最优推出全局最优</strong></p>
<h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><p>题意</p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p>贪心思想</p>
<p><code>胃口: 1 4 7 10</code></p>
<p><code>饼干: 2 5 6 9</code></p>
<p>我们应该用尽可能大的饼干去投喂胃口尽可能大的孩子，这样可以防止大饼干浪费的情况</p>
<p>这种思想的前提是胃口和饼干都需要进行排序</p>
<p>遍历逻辑</p>
<p>for循环从大到小遍历胃口，while循环控制饼干，判断饼干是否能满足大孩子的胃口，如果可以饼干再向前进行移动</p>
<p>这里面使用while方便对饼干进行控制</p>
<p>思考可不可以进行颠倒？</p>
<p>其实是不行的，我们外层遍历胃口，在这么多饼干中去寻找满足该胃口孩子可能</p>
<p>其他思路</p>
<p>相反本题还可以使用小饼干去满足胃口小的小孩，这么从前向后进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> g.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= <span class="number">0</span> &amp;&amp; g[i] &lt;= s[index])&#123;</span><br><span class="line">                index--;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><p>题意</p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<p>例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</p>
<p>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。<br>子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。</p>
<p>注意点</p>
<p>当有一个元素或者是有两个元素也是有摆动的</p>
<p>整体思路</p>
<p>我们遍历数组的时候，每次遇到一个摆动，就进行记录，如果遇到坡度，不去进行记录，并不用去考虑如何删除摆动中的这个坡度</p>
<p>如何判断一个峰值？</p>
<p><code>prediff = nums[i] - nums[i - 1]</code></p>
<p><code>curdiff = nums[i + 1] - nums[i]</code></p>
<p>如果发现prediff和curdiff互为相反数的话，那么久记录一次摆动</p>
<p><code>if(prediff &lt; 0 &amp;&amp; curdiff &gt; 0 || prediff &gt; 0 &amp;&amp; curdiff &lt; 0)</code></p>
<p>考虑平坡的情况</p>
<p>如果数组中出现<code>2 3 3 3 2</code>这里面包含两个摆动如何进行记录呢？</p>
<p>这个数组的最大摆动序列是3，<code>2 3 2</code></p>
<p>我们可以靠右边删，即将右边的两个3进行删除，保留最左边的3</p>
<p>还可以靠左边删，即将左边的两个3进行删除，保留最右边的3</p>
<p>假如，我按靠右边删来统计，即<code>prediff = 0 </code>，cudiff 小于0或者是大于0</p>
<p><code>if(prediff &lt;= 0 &amp;&amp; curdiff &gt; 0 || prediff &gt;= 0 &amp;&amp; curdiff &lt; 0)</code></p>
<p>考虑首尾元素的情况</p>
<p>针对于上面的规则只满足元素有三个元素，如果是尾元素，只有两个元素，我们可以在左边衍生出一个元素，用来统计这个摆动，首元素也是一样的</p>
<p>遍历的时候不用遍历尾元素，尾元素默认算作一个</p>
<p>考虑递增平坡的情况</p>
<p><code>Ex: 2 3 3 3 5</code></p>
<p>摆动是2，但是按照刚才的条件表达式进行统计的话，结果是3</p>
<p>初始化</p>
<p>curdiff，prediff，result默认初始化为1(尾元素也算一个摆动)</p>
<p>for循环遍历数组，curdiff记录每一次的值，prediff进行实时更新成prediff</p>
<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">题目入口</a></p>
<p>这道题有两种求解的思路</p>
<p>暴力法</p>
<p>两个for循环一个用来遍历数组中的每一个元素，另一个从当前元素的后面作为起始位置，接着去遍历剩余的元素，统计连续值的最大值</p>
<p>很明显Java中暴力法超时了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ;j &lt; nums.length;j++)&#123;</span><br><span class="line">                temp += nums[j];</span><br><span class="line">                result = Math.max(temp,result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>贪心算法</p>
<p>思路</p>
<p>我们从头到位遍历，遍历以为加到temp中，如果发现temp小于0的话我们需要将temp清空，然后下一次循环上来就加上了下一位的值，为什么要清空，因为如果保留这个temp负数那么加上下一位只会拖累下一位的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(count &gt; result) result = count;</span><br><span class="line">            <span class="keyword">if</span>(count &lt; <span class="number">0</span>) count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">题目入口</a></p>
<p>思路</p>
<p>我们需要计算出所有正利润差值的可能，很简单，遍历每一天，如果当前减去前一天的差值 &gt; 0 的话那么我们相当于是在前一天买，当天去卖，收获这比利润</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">             count += diff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">题目入口</a></p>
<p>思路</p>
<p>这道题我们不应该考虑每一次该去跳几步</p>
<p>我们应该考虑的是跳跃的范围，如果最大范围大于等于nums长度话返回true</p>
<p>每一次跳跃都是在更新覆盖范围<code>i + nums[i]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= cover;i++)&#123;</span><br><span class="line">            cover = Math.max(cover,i + nums[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">题目地址</a></p>
<p>思路</p>
<p>本题要求我们统计最少的跳跃次数</p>
<p>我们可以根据统计每一次可跳跃元素中最大的值，每一次跳最大值，统计个数</p>
<p>maxCover用来统计跳跃的最大区域</p>
<p>如果最大区域大于已经超过了数组的长度说明已经到达了末尾了，result++结束循环</p>
<p>如果发现走到了当前所在的最大区域，更新当前区域为最大区域，result++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义当前最大区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curMaxCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义最大区域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCover</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            maxCover = Math.max(maxCover,i + nums[i]);</span><br><span class="line">            <span class="comment">//如果最大区域已经超过了数组的范围，</span></span><br><span class="line">            <span class="keyword">if</span>(maxCover &gt;= nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                result++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当你走到了最大区域的时候更新你当前所在的最大区域</span></span><br><span class="line">            <span class="keyword">if</span>(i == curMaxCover)&#123;</span><br><span class="line">                curMaxCover = maxCover;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="K次取反后最大化的数组和"><a href="#K次取反后最大化的数组和" class="headerlink" title="K次取反后最大化的数组和"></a>K次取反后最大化的数组和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">题目入口</a></p>
<p>贪心思路</p>
<p>第一次贪心，我们可以优先对绝对值最大的负数进行取反，接着对其余的负数进行取反，使数组中的元素尽可能都是正数</p>
<p>第二次贪心，当全是正数了，但是k没有用完我们优先对正数中最小的数进行取反操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        nums = IntStream.of(nums)</span><br><span class="line">                .boxed()</span><br><span class="line">                .sorted((o1, o2) -&gt; Math.abs(o1) - Math.abs(o2))</span><br><span class="line">                .mapToInt(Integer::intValue).toArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) nums[<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(nums).sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">题目入口</a></p>
<p>题意</p>
<blockquote>
<p>题目给出了两个数组让我们求从哪个索引出发，在保证油量充足的情况下，最终能够到达原点</p>
</blockquote>
<p>贪心思路</p>
<p>我们生成一个新的数组用来存放每一次补充的油量和消耗的油量差值，遍历数组如果发现当前油量为负的话，那么就从他的下一位开始,同时将临时统计的油量和进行清空操作</p>
<p>为什么发现curSum小于0要从下一位开始？</p>
<p>curSum统计的是从起始位置开始到达i这个位置的和，如果发现curSum 小于零，说明[0,i]这个区间内都不能作为起始点，因为无论你选择这段区间内的哪，到i这个位置的时候都会使curSum&lt;0，所以起始位置从i + 1开始</p>
<p>当curSum为负数的时候，如果后面还有更大的负数呢？</p>
<p>如果这个负数比较大的话，那么加到这个更大负数的时候curSum会小于零start的起始位置也会更新</p>
<p>如果数组够长那么前面数组和 + 当前消耗的油量大于0，那么起始位置不是从前面开始吗？</p>
<img src="/Users/satrol_/Desktop/NotepadImg/加油站.jpg" style="zoom:33%;" />



<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; gas.length;i++)&#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                result = i + <span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">题目入口</a></p>
<p>题意</p>
<p>每一个孩子至少一个糖果，相邻两个孩子，得分高的比得分低的多分配糖果，糖果的数量你随意，但是要求最终分配的糖果数量是最少的</p>
<p>思路</p>
<p>我们不应该同时考虑某个孩子两边的情况</p>
<p>首先将每一个孩子手中的糖果默认为-1</p>
<p>我们首先从左向右进行比较，如果发现右边的人分数高于左边，那么就在左边糖果的基础上加1操作</p>
<p>然后我们从右向左遍历，如果发现左边糖果数量高于右边的话，在右边糖果的基础上加1操作</p>
<p><code>由于要同时满足两种情况所以需要在两者中进行一次取值，即取两数组的最大值</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] Candy = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(Candy,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>])&#123;</span><br><span class="line">                Candy[i] = Candy[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>])&#123;</span><br><span class="line">                Candy[i] = Math.max(Candy[i + <span class="number">1</span>] + <span class="number">1</span>,Candy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(Candy).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">题目入口</a></p>
<p>题意</p>
<p>开始你是没有钱的，通过客户来获取钱，如果你能给客户找零，那么返回true否则返回false，只有5 15 20三张面额的钞票</p>
<p>如果客户给你5元，那么正好</p>
<p>如果客户给你10元，你需要返还给他5元</p>
<p>如果客户给你20元，你需要返还10 + 5 或者是5 + 5 + 5元</p>
<p>思路</p>
<p>我们定义三个变量用来统计我手中每一张钞票的数量</p>
<p>如果是5元，那么5的钞票数量 + 1</p>
<p>如果是10元，判断是否有5元，5的数量- 1，10的数量 + 1</p>
<p>如果是20元，先判断10有没有，如果没有再去考虑全是5的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>,ten = <span class="number">0</span>,twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : bills)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(five == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">20</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/submissions/">题目入口</a></p>
<p>思路</p>
<p>这道题和分发糖果那道题很像，本题可以按照k从小到大的顺序，或者是h从大到小的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]] </span><br></pre></td></tr></table></figure>



<p>按照k从小到大的顺序进行排列，身高按照从低到高</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>



<p>身高按照从低到高，k按照从低到高的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">4</span>]]</span><br></pre></td></tr></table></figure>

<p>正确的排序顺序是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>



<p>可以发现和第二种有联系，将每一次的值移动到k下标到位置，结果刚好贴合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">				</span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//LinkedList集合可以将值添加到指定下标下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i : people)&#123;</span><br><span class="line">            que.add(i[<span class="number">1</span>],i);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//集合转化成数组</span></span><br><span class="line">        <span class="keyword">return</span> que.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">题目入口</a></p>
<p>思路</p>
<p>当一个气球的左边界大于上一个气球的右边界的时候，说明两个气球的范围并没有重合，我们需要添加一个弓箭</p>
<p>如果发现重合的可能如何接着判断下一个是否也重合了呢？</p>
<p>我们需要更新我们的右端点，如果下一次的左端点没有上两次的右端点的最小值小的话说明并没有和上两次重合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        Arrays.sort(points, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = Math.min(points[i - <span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/submissions/">题目入口</a></p>
<p>本题和上面哪道题基本一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>],intervals[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">题目入口</a></p>
<p>思路</p>
<p>我们可以统计字符串中所有元素的最远出现的位置，遍历字符串，不断更新最大值，如果i到达了最大值的话，将其放入到集合当中，以同样的方式接着进行统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] hashArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//统计每个元素出现的最远位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            hashArr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            right = Math.max(hashArr[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>],right);</span><br><span class="line">            <span class="keyword">if</span>(i == right)&#123;</span><br><span class="line">                result.add(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">题目入口</a></p>
<p>思路</p>
<p>这道题还是一道重叠的题</p>
<p>但是这道题需要在重叠的同时进行数组合并操作</p>
<p>比较当前数组的第一位和上一个数组的第二位</p>
<ol>
<li><p>如果当前数组的第一位比上一个数组的第二位小的话，需要进行合并</p>
</li>
<li><p>否则的话，直接将数组传入结果集当中</p>
</li>
</ol>
<p>两个区域进行合并左右边界都是在不断发生变化的，我们可以分别定义左右区域</p>
<p>因为我们需要比较前一个区域，所以我们从1开始，leftArea，rightArea定义为刚开始的</p>
<p>无论是否合并，rightArea都会发生动态变化，leftArea只有在不进行合并的时候才会进行合并</p>
<p>因为我们先将数据添加到result中，然后再去更新左右区域，所以我们需要将最后的区域进行加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightArea</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftArea</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &gt; rightArea)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftArea,rightArea&#125;);</span><br><span class="line">                leftArea = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightArea = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rightArea = Math.max(rightArea,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftArea, rightArea&#125;);</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">题目入口</a></p>
<p>题意分析</p>
<p>本题要求获取一个小于等于输入值的最大元素，并且保证这个元素每一位都是单调递增的</p>
<p>思路</p>
<p>由于本题需要获取一个小于等于输入值的元素，例如300 —-&gt; 299 ，如果使用暴力的话，我们从输入的元素开始到0，接着对单调递增进行处理，时间复杂度是O(n * m)，很容易超时</p>
<p>如果要实现单调递增需要判断字符串当前位和前一位的大小</p>
<p>如果要获取小于等于输入元素的话，我们需要在i - 1位做减1操作，同时让第i位保证是最大数9</p>
<p>Coding time</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = (n + <span class="string">&quot;&quot;</span>).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; s[i - <span class="number">1</span>])&#123;</span><br><span class="line">                s[i - <span class="number">1</span>] = (<span class="type">char</span>)(s[i - <span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">                flag = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> flag;i &lt; s.length;i++)&#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> <span class="title class_">String</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">题目入口</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划理论"><a href="#动态规划理论" class="headerlink" title="动态规划理论"></a>动态规划理论</h3><p>动态规划常见题型</p>
<ul>
<li>背包问题</li>
<li>打家劫舍</li>
<li>股票问题</li>
<li>子序列问题</li>
</ul>
<p>动态规划五部曲</p>
<ul>
<li><p>理解dp数组的含义</p>
</li>
<li><p>递推公式</p>
</li>
<li><p>dp数组如何初始化</p>
</li>
<li><p>遍历顺序</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>动态规划代码书写顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化</span><br><span class="line"></span><br><span class="line">确定遍历顺序</span><br><span class="line"></span><br><span class="line">递推公式</span><br><span class="line"></span><br><span class="line">打印dp数组</span><br></pre></td></tr></table></figure>



<p><strong>顺序是这样的，但是我们还是按照五部曲进行分析，更加的直观</strong></p>
<h3 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">题目入口</a></p>
<p>特点：每一个数等于前两个数的和</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dp法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="comment">//递推公式</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">题目入口</a></p>
<p>本题按照递归五部曲来推导</p>
<p>dp数组代表了什么？</p>
<p><code>dp[i]代表每一阶需要走的步数</code></p>
<p>递推公式</p>
<blockquote>
<p>dp[1] &#x3D; 1，dp[2] &#x3D; 2，dp[3] &#x3D; 3，dp[4] &#x3D; 5</p>
<p>可以得到递推公式为dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p>
</blockquote>
<p>初始化</p>
<p><code>dp[1] = 1, dp[2] = 2</code></p>
<p>遍历顺序：从前至后进行遍历</p>
<p>最终输出结果</p>
<p>dp法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量替换数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">1</span>,c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">题目入口</a></p>
<p>题目分析</p>
<p>本题需要求的是到达顶部所需要消耗的最少体力值，并且初始位置下标可以是0或者是1，每一次只能跳1或者是2层台阶</p>
<p>思路</p>
<p>dp数组每一个元素代表的含义</p>
<p><code>dp[i]代表在从初始位置调到i消耗的体力</code></p>
<p>递推公式</p>
<blockquote>
<p>我们已知台阶一次只能跳一个或者是两个，所以我们不得不从当前台阶的前两个台阶计算，从i - 2计算dp[i - 2] + cost[i - 2]，从i - 1计算dp[i - 1] + cost[i - 1]，由于我们最终需要的是消耗的最少体力，所以我们需要在这两个中取得最小值Math.min()</p>
</blockquote>
<p>初始化</p>
<p>题目给出描述，初始位置下标可以是0或者是1，即初始化如下</p>
<p><code>dp[0] = 0,dp[1] = 1</code></p>
<p>遍历顺序，从前向后遍历</p>
<p>最后输出dp数组验证结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= len;i++)&#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">题目入口</a></p>
<p>题意</p>
<p>从左上角做到右下角有多少条路径,每次移动只能向右或者是向下</p>
<p>思路</p>
<p><code>dp[i][j]的含义?</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j]代表了走到这个点共有多少条路径</span><br></pre></td></tr></table></figure>

<p>递推公式</p>
<blockquote>
<p>我们如果想要从左上角的某点走到右下角点某点，最后一步无疑不是走到目标点的左边或者是走到目标点的上面，分别统计走到这两点的路径，加起来就是最终结果</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>我们可以对第一行和第一列进行初始化，因为二维数组上的所有点都是基于这两行进行推导的</p>
<p>初始化的值为1，因为移动只能向右或者是向下，所以到达这些点的路径只能为1</p>
<p>如何进行遍历？</p>
<p>从左往右遍历，从上往下遍历</p>
<p>打印数组验证结果</p>
<p>深搜写法(时间复杂度是2 ^ (m + n - 1) - 1，明显会发现超时了)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dfs(<span class="number">1</span>,<span class="number">1</span>,m,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; m || j &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == m || j == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(i + <span class="number">1</span>,j,m,n) + dfs(i,j + <span class="number">1</span>,m,n); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>dp写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="不同路径-II"><a href="#不同路径-II" class="headerlink" title="不同路径 II"></a>不同路径 II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">题目入口</a></p>
<p>题意</p>
<p>相比于不同路径I 多了一个障碍物，求有多少种路径</p>
<p>思路</p>
<p>dp数组的含义</p>
<p><code>dp数组代表了到达二维数组中某一个点的路径</code></p>
<p>递推公式</p>
<p><code>还是一样的，不过需要考虑遍历过程中是否出现过障碍物的情况</code></p>
<p>初始化</p>
<blockquote>
<p>可能在第一行或者是第一列中出现过障碍物的情况，障碍物后面的情况都无法遍历到，所以只需要我们对障碍物前面的每一个位置进行赋1操作</p>
</blockquote>
<p>遍历从左到右，从上到下</p>
<p>打印数组验证结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>;j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">题目入口</a></p>
<p>题意</p>
<p>本题要求拆分一个整数，使得最终的乘积是最大的</p>
<p>思路</p>
<p>dp[i]数组含义</p>
<p>dp[i]代表对i进行拆分得到的最大乘积</p>
<p>递推公式</p>
<p>我们需要考虑两个数乘积，和多个数乘积在其中取最大值</p>
<p>我们需要固定一个值，接着拆分另一个值</p>
<p>这里面不拆分前面的值是因为后面的值拆分后已经包含了前面的值拆分的情况</p>
<p>两个值的乘积：j * (i - j)</p>
<p>多个值的乘积：j * dp[i - j]</p>
<p>获取乘积的最大值，这里也需要比较dp[i]的值，因为dp[i]的值也是在不断变大的</p>
<p>初始化</p>
<p>初始化0 1 都是没有意义的，因为0 1最大的乘积是0，所以我们应该从2开始进行初始化</p>
<p>遍历顺序</p>
<p>固然是从前向后进行遍历，j是依赖于i的值，需要现有i，再有j，正常来说，j是固定值，不能超过i，j从1开始遍历到达i - 1，但是这其中会出现很多重复的情况，所以我们只需要将j的上限设置为i - j即可</p>
<p>打印dp数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i - j;j++)&#123;</span><br><span class="line">                dp[i] = Math.max(Math.max(j * (i - j),j * dp[i - j]),dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">题目入口</a></p>
<p>思路</p>
<p>关于二叉搜索树是什么，如果还不清楚可以回到二叉树章节里去看一下</p>
<p>这道题我们可以试着寻找猫腻</p>
<p>当n &#x3D; 0的时候，什么树他都是算一种情况</p>
<p>当n &#x3D; 1的时候，只有一种情况</p>
<p>当n &#x3D; 2的时候，有两种情况</p>
<p>当n &#x3D; 3的时候，有五种情况</p>
<p>以上三种数据之间是没有发生规律的</p>
<p>但是可以试着去查看n &#x3D; 3二叉树的结构，会发现三种情况</p>
<p>当1作为顶点的时候，左边为空，右边有两个元素</p>
<p>当2作为顶点的时候，左边有一个元素，右边也有一个元素</p>
<p>当3作为顶点，左边有两个元素，右边没有元素</p>
<p>有两个元素的二叉树是dp[2]</p>
<p>有一个元素的二叉树是dp[1]</p>
<p>dp[3] &#x3D; dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</p>
<p>在这里面差不多找到了递推公式了</p>
<p>明确dp数组的含义</p>
<p>dp[i]代表着i个元素构成的二叉搜索树的个数</p>
<p>递推公式</p>
<p>刚才得到的递推公式的模版：dp[左节点出现元素的数量] * dp[右节点出现的元素的数量]</p>
<p>所以递推公式为: dp[i] +&#x3D; dp[j - 1] + dp[i - j]</p>
<p>初始化</p>
<p>dp[0] &#x3D; 1</p>
<p>遍历顺序</p>
<p>本题需要将每一个i作为头节点，接着去用j来进行遍历</p>
<p>打印dp数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line">                dp[i] += dp[j - <span class="number">1</span>] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="背包问题理论篇"><a href="#背包问题理论篇" class="headerlink" title="背包问题理论篇"></a>背包问题理论篇</h2><p><strong>01背包</strong></p>
<p>什么是01背包？</p>
<p>有一堆物品，每一个物品只有一个，它有自己的重量和价值，现在给一个容纳指定重量的背包，问这个背包能装有的最大价值是多少？</p>
<h3 id="二维数组实现01背包"><a href="#二维数组实现01背包" class="headerlink" title="二维数组实现01背包"></a>二维数组实现01背包</h3><p>暴力求解</p>
<p>我们可以标记物品的选中状态结合回溯来完成</p>
<p>确定dp数组的含义</p>
<p><code>dp[i][j]代表在[0,i]区间内，任选物品，放入容量为j的背包中的最大价值</code></p>
<p>递推公式</p>
<p>想要推出<code>dp[i][j]</code>需要考虑两种情况</p>
<p>如果不放物品i的话：<code>dp[i - 1][j]</code>，说明背包无法容纳该物品，那么获取最大价值中不包含当前i这个物品，即i - 1</p>
<p>放入物品i：<code>dp[i - 1][j - weight[i]] + value[i]</code> 相当于是将物品i放入到背包后，获取i - 1的最大价值，同时背包需要减去i的重量，最终加上下标i对应的价值</p>
<p><code>dp[i][j]</code>是在以上两种情况中取得的最大价值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>我们需要初始化哪些位置？</p>
<p>根据递推表达式，我们会发现下面的元素都是通过上面的元素或者是左上角的元素通过运算得来的</p>
<p>所以我们需要对左边一列和最上面一行进行初始化操作</p>
<p>第一列</p>
<p>对于背包容量为0的那一列我们需要将其全部初始化为0</p>
<p>第一行</p>
<p>当我们发现背包可以容纳weight[0] 我们需要将其初始化为weight[0]</p>
<p>如果发现背包无法容纳的话，初始化为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagweight;j++)&#123;</span><br><span class="line">  dp[j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果发现背包可以容纳的话，那么就将<code>dp[i][j]</code> &#x3D; value[0]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>];j &lt;= bagweight;j++)&#123;</span><br><span class="line">		dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着初始化其他值，初始化什么呢？</p>
<p>根据递推公式我们会发现<code>dp[i][j]</code>是由左上角的值推导而来，也就是最开始初始化的数据推导而来，初始化什么都会被覆盖，但是这里面我们还是尽量选择初始化为0，因为有可能第一行中背包无法容纳物体的重量，那么最大价值就是0</p>
<p>遍历顺序</p>
<p>我们都知道背包类问题都是由两层for循环组成的，那么背包的重量和物品呢？</p>
<p>其实都可以，因为<code>dp[i][j]</code>的值是由左上方的数据推导而来，顺序不同，但是结果相同</p>
<p>先遍历物品，接着遍历背包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; weigth.length;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagweight;j++)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(weight[i] &gt; j) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    	<span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - weight[i]] + value[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先遍历背包，再遍历物品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; weight.length; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] weight = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] value = &#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight,<span class="type">int</span>[] value,<span class="type">int</span> bagSize)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[weight.length][bagSize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[<span class="number">0</span>];j &lt;= bagSize;j++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; weight.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= bagSize;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; weight[i]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; weight.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagSize;j++)&#123;</span><br><span class="line">                System.out.print(dp[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="一维数组实现背包"><a href="#一维数组实现背包" class="headerlink" title="一维数组实现背包"></a>一维数组实现背包</h3><p>dp数组的含义</p>
<p>dp[j] 代表将物品放入到容量为j的背包的最大价值</p>
<p>递推公式</p>
<p>不放入物品 :<code>dp[j]</code>相当于将上一层的数据向下进行一次拷贝</p>
<p>放入物品:  <code>dp[j - weight[j]] + value[j]</code></p>
<p><code>dp[j]</code>同理是在以上两种情况中寻找最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[j] = Math.max(dp[j],dp[j - weight[j]]+ value[j]);</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>当背包容量为0的时候，dp[j]初始化为0即可</p>
<p>当背包容量不为0的时候，根据递推公式需要再dp[j] 和 后面的表达式之间取得最大值，并且表达式所能得到的值一般都是正整数，所以我们将剩余的dp[j]初始化为0即可</p>
<p>遍历顺序</p>
<p>先遍历物品，再遍历背包，方向不能反，并且遍历背包的时候需要倒序遍历？</p>
<p>为什么一定要倒序遍历</p>
<p><code>dp[1] = dp[1 - 1] + 15 = 15</code></p>
<p><code>dp[2] = dp[2 - 1] + 15 = 30</code></p>
<p>dp[2]计算了两次，明显是不对的</p>
<p>如果反过来进行遍历的话</p>
<p><code>dp[2] = dp[2 - 1] + 15 = 15</code></p>
<p><code>dp[1] = dp[1 - 1] + 15 = 15</code></p>
<p>起始本质上还是因为背包容量多的是在先前计算背包容量少的基础上进行计算的</p>
<p>它和二维数组唯一的不同点是它的数据需要用到先前统计好的最大价值</p>
<p>为什么一定要先遍历物品，再遍历背包？</p>
<p>如果先遍历背包，再遍历物品dp[i]中只会放入一个物品</p>
<p>整体代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] weight = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] value = &#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeightBagProblem</span><span class="params">(<span class="type">int</span>[] weight,<span class="type">int</span>[] value,<span class="type">int</span> bagSize)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; weight.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagSize;j &gt;= weight[i];j--)&#123;</span><br><span class="line">               dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= bagSize;j++)&#123;</span><br><span class="line">           System.out.print(dp[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">题目入口</a></p>
<p>思路</p>
<p>根据题目描述，数组中的每一个元素只能使用一次，所以我们可以使用01背包来解决</p>
<p>明确dp数组的含义</p>
<p>dp[i]代表了当背包容量为i的时候所能容纳的最大价值</p>
<p>在本题中每一个元素的值既代表了容量也代表了价值</p>
<p>判断满足条件表达式</p>
<p>dp[target] &#x3D; target</p>
<p>递推表达式</p>
<p><code>dp[i] = Math.max(dp[j],dp[j - weight[i]] + value[i])</code></p>
<p>对于本题</p>
<p><code>dp[i] = Math.max(dp[j],dp[j - number[i]] + number[i])</code></p>
<p>初始化</p>
<p><code>dp[0] = 0</code></p>
<p>其余全部初始化为0，因为dp[i]是通过取最大值获取的</p>
<p>遍历顺序</p>
<p>先遍历物品，再遍历背包</p>
<p>在本题中数组中每一个元素是物品，target就是背包</p>
<p>最后需要判断dp[target] 和target的值是否相等即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">题目入口</a></p>
<p>根据题目描述，每一块石头只能取一次，想要将碰撞后石头的和达到最小，很明显就是一道01背包问题</p>
<p>思路</p>
<p>这道题的关键起始就是统计总和将总和划分为一半，分别用数组中的数据凑成一半的值即可，和上一题的本质是一样的</p>
<p>明确dp数组的含义</p>
<p>本题石头的重量实质上就是价值</p>
<p>dp[i]代表了背包容量为j所容纳的最大价值，即最大重量</p>
<p>递推公式</p>
<p>正常来说01背包问题的递推公式为</p>
<p><code>dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])</code></p>
<p>但是这道题里面重量和价值是等价的，所以应该这么书写</p>
<p><code>dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i])</code></p>
<p>初始化</p>
<p>当背包容量为0的时候，dp[0] &#x3D; 0</p>
<p>其余的情况一律初始化为0，因为要取Math.max</p>
<p>dp数组大小应该初始化为多少？</p>
<p>根据题目描述</p>
<p>Stone数组的长度最大是30，每一块石头的最大重量为100</p>
<p>所以我们定义dp数组长度应该是dp[3010]</p>
<p>遍历顺序</p>
<p>和一维数组实现01背包问题一样</p>
<p>先遍历物品，再遍历背包，背包倒序进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3010</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : stones)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target;j &gt;= stones[i];j--)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum - dp[target] - dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">题目入口</a></p>
<p>思路</p>
<p>我们可以将数组分为正数的集合(left)和负数(right)的集合</p>
<p><code>left + right = sum left - right = target</code></p>
<p>可以得出结果</p>
<p><code>left = (target + sum) / 2</code></p>
<p>我们只需要计算正数集合和等于left的结果，剩余的就是负数的集合</p>
<p>如果target + sum 和 &#x2F; 2无法整除的话直接返回0</p>
<p>例如：sum &#x3D; 5 ，target &#x3D; 2</p>
<p>总和为5 的集合分为1 4 ，2 3，3 2，4 1</p>
<p>发现无法凑成target的值</p>
<p>现在left已经固定了，我们想要通过数组来凑成left</p>
<p>相当于是凑成背包容量为left的方法有多少种</p>
<p>dp数组的含义</p>
<p>dp[i]代表装满这个背包，有多少种方法</p>
<p>递推公式</p>
<p>我们可以通过nums[i]来推出dp数组每一项的值</p>
<p>dp[i] &#x3D; dp[i - nums[i]]</p>
<p>假如背包的空间为5，数组为[1,1,1,1,1]</p>
<p>如果有1个物品的话，我们有4种方法来凑成该背包</p>
<p>如果有2个物品的话，我们有3种方法来凑成背包</p>
<p>如果有3个物品的话，我们有2种方法来凑成背包</p>
<p>如果有4个物品的话，我们有1种方法来凑成背包</p>
<p>如果有5个物品的话，我们就有0种方法来凑成背包</p>
<p>为什么有n种物品，就会有dp[num - n]中方法呢？</p>
<p>因为当你放入n个物品的时候，此时背包容量相当于是减去了n，dp[n]的含义是填满背包容量为n所包含的方法</p>
<p>所以<code>dp[5] = dp[4] + dp[3] + dp[2] + dp[1] + dp[0]种方法</code></p>
<p>通过以上描述我们最终可以得到一个组合公式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>本题中dp[0] 需要初始化为1</p>
<p>为什么要初始化为1呢？</p>
<p>因为后面的dp数组都是由dp[0]推导而来的</p>
<p>也可以通过这个例子来证明</p>
<p>nums &#x3D; [0] target &#x3D; 0 方法不就包含一种</p>
<p>非零下标初始化什么？</p>
<p>由于上面要做累加操作，我们应该将它初始化为0</p>
<p>遍历顺序</p>
<p>先遍历物品，再遍历背包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum += num;</span><br><span class="line">				</span><br><span class="line">        <span class="keyword">if</span>((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//如果nums = [100,100] target = 400 这种target值如果和sum相差过大的话需要另行判断</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(sum) &lt; Math.abs(target)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">      	<span class="comment">//如果left出现了负值，很明显dp数组就无法创建了</span></span><br><span class="line">        <span class="keyword">if</span>(left &lt; <span class="number">0</span>) left = -left;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[left + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;j &gt;= nums[i];j--)&#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">题目入口</a></p>
<p>思路</p>
<p>本题要求在给出的数组中找到包含m个1和n个0，所构成的最大长度的子集</p>
<p>明确dp数组的含义</p>
<p>由于这里包含了两个维度，所以定义dp数组我们应该定义成二维的</p>
<p><code>dp[i][j]</code>代表了构建出i个0和j个1所构成的最大长度子集</p>
<p>递推公式</p>
<p>经典01背包问题中递推公式</p>
<p><code>dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i])</code></p>
<p>本题中是如何推导出递推公式的？</p>
<p>数组中每一个自己中都有0和1的数量，如果我们想要获取本数据接着向下进行装填背包的话</p>
<p><code>dp[i][j] = dp[i - x][j - y] + 1</code></p>
<p>为什么要加上一呢？</p>
<p>这里相当于是采纳了本次子集，所以加1</p>
<p>我们需要在最终取得子集的最大长度</p>
<p>所以我们需要对每一次操作取最大值</p>
<p><code>dp[i][j] = Math.max(dp[i][j],dp[i - x][j - y] + 1)</code></p>
<p>初始化</p>
<p><code>dp[0][0]相当于不往背包里里面装东西，即dp[0][0] = 0</code></p>
<p>其余的可能应该初始化成什么呢？</p>
<p>由于每一次<code>dp[i][j]</code>都是取最大值的操作，所以我们将其初始化为0</p>
<p>遍历顺序</p>
<p>遍历数组的时候我们需要统计每一个子集0的数量，1的数量即遍历物品</p>
<p>接着去倒序遍历背包的容量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>,y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span>) x++;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;1&#x27;</span>) y++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m;i &gt;= x;i--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n;j &gt;= y;j--)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[i - x][j - y] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m][n]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="完全背包理论基础"><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h3><p>完全背包和01背包的区别</p>
<blockquote>
<p>完全背包一件物品可以使用无限次</p>
</blockquote>
<p>完全背包的遍历顺序</p>
<p>完全背包两层for循环的遍历顺序都是正序的</p>
<p>先遍历物品还是先遍历背包都是可以的</p>
<p>先遍历物品，后遍历背包</p>
<p><code>相当于一组数据是横行进行填充的，从左到右进行填充数据</code></p>
<p>先遍历背包，后遍历物品</p>
<p><code>相当于一组数据是竖向进行填充的，从上到下进行填充数据</code></p>
<h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/">题目入口</a></p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p>装满背包amount，总共有多少种方法</p>
<p>递推公式</p>
<p>和之前目标和统计方法个数一样</p>
<p><code>dp[j] += dp[j - nums[i]]</code></p>
<p>初始化</p>
<p>当背包容量为0的时候为了方便后面数据的变动这里面初始为1是比较合适的</p>
<p><code>dp[0] = 1</code></p>
<p>其余数据初始化为0即可</p>
<p>遍历顺序</p>
<p>本题如果两种遍历顺序得到的结果是截然不同的</p>
<p>如果先遍历物品，接着去遍历背包</p>
<p>我们是按照物品的顺序去放入的</p>
<p>如果是先遍历背包，接着去遍历物品</p>
<p>每遍历一个背包，都将重复的数据进行放入，就会出现全排列的现象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和-Ⅳ"><a href="#组合总和-Ⅳ" class="headerlink" title="组合总和 Ⅳ"></a>组合总和 Ⅳ</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/">题目入口</a></p>
<p>思路</p>
<p>本题每一个物品都是可以重复使用的，很明显这是一道完全背包的题</p>
<p>和上一题不一样，他需要找到的是和满足target的所有排列</p>
<p>先遍历背包再遍历物品求的就是排列</p>
<p>思路和上一道一样遍历的顺序发生了变化，这样就需要我们判断当背包的容量大于物品，才能进行递推语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= target;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= nums[j])&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="爬楼梯-1"><a href="#爬楼梯-1" class="headerlink" title="爬楼梯"></a>爬楼梯</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">题目入口</a></p>
<p>学完完全背包后，会发现这道题起始本质上就是一道求完全背包排列的问题</p>
<p>我们可以用完全背包再写一遍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= nums[j])&#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">题目入口</a></p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p>dp[j]在本题中代表装满背包j所需要的最少物品的数量</p>
<p>递推公式</p>
<p>装好一个物品后，剩余背包容量所装的最少物品数量</p>
<p><code>dp[j] = dp[j - nums[i]]</code></p>
<p>每次装入一个物品都需要进行计数</p>
<p><code>dp[j] = dp[j - nums[i]] + 1</code></p>
<p>目标要求取的物品的最小值</p>
<p><code>Math.min(dp[j],dp[j - nums[i]] + 1)</code></p>
<p>初始化</p>
<p>对于本题如果amount &#x3D; 0，说明我们不需要给硬币，结果是0</p>
<p><code>dp[0] = 0</code></p>
<p>对于非零下标我们应该初始化成什么呢？</p>
<p>由于本题要取最小值，所以我们对于其余的每一个数据应该初始化成整数的最大值</p>
<p>遍历顺序</p>
<p>我们应该是先遍历物品还是先遍历背包呢？</p>
<p>针对于完全背包问题</p>
<p>先遍历物品，后遍历背包求的是组合数，先遍历背包，后遍历物品求的是排列数</p>
<p>不管是组合和排列，和这道求最小所需的物品数量没有任何关系，所以都可以进行选择</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; dp.length;i++) dp[i] = max;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i];j &lt;= amount;j++)&#123;</span><br><span class="line">              	<span class="comment">//防止dp[j - coins[i]] + 1溢出</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j - coins[i]] != max)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j],dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">题目入口</a></p>
<p>思路</p>
<p>本题和上一道题一样都是求物品的最少数量，只需要在原来的基础上稍加修改即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; dp.length;i++) dp[i] = max;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i * i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i;j &lt;= n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j - i * i] != max)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j],dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n] == max ? -<span class="number">1</span> : dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单词拆分"><a href="#单词拆分" class="headerlink" title="单词拆分"></a>单词拆分</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">题目入口</a></p>
<p>思路</p>
<p>确定dp数组的含义</p>
<p>本题要求判断一个字符串是否能由字符串数组中的元素组成</p>
<p><code>dp[i]</code>代表的含义就是当字符串长度为i的时候，是否能由字符数组组成</p>
<p>最终返回的结果也就是dp[字符串的长度]</p>
<p>递推公式</p>
<p>如果发现<code>[i,j]</code>这个区间段为true并且dp[j]同时也是true的话，返回结果dp[i]为true</p>
<p>初始化</p>
<p>根据题目描述字符串的长度至少为1，那么我们dp[0]其实初始化什么都是可以的</p>
<p>如果dp[0] 初始化为false的话，根据递推公式，那么后面的值就都是false了，显然这是不行的</p>
<p>所以我们dp[0]默认初始化为0</p>
<p>由于其余的状态都是未知的，所以我们初始化为false，由递推公式进行更新</p>
<p>遍历顺序</p>
<p>本题是先遍历背包还是先遍历物品呢？</p>
<p><code>s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</code></p>
<p>根据题目给出的案例来判断</p>
<p>s 是由 wordDict 121的顺序拼接而成的，顺序并不是固定的，所以本题需要的是排列数</p>
<p>即先遍历背包再遍历物品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">      	<span class="comment">//初始化操作</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,<span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//i用来遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">          	<span class="comment">//j用来遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">              	<span class="comment">//递推公式</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(j,i);</span><br><span class="line">                <span class="keyword">if</span>(wordDict.contains(str) &amp;&amp; dp[j])&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多重背包理论基础"><a href="#多重背包理论基础" class="headerlink" title="多重背包理论基础"></a>多重背包理论基础</h3><p><strong>多重背包和01背包是十分相似的，多重背包每件物品都有自己的最大数量，最终满足各式各样的条件</strong></p>
<p>相当于在01背包的基础上，多添加一层for循环用来遍历物品的数量</p>
<h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><h3 id="打家劫舍-1"><a href="#打家劫舍-1" class="headerlink" title="打家劫舍"></a>打家劫舍</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">题目入口</a></p>
<p>题意</p>
<p>给出一堆房间，偷金币的规则是不能同时偷相邻房间的金币</p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p>dp[i]代表，包括下标i之前能偷的最大钱币的数量</p>
<p>最终返回的结果是dp[nums.length - 1]</p>
<p>递推公式</p>
<p>一个房间需要考虑两种状态</p>
<p>偷<code>i</code></p>
<p>首先获取到的金币的数量为<code>nums[i]</code></p>
<p>还需要加上之前偷取的最大金币的数量</p>
<p><code>nums[i] + dp[i - 2]</code></p>
<p><code>i - 2</code>是因为相邻房间的金币是无法偷取的</p>
<p>不偷<code>i</code></p>
<p><code>dp[i - 1]</code></p>
<p>最终要获取的是最大金币的数量</p>
<p><code>Math.max(dp[i - 1],nums[i] + dp[i - 2])</code></p>
<p>初始化</p>
<p>如果只有一个房间的话，那么一定要偷</p>
<p><code>dp[0] = nums[0]</code></p>
<p>如果有两个房间的话，那么需要偷其中的最大值</p>
<p><code>dp[1] = Math.max(nums[0],nums[1])</code></p>
<p>遍历顺序</p>
<p>从前到后进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; len;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(nums[i] + dp[i - <span class="number">2</span>],dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/">题目入口</a></p>
<p>题目描述</p>
<p>相比于打家劫舍I，唯一的区别就是数组连成环，规则还是一样的</p>
<p>思路</p>
<p>由于本题中首尾连成环，如果想要防止首尾相邻的情况，我们可以分为一下三种情况</p>
<p>不考虑首尾元素</p>
<p>考虑首元素，不考虑尾元素</p>
<p>考虑尾元素，不考虑首元素</p>
<p>不过后两种情况其实已经考虑情况1了</p>
<p>最终在后两种情况中取最大值进行返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> robFromTo(<span class="number">0</span>,nums.length - <span class="number">2</span>,nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> robFromTo(<span class="number">1</span>,nums.length - <span class="number">1</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> Math.max(result1,result2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robFromTo</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        </span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start],nums[start + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>;i &lt;= end;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>],dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a>打家劫舍 III</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">题目入口</a></p>
<p>题意</p>
<p>本题相比于之前的题，唯一的区别就是在二叉树中偷取钱币</p>
<p>思路</p>
<p>明确dp数组的的含义</p>
<p>每一个dp数组都有两个状态，分别是偷和不偷</p>
<p>所以dp数组应该定义成一个长度为2的一个数组</p>
<p><code>dp[0]</code>代表的含义是不偷</p>
<p><code>dp[1]</code> 代表的含义是偷</p>
<p>函数定义</p>
<p>终止条件</p>
<p><code>如果遍历到当前节点为空节点直接返回</code></p>
<p>遍历顺序</p>
<p>本题使用的遍历顺序是后序遍历</p>
<p>单层递归逻辑</p>
<p>偷当前节点，那么说明左右节点不能偷</p>
<p><code>val1 = cur.val + cur.left[0] + cur.right[0]</code></p>
<p>不偷当前节点，左右节点可以偷也可以不偷，右节点同理</p>
<p><code>val2 = Math.max(root.left[0],root.left[1]) + Math.max(root.right[0],root.right[1])</code></p>
<p>暴力搜索(超时)</p>
<p>因为我们刚开始就计算了一次孙子的情况，但是我们在第二种情况中先计算了儿子接着又计算了孙子，这种情况明显重复了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="comment">//偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) val1 = val1 + rob(root.left.left) + rob(root.left.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) val1 = val1 + rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        <span class="comment">//不偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(val1,val2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Map标记重复计算的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Map&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> robAction(root,map);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robAction</span><span class="params">(TreeNode root,Map&lt;TreeNode,Integer&gt; momo)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.val; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(momo.containsKey(root))&#123;</span><br><span class="line">            <span class="keyword">return</span> momo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="literal">null</span>) val1 = val1 + robAction(root.left.left,momo) + robAction(root.left.right,momo);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="literal">null</span>) val1 = val1 + robAction(root.right.left,momo) + robAction(root.right.right,momo); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//不偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> robAction(root.right,momo) + robAction(root.left,momo);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(val1,val2);</span><br><span class="line"></span><br><span class="line">        momo.put(root,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = robAction(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] robAction(TreeNode root)&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] leftArr = robAction(root.left);</span><br><span class="line">        <span class="type">int</span>[] rightArr = robAction(root.right);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        res[<span class="number">0</span>] = Math.max(leftArr[<span class="number">0</span>],leftArr[<span class="number">1</span>]) + Math.max(rightArr[<span class="number">0</span>],rightArr[<span class="number">1</span>]);</span><br><span class="line">        res[<span class="number">1</span>] = root.val + leftArr[<span class="number">0</span>] + rightArr[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="买卖股票"><a href="#买卖股票" class="headerlink" title="买卖股票"></a>买卖股票</h2><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">题目入口</a></p>
<p>题意</p>
<p>要求在某一天买入，在后面卖出，要求赚取最大的数额</p>
<p>思路</p>
<p>本题可以使用暴力解法，枚举出两天做差后最大的数额</p>
<p>还可以使用贪心的思路，获取到前面的最小值和后面的最大值</p>
<p>但事实上，买卖股票是动态规划的经典题目</p>
<p>动态规划五部曲</p>
<p>明确dp数组的含义</p>
<p>dp数组主要是用来表示某一天股票持有的状态</p>
<p>我们可以使用二维数组来进行标记</p>
<p><code>dp[i][0]代表持有该股票最大金额，dp[i][1]代表不持有该股票的最大金额</code></p>
<p>这里面需要理清一个概念？</p>
<p>持有股票并不代表当天买入该股票，不持有股票也并不代表当天卖出该股票</p>
<p>递推公式</p>
<p>持有股票是包含两种状态的</p>
<p>或者是之前就保持着持有的状态</p>
<p><code>dp[i - 1][0] </code></p>
<p>当天买入</p>
<p><code>- price[i]</code></p>
<p>最终需要在这两种状态下获取最大值</p>
<p><code>dp[i][0] = Math.max(dp[i][0],-price[i])</code></p>
<p>不持有股票也是同样的原理</p>
<p>之前不持有股票</p>
<p><code>dp[i - 1][1]</code></p>
<p>当天把股票卖了</p>
<p><code>dp[i - 1][0] + price[i]</code></p>
<p>最终取值</p>
<p><code>Math.max(dp[i - 1][1],dp[i - 1][0] + price[i])</code></p>
<p>初始化</p>
<p>根据递推公式可以得出</p>
<p>基础是<code>dp[0][0]和dp[0][1]</code></p>
<p><code>dp[0][0]</code>代表的是第零天持有股票，说明第0天一定买入股票了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[0][0] -= price[0];</span><br></pre></td></tr></table></figure>

<p><code>dp[0][1]</code>代表的是第零天不持有股票，那么钱数就是0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[0][1] = 0;</span><br></pre></td></tr></table></figure>



<p>遍历顺序</p>
<p>从前向后遍历</p>
<p>暴力做法 <code>超时</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; prices.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; prices.length;j++)&#123;</span><br><span class="line">                res = Math.max(prices[j] - prices[i],res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(res &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>贪心做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            low = Math.min(prices[i],low);</span><br><span class="line">            max = Math.max(prices[i] - low,max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>dp做法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp数组的含义：第n天获取的最大利润</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//持有股票</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            <span class="comment">//不持有股票</span></span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机II-1"><a href="#买卖股票的最佳时机II-1" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">题目入口</a></p>
<p>题意</p>
<p>本题相比于上一道题，股票可以买卖多次</p>
<p>思路</p>
<p>dp数组的含义</p>
<p><code>dp[i][0]</code>代表在第i天持有股票的最大利润</p>
<p><code>dp[i][1]</code>代表在第i天不持有股票的最大利润</p>
<p>递推公式</p>
<p>持有股票</p>
<p>先前就持有股票</p>
<p><code>dp[i - 1][0]</code></p>
<p>在第i天买入股票，先前可能已经买卖多次</p>
<p><code>dp[i - 1][1] - price[i]</code></p>
<p>最终取得利润的最大值</p>
<p><code>Math.max(dp[i - 1][0],dp[i - 1][1] - price[i])</code></p>
<p>本题唯一的区别</p>
<p>其余的都是一样的</p>
<p>本题主要使用动态规划来解决股票一系列问题，当然贪心也行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">题目入口</a></p>
<p>题意</p>
<p>股票至多买卖两次</p>
<p>思路</p>
<p>动态规划五部曲</p>
<p>明确dp数组的含义</p>
<p>由于本题股票至多买卖两次，所以我们需要新添加一种状态</p>
<p><code>dp[i][0]</code> 不操作</p>
<p><code>dp[i][1]</code> 第一次持有股票</p>
<p><code>dp[i][2]</code> 第一次不持有股票</p>
<p><code>dp[i][3]</code> 第二次持有股票</p>
<p><code>dp[i][4]</code> 第二次不持有股票</p>
<p>递推公式</p>
<p><code>dp[i][0] = dp[i - 1][0]</code></p>
<p><code>dp[i][1] = Math.max(dp[i - 1][1],dp[i - 1][0] - price[i])</code></p>
<p><code>dp[i][2] = Math.max(dp[i - 1][2],dp[i - 1][1] + price[i])</code></p>
<p><code>dp[i][3] = Math.max(dp[i - 1][3],dp[i - 1][2] - price[i])</code></p>
<p><code>dp[i][4] = Math.max(dp[i - 1][4],dp[i - 1][3] + price[i]) </code></p>
<p>初始化操作</p>
<p><code>dp[0][0] = 0</code></p>
<p><code>dp[0][1] = -price[0]</code></p>
<p><code>dp[0][2] = 0</code></p>
<p><code>dp[0][3] = -price[0]</code></p>
<p><code>dp[0][4] = 0</code></p>
<p>遍历顺序</p>
<p>从前向后进行遍历</p>
<p>最终取值：<code>dp[price.length - 1][4]</code></p>
<p>第二次卖出后的结果中已经包含了第一次卖出的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>],dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>],dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">题目入口</a></p>
<p>题意</p>
<p>进行k次买卖</p>
<p>思路</p>
<p>定义dp数组</p>
<p>根据上面的题分析，当我们进行两次买卖的时候最终dp到达的是4</p>
<p>所以我们dp数组的大小是2 * k + 1</p>
<p>递推公式</p>
<p>由于需要进行k次买卖，于是就不能像上一道题一样将每一种状态都罗列出来</p>
<p>我们可以通过循环为每一次的买卖赋值</p>
<p>大体模版(其余参考至多两次买卖)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">2</span> * k;j += <span class="number">2</span>)&#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>根据上一道题可以发现</p>
<p>当下标为奇数项的时候结果为<code>-price[0]</code></p>
<p>下标为偶数项的时候结果为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;k &lt; <span class="number">2</span> * k;k += <span class="number">2</span>)&#123;</span><br><span class="line">	 dp[<span class="number">0</span>][k] = -price[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历顺序</p>
<p>从前向后进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; <span class="number">2</span> * k;i += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; <span class="number">2</span> * k;j += <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>],dp[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>],dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">题目入口</a></p>
<p>题意</p>
<p>卖出股票后无法在第二天进行买入操作</p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p><code>dp[i][0]</code> 持有股票</p>
<p>将不持有股票的状态进行拆分</p>
<p><code>dp[i][1]</code> 保持卖出股票状态</p>
<p><code>dp[i][2]</code>  卖出股票</p>
<p><code>dp[i][3]</code> 冷冻期</p>
<p>递推公式</p>
<hr>
<p><code>dp[i][0]</code></p>
<p>延续前一天的状态</p>
<p><code>dp[i][0] = dp[i - 1][0]</code></p>
<p>在冷冻期过后买入股票</p>
<p><code>dp[i][0] = dp[i - 1][3] - price[i]</code></p>
<p>保持卖出股票的状态时买入股票</p>
<p><code>dp[i][0] = dp[i - 1][1] - price[i]</code></p>
<p>最终在三种情况中取最大值</p>
<p><code>dp[i][0] = Math.max(dp[i - 1][0],Math.max(dp[i - 1][3] - price[i],dp[i - 1][1] - price[i]))</code></p>
<hr>
<p><code>dp[i][1]</code></p>
<p>保持卖出股票的状态分为两种</p>
<p>继承先前的状态</p>
<p><code>dp[i][1] = dp[i - 1][1]</code></p>
<p>冷冻期后的一天</p>
<p><code>dp[i][1] = dp[i - 1][3]</code></p>
<p>最终取最大值</p>
<hr>
<p><code>dp[i][2]</code></p>
<p>前一天处于持有股票的状态，当天将股s票进行卖出</p>
<p><code>dp[i - 1][0] + price[i]</code></p>
<hr>
<p><code>dp[i][3]</code></p>
<p>前一天一定是卖出股票的状态</p>
<p><code>dp[i - 1][2]</code></p>
<p>初始化</p>
<p><code>dp[0][0] = -price[0]</code></p>
<p><code>dp[0][1] = 0</code></p>
<p><code>dp[0][2] = 0</code></p>
<p><code>dp[0][3] = 0</code></p>
<p>遍历顺序</p>
<p>从前向后进行遍历</p>
<p>最终取值：在卖出的三个状态中取最大值</p>
<p><code>Math.max(dp[price.length - 1][1],dp[price.length - 1][2],dp[price.length - 1][3])</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bad case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// dp公式</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">题目入口</a></p>
<p>思路</p>
<p>每进行一次买卖操作就需要减去手续费用</p>
<p>可以进行无限次交易</p>
<p>我们在每一次卖东西的时候需要减去手续费用即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">题目入口</a></p>
<p>思路</p>
<p>本题可以通过动态规划来解决</p>
<p>明确dp数组的含义</p>
<p>dp[i]代表的是以i为结尾，最长子序列的长度</p>
<p>递推公式</p>
<p>假设j 为i前面的点，并且nums[i] &gt; nums[j]，我们可以得到dp[i] 和dp[j]之间的关系</p>
<p><code>dp[i] = dp[j] + 1</code></p>
<p>不过最终我们要获取的答案是最长的子序列，需要将前面的所有情况取最大值</p>
<p><code>dp[i] = Math.max(dp[i],dp[j] + 1)</code></p>
<p>初始化</p>
<p>每一个元素都算是一个递增子序列，所以所有元素都初始化为1</p>
<p>遍历顺序</p>
<p>本题要求得到的是最长递增子序列，那么一定是从前到后的</p>
<p>最终取值为什么？</p>
<p>由于我们无法确定nums中哪一个元素是最大的元素，无法与dp数组的下标对应，所以我们需要遍历dp数组求得最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] + <span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : dp) res = Math.max(res,i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最长连续递增序列"><a href="#最长连续递增序列" class="headerlink" title="最长连续递增序列"></a>最长连续递增序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">题目入口</a></p>
<p>思路</p>
<p>本题相比于上一道题来说，需要保证最长的递增序列连续</p>
<p>dp数组的含义</p>
<p>dp[i]代表以i结尾，最长的递增子序列</p>
<p>递推公式</p>
<p>由于两个递增元素之间是连续的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n[i] &gt; n[i - <span class="number">1</span>])&#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>同理，每一项初始化为1</p>
<p><code>dp[i] = 1</code></p>
<p>遍历顺序</p>
<p>从前向后进行遍历，取dp数组中的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : dp) res = Math.max(res,i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">题目入口</a></p>
<p>思路</p>
<p>dp数组的含义</p>
<p>以i - 1为结尾，以j - 1为结尾，最长重复子数组的长度</p>
<p>递推公式</p>
<p>如果发现两个数组中元素相等，那么将两个元素整体进行后移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">		dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>根据递推公式，第一行和第一列都是没有意义的，初始化为0，方便后面的数据都是从0开始进行计算的</p>
<p>遍历顺序</p>
<p>先遍历那一个都行，下角标需要从1开始，最终可以取nums.length因为dp数组是以i - 1结尾的</p>
<p>最终取<code>dp[i][j]</code>的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1 == nums2) <span class="keyword">return</span> nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">题目入口</a></p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p><code>dp[i][j]</code>代表的是以i - 1为结尾，以j - 1为结尾的最长公共子序列的长度</p>
<p>递推公式</p>
<p>如果发现两个元素相同的话,一起向后移动</p>
<p><code>dp[i][j] = dp[i - 1][j - 1] + 1</code></p>
<p>如果两个元素不同的话</p>
<p><code>dp[i][j] = dp[i - 1][j] </code></p>
<p><code>dp[i][j] = dp[i][j - 1]</code></p>
<p>最终取一个最大值</p>
<p><code>dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - </code>1])&#96;</p>
<p>初始化</p>
<p>根据递推公式<code>dp[i][j]</code>可以由<code>dp[i - 1][j]</code> <code>dp[i][j - 1]</code> <code>dp[i - 1][j - 1]</code>推导而来，所以我们需要对第一行和第一列进行初始化</p>
<p><code>dp[i][0]</code> <code>dp[0][j]</code>应该初始化什么呢？</p>
<p>通过dp数组的含义我们可以了解到dp[0]获取到的是空字符串</p>
<p>没有子序列，即初始化为0</p>
<p>遍历顺序</p>
<p>从左上到右下</p>
<p>最后返回什么？</p>
<p><code>dp[nums1.length - 1][nums2.length - 2]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= text1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= text2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[text1.length()][text2.length()];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">题目入口</a></p>
<p>题意</p>
<p>连接两个相同的元素，使连成的线无法相交</p>
<p>思路</p>
<p>本题其实并不需要取考虑怎么去做才能让两条线相交</p>
<p>Ex: [1,2] [ 2,1]他们的相同子序列是 1 或者是 2，并不是1，2因为子序列是按照顺序去对照的</p>
<p>根据本例，我们会发现求不相交线，就是求相同子序列</p>
<p>和上一道公共子序列的题一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums1.length][nums2.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最大子序和-1"><a href="#最大子序和-1" class="headerlink" title="最大子序和"></a>最大子序和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">题目入口</a></p>
<p>思路</p>
<p>dp数组的含义</p>
<p>本题要求连续子序列的和的最大值</p>
<p>那么<code>dp[i]</code>代表的就是以i为尾部的最大连续子序列的和</p>
<p>递推公式</p>
<p>无疑就是两种</p>
<p>要前面</p>
<p><code>dp[i - 1] + nums[i]</code></p>
<p>不要前面</p>
<p><code>nums[i]</code></p>
<p>最终我们需要在这两种情况中进行取最大值操作</p>
<p><code>Math.max(dp[i - 1] + nums[i],nums[i])</code></p>
<p>初始化</p>
<p>根据递推公式dp[i]是由dp[i - 1]推导而来，所以我们需要对dp[0]进行初始化</p>
<p>dp[0]代表以下标0结尾的最大子序列的和，即nums[0]</p>
<p><code>dp[0] = nums[0]</code></p>
<p>遍历顺序</p>
<p>从前向后进行遍历</p>
<p>返回结果</p>
<p>数组的最后一位并不一定是最大值，所以我们需要遍历dp数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i],nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res) res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">题目入口</a></p>
<p>题意</p>
<p>给出<code>s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</code></p>
<p>判断s是否是t的子序列</p>
<p>删除t中的某些元素，判断是否能和s相同</p>
<p>思路</p>
<p>其实本质上还是求公共子序列的问题，如果计算出来发现公共子序列的长度等于s的话，那么就返回true</p>
<p>dp数组的含义</p>
<p><code>dp[i][j]</code>代表的是以i - 1结尾和j - 1结尾的最长公共子序列的长度</p>
<p>这里为什么代表的是i - 1和j - 1，是因为方便对第一行和第一类进行初始化操作</p>
<p>递推公式</p>
<p>如果发现<code>s[i] != t[j]</code>，由于s属于子串，所以我们只需要移动j就可以了</p>
<p><code>dp[i][j] = dp[i][j - 1]</code></p>
<p>如果相等的话</p>
<p><code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>初始化</p>
<p>由递推公式，我们可以得到dp数组中的元素都是由左边和上面推导而来</p>
<p>所以我们需要初始化第一行和第一列</p>
<p>dp[0]代表的是空串的最大子序列的长度</p>
<p><code>dp[0] = 0</code></p>
<p>遍历顺序</p>
<p>从左上角到左下角</p>
<p>最终判断<code>dp[n1.length - 1][n2.length - 1] == s.size()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= t.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()] == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">题目入口</a></p>
<p>dp数组的含义</p>
<p><code>dp[i][j]</code>代表中以<code>i - 1</code>为结尾的s中包含以<code>j - 1</code>为结尾的t的个数</p>
<p>递推公式</p>
<p>如果s中的元素等于t中的元素</p>
<p>我们需要计算考虑s中的元素和不考虑s中的元素</p>
<p><code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]</code></p>
<p>如果s中的元素不等于t中的元素</p>
<p><code>dp[i][j] = dp[i - 1][ j]</code></p>
<p>初始化</p>
<p>根据递推公式，dp数组中的数据是第一行和第一列推导而成</p>
<p>所以我们需要初始化dp数组的第一行和第一列 </p>
<p><code>dp[i][0]</code>代表的是t为空串，当s被删除完毕后，保留下来一个空串，所以需要将其设置为1</p>
<p><code>dp[0][j]</code>代表的是s为空串，那么s怎么删都是无法凑成t的，所以将其设置为0</p>
<p>遍历顺序</p>
<p>从左上到坐下进行遍历</p>
<p>最终返回值？</p>
<p>返回<code>dp[s.length() - 1][t.length() - 1]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; t.length() + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">题目入口</a></p>
<p>思路</p>
<p>确定dp数组的含义</p>
<p><code>dp[i][j]</code>代表以i - 1为结尾的word1，和以j - 1为结尾的word2删除元素后保持相同需要的最少操作个数</p>
<p>递推公式</p>
<p>如果发现出现相同元素的时候考虑相同的元素和不考虑相同的元素结果是相同的</p>
<p><code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>如果两个元素不相同的话</p>
<p>我们有三种情况需要进行考虑</p>
<p>删除word1末尾的元素</p>
<p><code>dp[i - 1][j] + 1</code></p>
<p>删除word2末尾的元素</p>
<p><code>dp[i][j - 1] + 1</code></p>
<p>同时删除word1和word2末尾的元素</p>
<p><code>dp[i - 1][j - 1] + 2</code></p>
<p>最终取三种情况的最小值</p>
<p><code>Math.min(dp[i - 1][j],dp[i][j - 1],dp[i - 1][j - 1] + 2)</code></p>
<p>初始化</p>
<p>根据递推公式我们可以得出，dp数组中的数据都是从第一行和第一列推导而来</p>
<p><code>dp[i][0]</code> word2为空串，如果想要将word1转化为word2，需要操作i次，<code>dp[i][0] = i</code></p>
<p><code>dp[0][j]</code> word1为空串，如果想要将word2转化为word1，需要操作j次，<code>dp[0][j] = j</code></p>
<p>遍历顺序</p>
<p>从左上到右下</p>
<p>最终返回的结果？</p>
<p><code>dp[word1.length() - 1][word2.length() - 1]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= word2.length();j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>,Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>,dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">题目入口</a></p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p><code>dp[i][j]</code>代表以i - 1结尾的word1和以j - 1结尾的word2，最少操作的次数</p>
<p>递推公式</p>
<p>如果两个值相等的话，我们并不需要增加操作的次数</p>
<p><code>dp[i][j] = dp[i - 1][j - 1]</code></p>
<p>如果两个值不相同的话</p>
<p>增删</p>
<p><code>dp[i - 1][j] + 1</code></p>
<p><code>dp[i][j - 1] + 1</code></p>
<p>删除的操作和添加的操作实质上是一样</p>
<p>Ex: word1 &#x3D; “a” word2 &#x3D; “ab”</p>
<p>那么我们向word1中添加元素b和删除word2中的b是一样的</p>
<p>替换</p>
<p>我们可以根据<code>dp[i][j] = dp[i - 1][j - 1]</code>进一步进行推导，替换操作不需要进行增删操作，我们只需要在两个元素不相同的基础上修改一次，那么就相同了</p>
<p><code>dp[i - 1][j - 1] + 1</code></p>
<p>初始化</p>
<p>根据递推公式我们需要对第一行和第一列进行初始化</p>
<p><code>dp[i][0]</code> 操作的次数是i次，即将word1中的元素全部进行删除操作</p>
<p><code>dp[0][j]</code> 操作的次数是j次，即将word2中的元素全部进行删除 </p>
<p>遍历顺序</p>
<p>从左上角到右下角</p>
<p>返回什么？</p>
<p><code>dp[word1.length()][word2.length()]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= word1.length();i++) dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt;= word2.length();j++) dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j],Math.min(dp[i][j - <span class="number">1</span>],dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">题目入口</a></p>
<p>思路</p>
<p>明确dp数组的含义</p>
<p>如果本题定义一个<code>dp[j]</code>代表的含义是以j结尾回文子串的个数，这样是不太方便判断是否是回文串的</p>
<p>于是，我们可以定义一个二维数组<code>dp[i][j]</code>代表从i 到j这个范围内是否是回文子串</p>
<p>递推公式</p>
<p>我们需要考虑两种情况当nums[i]和nums[j]相同和不同的情况</p>
<p>不同的情况直接说明不是回文子串，返回false</p>
<p>接下来考虑相同的情况，包含两种情况</p>
<p>当j和i的差值小于等于1的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(j - i &lt;= 1)&#123;</span><br><span class="line">		dp[i][j] = true;</span><br><span class="line">		res++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当j和i的差值大于等于1的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">		if(dp[i + 1][j - 1])&#123;</span><br><span class="line">				dp[i][j] = true;</span><br><span class="line">				res++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>初始化</p>
<p>默认都初始化成false，通过递推公式决定每一个位置的结果</p>
<p>遍历顺序</p>
<p>根据递推公式我们可以得到每一个值都是由它的左下方的数据推导而来</p>
<p>所以我们需要从左下到右上进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(dp[i + <span class="number">1</span>][j - <span class="number">1</span>])&#123;</span><br><span class="line">                            dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                            res++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">题目入口</a></p>
<p>题意</p>
<p>本题和上一题不太一样，他想要的是最长回文子序列的长度</p>
<p>思路</p>
<p>确定dp数组的含义</p>
<p><code>dp[i][j]</code>代表的是从i 到 j这段范围内的最长回文子序列的长度</p>
<p>递推公式</p>
<p>分为两种情况</p>
<p>当<code>s[i] == s[j]</code>的时候</p>
<p>我们需要在内部区间子序列的基础上加2操作</p>
<p><code>dp[i][j] = dp[i - 1][j - 1] + 2</code></p>
<p>如果<code>s[i] != s[j]</code></p>
<p>我们需要对两边进行分别考虑</p>
<p><code>dp[i][j] = Math.max(dp[i + 1][j] + 1,dp[i][j - 1] + 1)</code></p>
<p>初始化</p>
<p>当我们i &#x3D; j当时候我们需要对dp数组进行初始化操作</p>
<p><code>dp[i][i] = 1</code></p>
<p>遍历顺序</p>
<p>根据递推公式</p>
<p>我们应该从左下方向右上方进行遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 从后往前遍历 保证情况不漏</span></span><br><span class="line">            dp[i][i] = <span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], Math.max(dp[i][j], dp[i][j - <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io">Satrol_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/">https://sloplerol.github.io/2023/05/07/LeetCode_Note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sloplerol.github.io" target="_blank">Freedom Coding</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/10/promise/" title="Promise_usage"><img class="cover" src="https://w.wallhaven.cc/full/85/wallhaven-85d3xj.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Promise_usage</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/CalculateForJava/" title="CalculateForJava"><img class="cover" src="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CalculateForJava</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E5%89%8D%E9%A1%BB%E7%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">看前须知</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">数组理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number"></span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number"></span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-number"></span> <span class="toc-text">螺旋矩阵II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">总结篇</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">链表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">如何定义链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number"></span> <span class="toc-text">链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">环形链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.</span> <span class="toc-text">有效的字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">快乐数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">赎金信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="toc-number">8.</span> <span class="toc-text">四数之和</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="toc-number"></span> <span class="toc-text">反转字符串II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number"></span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number"></span> <span class="toc-text">翻转字符串里的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">KMP算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-strStr"><span class="toc-number"></span> <span class="toc-text">实现 strStr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">重复的子字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">栈和队列理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">用栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number"></span> <span class="toc-text">用队列实现栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number"></span> <span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number"></span> <span class="toc-text">删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">逆波兰表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">前 K 个高频元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">二叉树理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II"><span class="toc-number">2.</span> <span class="toc-text">二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">二叉树的层平均值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">N叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">在每个树行中找最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II"><span class="toc-number">8.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">二叉树的最小深度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最小深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">完全二叉树的节点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">左叶子之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">路径总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-number"></span> <span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number"></span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number"></span> <span class="toc-text">二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">二叉搜索树中的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">删除二叉搜索树中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">修剪二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">把二叉搜索树转换为累加树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number"></span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII"><span class="toc-number"></span> <span class="toc-text">组合总和III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number"></span> <span class="toc-text">电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII"><span class="toc-number"></span> <span class="toc-text">组合总和II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number"></span> <span class="toc-text">复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number"></span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86II"><span class="toc-number"></span> <span class="toc-text">子集II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number"></span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97-II"><span class="toc-number"></span> <span class="toc-text">全排列 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N%E7%9A%87%E5%90%8E"><span class="toc-number"></span> <span class="toc-text">N皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%95%B0%E7%8B%AC"><span class="toc-number"></span> <span class="toc-text">解数独</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number"></span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number"></span> <span class="toc-text">分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">摆动序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number"></span> <span class="toc-text">跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII"><span class="toc-number"></span> <span class="toc-text">跳跃游戏II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">K次取反后最大化的数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-number"></span> <span class="toc-text">加油站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number"></span> <span class="toc-text">分发糖果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-number"></span> <span class="toc-text">柠檬水找零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">根据身高重建队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-number"></span> <span class="toc-text">用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">无重叠区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">划分字母区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number"></span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number"></span> <span class="toc-text">单调递增的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">监控二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number"></span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA"><span class="toc-number"></span> <span class="toc-text">动态规划理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">斐波那契数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number"></span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number"></span> <span class="toc-text">使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">不同路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-II"><span class="toc-number"></span> <span class="toc-text">不同路径 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number"></span> <span class="toc-text">整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">不同的二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">背包问题理论篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B001%E8%83%8C%E5%8C%85"><span class="toc-number"></span> <span class="toc-text">二维数组实现01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E8%83%8C%E5%8C%85"><span class="toc-number"></span> <span class="toc-text">一维数组实现背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number"></span> <span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-number"></span> <span class="toc-text">最后一块石头的重量II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number"></span> <span class="toc-text">一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">完全背包理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II"><span class="toc-number"></span> <span class="toc-text">零钱兑换II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-number"></span> <span class="toc-text">组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF-1"><span class="toc-number"></span> <span class="toc-text">爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="toc-number"></span> <span class="toc-text">零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number"></span> <span class="toc-text">单词拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">多重背包理论基础</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number"></span> <span class="toc-text">打家劫舍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-1"><span class="toc-number"></span> <span class="toc-text">打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII"><span class="toc-number"></span> <span class="toc-text">打家劫舍II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="toc-number"></span> <span class="toc-text">打家劫舍 III</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="toc-number"></span> <span class="toc-text">买卖股票</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-1"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number"></span> <span class="toc-text">最佳买卖股票时机含冷冻期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number"></span> <span class="toc-text">买卖股票的最佳时机含手续费</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">子序列问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">最长连续递增序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">最长重复子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number"></span> <span class="toc-text">不相交的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C-1"><span class="toc-number"></span> <span class="toc-text">最大子序和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">不同的子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number"></span> <span class="toc-text">两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number"></span> <span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">最长回文子序列</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Satrol_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my site !!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://sloplerol.github.io/2023/05/07/LeetCode_Note/'
    this.page.identifier = '/2023/05/07/LeetCode_Note/'
    this.page.title = 'Leecode Brush Questions Journey'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>