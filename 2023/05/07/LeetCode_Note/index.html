<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Leecode Brush Questions Journey | Freedom Coding</title><meta name="author" content="Satrol_"><meta name="copyright" content="Satrol_"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode刷题历程">
<meta property="og:type" content="article">
<meta property="og:title" content="Leecode Brush Questions Journey">
<meta property="og:url" content="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html">
<meta property="og:site_name" content="Freedom Coding">
<meta property="og:description" content="LeetCode刷题历程">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg">
<meta property="article:published_time" content="2023-05-07T13:06:30.000Z">
<meta property="article:modified_time" content="2023-05-16T13:54:59.657Z">
<meta property="article:author" content="Satrol_">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Leecode Brush Questions Journey',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-05-16 21:54:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/109008086?v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Freedom Coding"><span class="site-name">Freedom Coding</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 学习</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 生活</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Leecode Brush Questions Journey</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-07T13:06:30.000Z" title="发表于 2023-05-07 21:06:30">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-16T13:54:59.657Z" title="更新于 2023-05-16 21:54:59">2023-05-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Leecode Brush Questions Journey"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="看前须知"><a href="#看前须知" class="headerlink" title="看前须知"></a>看前须知</h4><blockquote>
<p>由于之前做完题后没有进行梳理，作者会尽快再刷一遍，所以这边笔记专注于讲解大致思路，可能有些地方没有给出详细解释，真理蕴藏于代码之中，本片笔记暂时未完善，布局可能也不够完美，作者会尽量将每一个部分完善，请谅解😌</p>
</blockquote>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="数组理论基础"><a href="#数组理论基础" class="headerlink" title="数组理论基础"></a>数组理论基础</h3><blockquote>
<p><strong>数组是存放在连续内存空间上的相同类型数据的集合</strong></p>
</blockquote>
<p>注意点</p>
<ul>
<li>数组的下标是从0开始的</li>
<li>数组中每一个元素的内存地址是连续的</li>
</ul>
<p>数组对于查找元素很方便，但是增删元素会导致后面元素的内存地址发生后移的效果，所以效率比较低</p>
<p><code>数组中的元素只能被覆盖，不能删除</code></p>
<p>在C++中内存地址是连续的，而在Java中内存地址是交给虚拟机进行寻址操作进行分配的</p>
<p>数组的理论基础介绍到这里，或多或少你也掌握了一些数组的基本知识点了</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>二分查找是对升序的数组进行查找操作，如果在数组中查找到元素，返回下标否则返回-1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">2</span>;</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; target = <span class="number">10</span>;</span><br><span class="line">Output: -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>思路分析</p>
<p>二分查找的难点主要集中在考虑临界点情况 到底是while(left &lt; right) 还是while(left &lt;&#x3D; right)呢</p>
<p>在二分法中区间主要分为两种[left,right] 或者是 [left,right)</p>
<p>第一种写法: [left,right] </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right] 决定left 是否等于 right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">                right = midVal - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种写法[left,right)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//[left,right) 这是后while循环left &lt; right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[midVal] &lt; target)&#123;</span><br><span class="line">                left = midVal + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[midVal] &gt; target)&#123;</span><br><span class="line">              <span class="comment">//因为右边取不到所以直接直接将right赋值为midVal</span></span><br><span class="line">                right = midVal;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> midVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">LeetCode链接</a></p>
<p>这道题给我们一个数组，并且给我们target，要求我们返回移除所有该元素后返回的新数组，和长度</p>
<p>暴力算法</p>
<p>思路分析</p>
<blockquote>
<p>对数组进行遍历，如果发现了有一个值和target相等在来一个for循环将数组后的所有元素进行前移操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">             		<span class="comment">//目标元素后面的元素进行操作</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                    nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//将下标前移 接着进行移位后的数组从i开始重复</span></span><br><span class="line">                i--;</span><br><span class="line">              	<span class="comment">//将数组总长度进行减1操作</span></span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针法</p>
<p>思路分析</p>
<blockquote>
<p>定义一个快指针，定义一个慢指针，快指针用来遍历数组中的元素，如果不等于target的值的话才将值赋值给慢指针对应的下标，慢指针再做后移操作</p>
</blockquote>
<img src="/Users/satrol_/Desktop/NotepadImg/删除数组中元素.jpg" style="zoom:25%;" />

<p>如果是在不理解这里有一张我画的图解，fast向后查找如果查找到的目标值为1的话slow不需要进行后移操作，否则需要，最后将slow的大小进行返回即新数组的长度</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;fast &lt; nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val)&#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//返回慢指针的大小也就是新数组的长度</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="有序数组的平方"><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">链接地址</a></p>
<p>题意：给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组</p>
<p>暴力解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            nums[i] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么会想到双指针？</p>
<p><code>因为数组是有序的的那么最大值只能出现在两边，于是我们可以通过比较两边值的平方的方法，将大的值放入到新的数组中</code></p>
<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] newResult = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//一定是&lt;=否则会丢掉中间值的可能</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = size;left &lt;= size;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right] * nums[right] &gt; nums[left] * nums[left])&#123;</span><br><span class="line">                newResult[size--] = nums[right] * nums[right];</span><br><span class="line">                right--;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//相等的情况放在哪种情况中都可以，就是不能丢掉</span></span><br><span class="line">                newResult[size--] = nums[left] * nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="长度最小的子数组"><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">链接地址</a></p>
<p>题意：给出一个数组和一个target求出数组中长度最小的的连续子数组的和大于等于target的值的元素个数</p>
<p>暴力解法</p>
<blockquote>
<p>双层for循环，第一层for循环设置起始位置第二层for循环从起始位置开始到达终止位置判断是否满足条件，进行返回结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j &lt; nums.length;j++)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum &gt;= target)&#123;</span><br><span class="line">                    min = Math.min(min,j - i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>滑动窗口</p>
<blockquote>
<p>其实还是双指针的想法，只不过左指针是在动态移动的，一层for循环用来移动右指针，发现一个满足条件的，移动左指针，看是否可以缩小范围</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,sum = <span class="number">0</span>,subLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                subLen = j - i + <span class="number">1</span>;</span><br><span class="line">                result = Math.min(subLen,result);</span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="螺旋矩阵II"><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">链接地址</a></p>
<p>思路</p>
<blockquote>
<p>每一次循环考虑的只包含单个对角，然后再考虑转了几圈，如果是偶数的话转的圈数必然是n &#x2F; 2但是如果是奇数的话圈数也是n &#x2F; 2中间的那一个点需要单独处理</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>,count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span>(loop++ &lt; n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = start;j &lt; n - loop;j++)&#123;</span><br><span class="line">                arr[start][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i = start;i &lt; n - loop;i++)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时i，j已经到arr[n][n]处了</span></span><br><span class="line">            <span class="comment">//这部一定要 &gt;= loop </span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt;= loop;j--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(;i &gt;= loop;i--)&#123;</span><br><span class="line">                arr[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//转完一圈起始位置会发生变化</span></span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            arr[start][start] = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h3><blockquote>
<p>数组往期的做法，很多人都可能采用两个for循环求解题目，上述这些题目带你初步了解如何通过双指针的想法仅仅用一个for循环来求解题目，希望写完题目后的你能自我反思自己是否要改变往常的双for循环的低效方法</p>
</blockquote>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h3 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h3><p>链表是什么？</p>
<blockquote>
<p>每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。</p>
</blockquote>
<p>众所周知，链表分为好几大类</p>
<p><strong>单链表</strong>(每一个节点只有一个指向next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8D%95%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>双链表</strong>(每一个节点包含两个指向pre,next)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%8F%8C%E9%93%BE%E8%A1%A8.png"></p>
<p><strong>循环链表</strong>(主要用于解决约瑟夫问题)</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png"></p>
<p>链表在内存中存储可不是连续的，所以主要用来进行增删操作</p>
<h4 id="如何定义链表"><a href="#如何定义链表" class="headerlink" title="如何定义链表"></a>如何定义链表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">  	ListNode next;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(ListNode next,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.next = next;</span><br><span class="line">      <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8.png"></p>
<p>这里面暗藏了垃圾回收机制，那么什么是垃圾回收呢</p>
<p>见图解当删除D即没有东西指向D的时候D没有了任何作用就会触发垃圾回收机制</p>
<p>C++中需要手动释放，而Java Python中可以自动垃圾回收</p>
<p>添加链表中节点</p>
<p>图解</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9.png"></p>
<h3 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/submissions/">链接地址</a></p>
<p>这道题需要考虑两种情况</p>
<ul>
<li>移除头节点 让头节点设置为head.next</li>
<li>移除非头节点 找到上一个节点让他的下一个节点指向当前节点的下一个节点</li>
</ul>
<p>如果想要以统一的方式删除节点就可以引入<code>虚拟头节点的概念</code></p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9.jpg"></p>
<p>先使用传统的方式去移除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果删除的是头节点的话 假如链表中元素都是1的话需要进行全部移除</span></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span> &amp;&amp; head.val == val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果删除的节点不是头节点的话</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里面让当前节点指向head的目的是为了获取到删除节点的上一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//避免操作空指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">      	<span class="comment">//定义虚拟头节点下一位指向head val设置为什么都可以 因为最后返回值是从head开始的</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">链接地址</a></p>
<p>这道题可以让你熟练的掌握链表的所有基本基本操作</p>
<p>为了迎合增删是否为头节点的问题本题使用虚拟头节点来解决</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点</span></span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表最前面插入一个节点，等价于在第0个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class="line">    <span class="comment">// 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class="line">    <span class="comment">// 如果 index 大于链表的长度，则返回空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="comment">//找到要插入节点的前驱</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        toAdd.next = pred.next;</span><br><span class="line">        pred.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index ; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">题目入口</a></p>
<p>这道题有两种做法双指针和递归</p>
<p>双指针</p>
<p>思路</p>
<p>我们可以定义一个pre初始化为空，在head的前面，通过双指针的思想不断移动pre和cur</p>
<p>临界条件：当pre为为节点cur为原来的尾节点后的null的时候截止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//临界条件是cur刚好为尾节点后的空节点，此时pre指向的就是为尾节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//保存cur的下一个值因为现在cur要指向他的前一个值了</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归写法：实际上还是双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">return</span> reverse(pre,cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode pre,ListNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> pre;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">题目入口</a></p>
<p>思路</p>
<p>这道题需要使用虚拟头节点，可能有人问为什么使用虚拟头节点，这是因为你要操作head这个元素所以肯定要用到它的前一个节点</p>
<p>图解</p>
<img src="/Users/satrol_/Desktop/NotepadImg/交换节点.jpg" style="zoom:35%;" />

<p><strong>如上图所见dummyhead使用来操作两个节点的每一次都是作为前一个节点的前面的节点</strong></p>
<p>接下来需要考虑临界条件</p>
<p>这里包含两种情况</p>
<ul>
<li><p>偶数的时候 dummyhead.next &#x3D;&#x3D; null</p>
</li>
<li><p>奇数的时候 dummyhead.next.next &#x3D;&#x3D; null </p>
</li>
<li><p>以上两种情况必须同时满足</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="comment">//temp 和 temp1需要保存下来因为下面在进行修改</span></span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> cur.next.next.next;</span><br><span class="line">           cur.next = cur.next.next;</span><br><span class="line">           cur.next.next = temp;</span><br><span class="line">           temp.next = temp1;</span><br><span class="line">           cur = cur.next.next;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//正如上图所见，head发生了变化所以需要将dummyhead.next作为头节点</span></span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/submissions/">题目入口</a></p>
<p>这道题还是一个双指针问题</p>
<p>思路</p>
<blockquote>
<p>定义快慢指针，先让快指针移动n步，再让慢指针跟着慢指针同时进行移动操作，但是这时候你发现了另一个问题，虽让慢指针定位到了要删除的元素身上，当时无法对他进行操作，所以要让快指针移动n + 1步，此时慢指针才会定位到要删除元素的前一个节点的身上</p>
</blockquote>
<p>临界条件判断：当快指针为空的时候结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummyhead;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n + <span class="number">1</span>;i++)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">题目入口</a></p>
<p>思路</p>
<p>当两条长度不一的情况下求出差值让长链表移动差值次，接着比较每一次的值是否相等，决定返回值是什么</p>
<img src="/Users/satrol_/Desktop/NotepadImg/双链表相交点.jpg" style="zoom:40%;" />





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>,lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">//获取两条链表的长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//因为curA此时已经为空需要重置</span></span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">				<span class="comment">//让长的链表为curA</span></span><br><span class="line">        <span class="keyword">if</span>(lenB &gt; lenA)&#123;	</span><br><span class="line">            <span class="type">int</span> <span class="variable">tempVal</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = tempVal;</span><br><span class="line">            </span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tempNode</span> <span class="operator">=</span> curA;</span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tempNode;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//求差值</span></span><br><span class="line">        cha = lenA - lenB;</span><br><span class="line">     		<span class="comment">//长链表后移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; cha;i++)&#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">				<span class="comment">//判断是否相等</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">null</span> &amp;&amp; curB != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">题目入口</a></p>
<p>这道题让我们判断是否能成环，尾部连接到那一个节点</p>
<p>这道题可以使用快慢指针的思路来解决，为什么想到用这种方式来解决呢？</p>
<p><strong>判断是否成环</strong></p>
<blockquote>
<p>因为链表如果成环的话，那么快慢指针能够相遇</p>
<p>那为什么快指针可以和慢指针相遇呢？</p>
<p>比如快指针的速度为2，慢指针的速度为1，那么差值为1，快指针一直以1的速度无限接近于慢指针，肯定是能碰到的</p>
</blockquote>
<p><strong>判断在哪相遇</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/环形链表.jpg" style="zoom:40%;" />



<p>这个图是有很多注意点的</p>
<ul>
<li>由于快指针比慢指针快所以相遇的圈数一定大于等于1</li>
<li>慢指针走过的圈数一定没有1圈，假如快指针速度为2，慢指针速度为1，那么最坏的情况也是在圈中间相遇</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">      	<span class="comment">//fast来判断为null的情况</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">              	<span class="comment">//参考上面图解x = z</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//返回相遇的节点index1和2都行</span></span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到相遇的节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><p>什么是哈希表呢？</p>
<p>哈希表又称散列表，根据关键码的值而直接进行访问的数据结构，数组就是通过下标来进行访问的也就是一张哈希表</p>
<p>哈希表主要使用来干什么的？</p>
<p><strong>用来判断集合中是否出现了某一个元素</strong></p>
<p>将时间复杂度大大的降低了</p>
<p>哈希函数是什么？</p>
<p>比如将每一个人的信息映射到下标索引身上，通过查询下标来判断是谁</p>
<p>注意这里面将每一条数据信息转化为hashCode数值</p>
<p>那么如果hashCode得到的值大于哈希表的长度的话，该如何解决</p>
<p><strong>我们可以通过取模的方式(hashCode &#x2F; HashTable)进行解决</strong></p>
<p><strong>常见的问题：哈希碰撞</strong></p>
<p>什么是哈希碰撞？</p>
<blockquote>
<p>两条数据同时映射到哈希表的同一个位置上</p>
</blockquote>
<ul>
<li><p>解决方法1:  拉链法</p>
<p>  将两条数据同时存储到该位置上</p>
<hr>
<p>  其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。</p>
</li>
<li><p>解决方法2: 线性探测法</p>
<p>  前提：hastable足够大，通过空位的方式来存放碰撞的值</p>
</li>
</ul>
<p>常见实用哈希法来完成的三种数据结构</p>
<ul>
<li>Map</li>
<li>Set</li>
<li>数组</li>
</ul>
<h4 id="有效的字母异位词"><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">题目入口</a></p>
<p>思路分析</p>
<p>这道题我们可以使用哈希表+数组的方式来解决，为什么呢？</p>
<blockquote>
<p>因为统计的是小写字母，ASCII码值是连续的，可以将a代表数组下标为0，z对应数组下标为25</p>
</blockquote>
<p>当然Map来解决也是可以的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">      	<span class="comment">//通过字符串的toCharArray方法将字符串中的每一个字符拆分开来</span></span><br><span class="line">        <span class="type">char</span>[] c1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = t.toCharArray();</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            arr[c1[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; c2.length;j++)&#123;</span><br><span class="line">            arr[c2[j] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">题目入口</a></p>
<p>为什么我们想到用哈希表来解决这道题？</p>
<p><strong>因为哈希表往往是用来查找集合中是否包含某个元素</strong></p>
<p>三种数据类型我们应该选择哪种，针对于这道题来说，尽量不要选择数组来解决该问题，因为数据够大，使用数组需要开辟很多的内存空间，所以我们优先选择set来解决</p>
<p><code>Set还有一个优势就是可以帮助我们去重数组，放置结果中出现两个重复的元素</code></p>
<p>解题思路</p>
<p>查找两个数组重复元素，我们可以将一个数组放入到集合当中，然后判断另一个数组中的元素是否在当前集合中出现过，如果出现过的话放入到新数组中，最后将集合转化为数组，解决此问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int index = 0;</span></span><br><span class="line">        <span class="comment">//int[] arr = new int[result.size()];</span></span><br><span class="line">        <span class="comment">//for(int i : result)&#123;</span></span><br><span class="line">            <span class="comment">//arr[index++] = i;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//return arr;</span></span><br><span class="line">     		<span class="keyword">return</span> result.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>LeetCode中后来将数据改成了1000所以可以使用数组来解决，不过在Java中不用Set没有直接对数组去重的操作，所以不推荐在Java中使用数组使用该题</strong></p>
<p>数组的大体思路是创建一个1010的数组，将num1的值对应的数组下标设置为1，将num2去重，判断在数组中num2下标对应的值是否是1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1010</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            arr[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得不重复的nums2</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(i))&#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[list.get(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                res.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.size();i++)&#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="快乐数"><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">题目入口</a></p>
<p>思路</p>
<p>可以拆分出来一个方法专门用来求每一项的平方，可以借助Set集合来判断之前的集合中是否包含之前计算出来过的元素，如果包含说明肯定不是，那么就让他不停的进行循环操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !set.contains(n))&#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">            n = getSum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> digital;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            digital = n % <span class="number">10</span>;</span><br><span class="line">            sum += digital * digital;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">题目入口</a></p>
<p>思路分析</p>
<p>这道题如果使用暴力很简单，这里就直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i;</span><br><span class="line">                    res[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>显然时间复杂度为O(n * 2)不太好</p>
<p>接下来使用哈希法来解决</p>
<p>在写代码之前讲一下大体思路</p>
<p>我们可以通过map的方式来记录每一个下标和他的对应的值，通过查找target - 当前对应的值，返回下标，从而得到两个下标</p>
<p><strong>注意点：不要先把每一个值上来就都放入到map中，如果这样加入nums是[3,3] 返回到下标就是[0,0]，而我们要的结果是[0,1]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(target - nums[i]);</span><br><span class="line">                result[<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">题目入口</a></p>
<p>解题思路</p>
<p>我们可以将四个数组拆分成两对，第一对遍历前两个数组，通过Map的方式来记录a + b的值作为key 出现的次数记为value，再去遍历另一对两个数组记录key为- (c + d) ,因为要使a + b + c + d &#x3D; 0 , a + b &#x3D; - (c + d)</p>
<p>注意点：如果a + b 出现了 - ( c + d)匹配的值的话就加上a + b对应的value值  </p>
<p>ex : a + b : 3 出现了一个- (c + d)匹配那么次数就应该加3</p>
<p>可能有的人认为为什么不将四个数组分成分成1 和 3 因为3的时间复杂度为O(n * 3) 而分成2 * 2 时间复杂度才O(n * 2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n)</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums2.length;j++)&#123;</span><br><span class="line">                map.put(nums1[i] + nums2[j],map.getOrDefault(nums1[i] + nums2[j],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums3.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; nums4.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> -<span class="number">1</span> * (nums3[i] + nums4[j]);</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">                    count += map.get(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/submissions/">题目链接</a></p>
<p>思路和有效字母异位词一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = ransomNote.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = magazine.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] ch = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c2.length;i++)&#123;</span><br><span class="line">            ch[c2[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; c1.length;i++)&#123;</span><br><span class="line">            ch[c1[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : ch)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">题目链接</a></p>
<p>思路分析，因为要获取到的是三个数的值，和统计出现的次数可不太一样，使用哈希表的方法来解决是很麻烦的</p>
<p><strong>所以我们能想到双指针的方法来解决，排序数组之后定义第一个数<code>i</code>用来走遍数组，接着定义的两个指针布局于<code>i + 1</code> , <code>len - 1</code>,通过三数之和判断是否等于0移动指针</strong></p>
<p>注意事项</p>
<ul>
<li>如果第一个数大于0那么就不用判断了</li>
<li>判断i 是否重复</li>
<li>判断left 和right 是否重复</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果发现i重复利用的情况</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line">                    <span class="comment">//去重操作</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="四数之和-1"><a href="#四数之和-1" class="headerlink" title="四数之和"></a>四数之和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">题目入口</a></p>
<p>思路</p>
<p>延续了三数之和的方法在三数for循环的外面再套一层循环</p>
<p>注意点</p>
<ul>
<li><p>由于可能出现负数的情况所以剪枝操作是不行的,因为两个负数相加变得会越来越小</p>
<blockquote>
<p>剪枝操作就是三数之和判断首位元素 &gt; target 就直接返回</p>
</blockquote>
<p>  如果要做剪枝的话需要判断首位元素是否大于0</p>
</li>
<li><p>去重操作</p>
</li>
<li><p>外层需要剪枝操作和去重操作，内层只需要去重判断</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) <span class="keyword">return</span> list;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;j &lt; nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line"></span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">题目入口</a></p>
<p>思路：</p>
<p>根据题意，返回的还是原数组，所以我们需要通过双指针的方式来交换首尾元素</p>
<p>双指针方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过for循环每一次走过的路径都是2k反转内部长度为k的字符串</p>
<p>注意事项</p>
<blockquote>
<p>需要判断i + k是否超过了整个字符串的长度，如果超过了反转i到字符串长度的字符即可，否则反转i 到i + k范围内的字符</p>
</blockquote>
<p>最直白的写法(时间有点多)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt; len)&#123;</span><br><span class="line">                s = reverse(s,i,i + k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = reverse(s,i,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来翻转字符串下标从j到k之间的字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String str,<span class="type">int</span> j,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>巧用StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; len;i += <span class="number">2</span> * k)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">firstK</span> <span class="operator">=</span> i + k &gt; len ? len : i + k;</span><br><span class="line">            <span class="type">int</span> <span class="variable">secondK</span> <span class="operator">=</span> i + <span class="number">2</span> * k &gt; len ? len : i + <span class="number">2</span> * k;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            temp.append(s.substring(i,firstK));</span><br><span class="line">            result.append(temp.reverse());</span><br><span class="line">						<span class="comment">//如果第一个k和第二个k之间有元素的话，需要截取</span></span><br><span class="line">            <span class="keyword">if</span>(firstK &lt; secondK)&#123;</span><br><span class="line">                result.append(s.substring(firstK,secondK));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">题目入口</a></p>
<p>显然这道题肯定不是让你调用库函数的题</p>
<p>可以通过StringBuffer来判断是否是空格，条件判断执行不同的语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针通过扩容机制来解决</p>
<p>思路</p>
<p><em><em>我们可以扩容空格的个数</em> 2倍，通过双指针判断是否为空格来进行填充%20操作</em>*</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//扩容两倍</span></span><br><span class="line">                sb.append(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sb.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始定义双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        s += sb.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[left] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                ch[right--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                ch[right] = <span class="string">&#x27;%&#x27;</span>;  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ch[right] = ch[left];</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">题目入口</a></p>
<p>本题思路</p>
<p>先对字符串的前后进行去除空格的操作，然后对中间进行去除空格的操作，最后对整个字符串进行反转操作，通过split方法分割多个字符串，然后对每一个字符串进行反转操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//用来去除两边的空格</span></span><br><span class="line">        <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(right) == <span class="string">&#x27; &#x27;</span>) right--;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">while</span>(s.charAt(left) == <span class="string">&#x27; &#x27;</span> &amp;&amp; s.charAt(left + <span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(s.charAt(left));</span><br><span class="line">            left++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] firstReverse = sb.reverse().toString().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; firstReverse.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != firstReverse.length - <span class="number">1</span>)&#123;</span><br><span class="line">                result += reverse(firstReverse[i]) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                result += reverse(firstReverse[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverse</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> ch.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            temp = ch[left];</span><br><span class="line">            ch[left] = ch[right];</span><br><span class="line">            ch[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目入口</a></p>
<p>思路分析</p>
<p>左旋转2翻译人话就是将最左边的两个元素放入到最右边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,n);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> s.substring(n,s.length());</span><br><span class="line">        <span class="keyword">return</span> str2 + str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><blockquote>
<p>主要解决字符串匹配的问题</p>
</blockquote>
<p>ex : str1 &#x3D; “aabaabaaf” str2 &#x3D; “aabaaf”</p>
<p>判断是否str1中出现了str2 ？</p>
<p>正常来说我们会通过双层for循环的方法逐一进行匹配，但是时间复杂度是两个字符串长度的乘积，效率很low</p>
<p>KMP算法的实现原理</p>
<p>还是以str1和str2为例,我们首先进行逐一匹配发现在b和f的位置上无法匹配了那么就会回到之前匹配过的b上接着进行匹配</p>
<p>如果不太理解可以看这张图</p>
<img src="/Users/satrol_/Desktop/NotepadImg/KMP.jpg" style="zoom:40%;" />

<ul>
<li><p>前缀</p>
<blockquote>
<p>包含首元但不包含尾元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; a，aa，aab，aaba，aabaa</p>
</li>
<li><p>后缀</p>
<blockquote>
<p>包含尾元但不包含首元的所有子串</p>
</blockquote>
<p>  ex: aabaaf &#x3D;&gt; f，af，aaf，baaf，abaaf</p>
</li>
<li><p>通过匹配的字符串获取到的前缀表</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>前缀</th>
<th>后缀</th>
<th>相等前后缀</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>无</td>
<td>无</td>
<td>0</td>
</tr>
<tr>
<td>aa</td>
<td>a</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>aab</td>
<td>a, aa</td>
<td>b, ab</td>
<td>0</td>
</tr>
<tr>
<td>aaba</td>
<td>a, aa, aab</td>
<td>a, ba, aba</td>
<td>1</td>
</tr>
<tr>
<td>aabaa</td>
<td>a, aa, aab,aaba</td>
<td>a, aa, baa, abaa</td>
<td>2</td>
</tr>
<tr>
<td>aabaaf</td>
<td>a, aa, aab, aabaa</td>
<td>f, af, aaf, baaf,abaaf</td>
<td>0</td>
</tr>
</tbody></table>
</li>
</ul>
<p>得到前缀表后我们应该去找不匹配元素的前面的一个元素的值，即2，代表了前缀中有一个和后缀相等的字符串，从这个字符串的后面接着开始匹配，这个元素的下标就是最长相等前后缀的值</p>
<p>next数组的不同实现方式</p>
<ul>
<li>原封不动的将前缀表作为next数组</li>
<li>将前缀表右移，将第一个设置为-1，作为新的next数组</li>
<li>将前缀表整体减1，作为next数组</li>
</ul>
<p>next数组实现包含四步</p>
<ul>
<li><p>初始化操作</p>
<p>  定义两个指针i，j分别代表后缀起始位置和前缀起始位置</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br></pre></td></tr></table></figure>

<hr>
<p>  这里设置j为-1是因为我们采用的是统一减1的实现方式</p>
</li>
<li><p>判断前后缀不相等的情况</p>
<p>  j里面记录着包括j之前子串中相等前后缀的数量</p>
<p>  当发现前后缀的值不相等的话就需要回退到j + 1的前一个值对应的索引</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>判断前后缀相等的情况</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i)) j++;</span><br></pre></td></tr></table></figure>

</li>
<li><p>更新next数组</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line">next[i] = j;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完整代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(s.charAt(i) != s.charAt(j + <span class="number">1</span>)) &#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(s.charAt(i) == s.charAt(j + <span class="number">1</span>))&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>next数组实现完毕，接下来看我们该如何进行使用</p>
<p>我们要在文本串(s)中查找模式串(t)</p>
<p>定义两个指针i从文本串的起始位置开始，j从模式串的起始位置开始</p>
<p>j的初始值是-1 ，i的初始值为1 ，接着对i 和 j + 1进行比较</p>
<p>因为要对模式串和文本串进行一一比较所以i我们要从0开始</p>
<ul>
<li><p>如果文本串和模式串无法匹配</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//j &gt;= 0 是为了防止j = next[-1]的情况</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">		<span class="comment">//跳转位置</span></span><br><span class="line">		j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何匹配了的话</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i和j同时向后移动 因为i在循环中</span></span><br><span class="line"><span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>]) j++;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何判断匹配成功了呢</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当j指向了模式串的末尾的话即匹配成功</span></span><br><span class="line"><span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> i - t.length() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体代码</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">		<span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s[i] != t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s[i] == t[j + <span class="number">1</span>])&#123;</span><br><span class="line">				j++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(j == t.length() - <span class="number">1</span>)&#123;</span><br><span class="line">				reutrn i - t.length() + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实现-strStr"><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">题目入口</a></p>
<p>最直白的方法indexOf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j + <span class="number">1</span>)) j = next[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j + <span class="number">1</span>)) j++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j == needle.length() - <span class="number">1</span>) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; s.charAt(j + <span class="number">1</span>) != s.charAt(i))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(j + <span class="number">1</span>) == s.charAt(i))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">题目地址</a></p>
<p>移动匹配</p>
<p>思路</p>
<p>如果一个字符串是由重复子串构成的话，那么这个字符串的前半部分和后半部分是相同的，于是我们可以再添加一个这个字符串，截取掉拼接好的字符串的两边，判断中间是否包含原来的字符串 &#x3D;&gt; 前半部分的尾元 + 后半部分的首元</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">concat</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> concat.substring(<span class="number">1</span>,concat.length() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.indexOf(s) != -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>KMP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h3 id="栈和队列理论基础"><a href="#栈和队列理论基础" class="headerlink" title="栈和队列理论基础"></a>栈和队列理论基础</h3><blockquote>
<p>栈是先进后出，队列是先进先出</p>
</blockquote>
<p>栈和队列都是属于STL（C++标准库）里面的数据结构</p>
<p>常见的STL版本</p>
<ul>
<li><p>HP STL</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。</span><br></pre></td></tr></table></figure>

</li>
<li><p>P.J.Plauger STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>SGI STL </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">题目入口</a></p>
<p>思路</p>
<p>通过两个栈来实现队列，一个是in栈，还有一个是out栈，将一组数据放入到in栈中，再将这组数据从in栈中弹出放入到out栈中，此时弹出来的顺序就是正确的了</p>
<img src="/Users/satrol_/Desktop/NotepadImg/栈实现队列.jpg" style="zoom:33%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpInStackOut();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpInStackOut</span><span class="params">()</span>&#123;</span><br><span class="line">      	<span class="comment">//如果out栈为空说明已经将in栈推送到了out栈中 </span></span><br><span class="line">        <span class="keyword">if</span>(!stackOut.empty()) <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">//如果in栈不为空说明需要将内容push到out栈中</span></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.empty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以通过一个队列或者是两个队列来实现栈</p>
<p>两个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line">    Deque&lt;Integer&gt; que2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">//第二个队列主要用来备份除栈中第一个元素外其余的元素</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que2.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> que1.peekFirst();</span><br><span class="line">        que1.pollFirst();</span><br><span class="line">        que1 = que2;</span><br><span class="line">      	<span class="comment">//这种方式来清空que2中残留的数据更加直观</span></span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;	</span><br><span class="line">      	<span class="comment">//队尾即栈顶</span></span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一个队列来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.addLast(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            que.addLast(que.peekFirst());</span><br><span class="line">            que.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">      	<span class="comment">//这里面的栈顶就是队尾</span></span><br><span class="line">        <span class="keyword">return</span> que.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">题目入口</a></p>
<p>思路分析</p>
<p>可以通过栈来解决本题，如果遇到了左括号就将与之对应的右括号入栈，当遇到了右括号就可以和之前的右括号进行消除</p>
<p>本题需要考虑三种情况</p>
<ul>
<li>消除到最后栈中包含某个右括号没有被消除</li>
<li>在遇到右括号的时候发现栈顶元素并不是右括号</li>
<li>字符串在遇到右括号需要消除的时候，栈内没有元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || stack.peek() != s.charAt(i))&#123;</span><br><span class="line">              	<span class="comment">//第二种情况和第三种情况放在一起进行考虑</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">题目入口</a></p>
<p>思路分析</p>
<p>我们可以用栈来解决这道题目</p>
<blockquote>
<p>定义一个栈，遍历字符串添加条件判断语句将重复连续的元素进行去除后，因为栈pop出来的字符串是反序的所以需要我们去反转一下栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; stack.peek() == s.charAt(i))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//反转栈的操作</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            result.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>将字符串作为栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; s.length();i++)&#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="comment">//重复的情况</span></span><br><span class="line">            <span class="keyword">if</span>(top &gt;= <span class="number">0</span> &amp;&amp; ch == res.charAt(top))&#123;</span><br><span class="line">                res.deleteCharAt(top);</span><br><span class="line">                top--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(ch);</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">            <span class="comment">// 直接用fast指针覆盖slow指针的值</span></span><br><span class="line">            ch[slow] = ch[fast];</span><br><span class="line">            <span class="comment">// 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了</span></span><br><span class="line">            <span class="keyword">if</span>(slow &gt; <span class="number">0</span> &amp;&amp; ch[slow] == ch[slow - <span class="number">1</span>])&#123;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="逆波兰表达式求值"><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">题目入口</a></p>
<p>什么是逆波兰表达式</p>
<blockquote>
<p>方便计算机计算的表达式</p>
</blockquote>
<p>平常比较常见的是中缀表达式</p>
<p>ex: (1 + 2) * 3</p>
<p>切换成后缀表达式就是</p>
<p>ex : 1 2 + 3 *</p>
<p>思路分析</p>
<p>正常来说如果没有遇到操作符的话，就将其转化为数字放入到栈中，如果遇到了，我们可以pop出两个元素对这两个元素进行运算，最后栈中只留下了一个值，也就是答案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s))&#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">题目入口</a></p>
<p>这道题如果用暴力的话时间复杂度是O(n * k)，很容易就超时</p>
<p>思路</p>
<p>我们可以使用队列来解决本题，每一次滑动窗口移动的时候，我们可以将首元进行pop将新加入的尾元进行push，最后再去获得这组数据中的最大值</p>
<blockquote>
<p>在C++中有优先级队列的概念，但是如果你使用了优先级队列的话，那么每一次数据都是排序好的，你如果pop的话就会将最大值弹出和预期弹出的值不相符</p>
</blockquote>
<p>单调队列模拟</p>
<p>首先确定k的大小，初始化</p>
<p>ex: 1 3 -1 -3 5 3 2 1</p>
<p>根基建立 使元素个数达到k</p>
<p>我们上来将1放入到队列中，接着放入3发现前面的元素比3小，那么就需要将前面的元素全部pop出来，然后加入-1，发现后面的元素比3小push进来</p>
<p>3 -1 &#x3D;&gt; 3</p>
<p>第二次循环：放入-3，发现前面元素都比他大所以直接放入</p>
<p>3 -1 -3 &#x3D;&gt; 3</p>
<p>第三次循环：将3pop出来，放入5，发现前面元素都比5小，将前面的元素全部pop出来</p>
<p>5 &#x3D;&gt; 5</p>
<p>第四次循环：将-1pop出去，由于之前5进来的时候-1已经pop出去了所以不用pop了，将3 放入</p>
<p>5 3 &#x3D;&gt; 5</p>
<p>第五次循环：将-3pop，之前pop过，不用pop，将2放入</p>
<p>5 3 2 &#x3D;&gt; 5</p>
<p>第六次循环：经5pop，将1放入</p>
<p>3 2 1 &#x3D;&gt; 3</p>
<p>result: [3,3,5,5,5,3]</p>
<p>单调队列就好比，一群人加入到一个队伍，每一个加入进来的人能力不一，后进来的人发现自己能力比前面的人高，就想方设法将他从队伍中赶出去，自己作为队长</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDeque</span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      	<span class="comment">//移除队列的首元</span></span><br><span class="line">        <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; val == que.peek())&#123;</span><br><span class="line">            que.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">      <span class="comment">//添加元素并且将前面小于该元素的元素一处</span></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty() &amp;&amp; val &gt; que.getLast())&#123;</span><br><span class="line">            que.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        que.add(val);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//获取到每一次的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getMax</span><span class="params">()</span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> que.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">MyDeque</span> <span class="variable">deque</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDeque</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[num++] = deque.getMax();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将最前面的元素进行移除</span></span><br><span class="line">            deque.poll(nums[i - k]);</span><br><span class="line">            deque.add(nums[i]);</span><br><span class="line">            res[num++] = deque.getMax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">题目入口</a></p>
<p>思路</p>
<p>本题分为三个步骤</p>
<ul>
<li>统计元素出现的频率</li>
<li>对出现的频率进行排序</li>
<li>找出前K个高频元素</li>
</ul>
<p>在这里面，统计元素出现的频率通过map就可以进行统计</p>
<p>排序出现的频率可以通过优先队列</p>
<p>什么是优先级队列呢？</p>
<p>其实<strong>就是一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。</p>
<p>什么是堆呢？</p>
<p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p>
<p>这道题是用大顶堆呢还是小顶堆呢，其实两种方式都可以实现</p>
<ul>
<li><p>大顶堆思路</p>
<blockquote>
<p>由于你是大顶堆上面的是最大的那么你最后poll出来的前k个就是出现频率最高的元素</p>
</blockquote>
</li>
<li><p>小顶堆思路</p>
<blockquote>
<p>将最小的在遍历map的时候poll出去，队列中余下的就都是出现频率最高的元素</p>
</blockquote>
</li>
</ul>
<p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p>
<p>通过大顶堆进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">  			<span class="comment">//通过map来获取每一个元素出现的次数</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//定义优先级队列，定义小顶堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm2[<span class="number">1</span>] - parm1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">          	<span class="comment">//遍历map通过数组出现的频率进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">  			<span class="comment">//最后poll出来的k个元素都是出现频率最高的元素</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>小顶堆来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            map.put(nums[i],map.getOrDefault(nums[i],<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((parm1,parm2)-&gt;parm1[<span class="number">1</span>] - parm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; pq.peek()[<span class="number">1</span>])&#123;</span><br><span class="line">                    pq.poll();</span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">          </span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>Stack</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.isEmpty(); <span class="comment">//true</span></span><br><span class="line">stack.push(<span class="number">1</span>);</span><br><span class="line">stack.push(<span class="number">2</span>);</span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line">stack.pop(); <span class="comment">//4</span></span><br><span class="line">stack.peek(); <span class="comment">//3</span></span><br><span class="line">stack.isEmpty(); <span class="comment">// false</span></span><br><span class="line">stack.search(<span class="number">4</span>); <span class="comment">// -1 没有返回-1</span></span><br><span class="line">stack.search(<span class="number">3</span>); <span class="comment">//1</span></span><br><span class="line">stack.search(<span class="number">2</span>); <span class="comment">//2</span></span><br><span class="line">stack.search(<span class="number">1</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>push</td>
<td></td>
<td>将元素压入栈中</td>
</tr>
<tr>
<td>pop</td>
<td></td>
<td>从栈顶移除元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>查看栈顶元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断栈是否为空</td>
</tr>
<tr>
<td>search</td>
<td></td>
<td>查找元素在栈中的位置</td>
</tr>
</tbody></table>
<p><strong>Queue</strong></p>
<p>单项队列，只能够操作入队列的那一边</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">que.offer(<span class="number">1</span>);</span><br><span class="line">que.offer(<span class="number">2</span>);</span><br><span class="line">que.offer(<span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> que.poll();</span><br><span class="line">System.out.println(a); <span class="comment">//1</span></span><br><span class="line">System.out.println(que.peek()); <span class="comment">//2</span></span><br><span class="line">System.out.println(que.pollLast()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td></td>
<td>向队列尾部添加元素</td>
</tr>
<tr>
<td>offer</td>
<td></td>
<td>向队尾添加元素，方法优于add</td>
</tr>
<tr>
<td>remove</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>poll</td>
<td></td>
<td>获取并移除队列头不元素</td>
</tr>
<tr>
<td>peek</td>
<td></td>
<td>获取队列头部元素</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>size</td>
<td></td>
<td>获得队列的长度</td>
</tr>
</tbody></table>
<p><strong>Deque</strong></p>
<p>简介：又名双向队列，可以从两边操作元素</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th></th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>offerFirst</td>
<td></td>
<td>从前面插入元素</td>
</tr>
<tr>
<td>offerLast</td>
<td></td>
<td>从后面插入元素</td>
</tr>
<tr>
<td>pollFirst</td>
<td></td>
<td>从前面获取并移除元素</td>
</tr>
<tr>
<td>pollLast</td>
<td></td>
<td>从后面获取并移除元素</td>
</tr>
<tr>
<td>peekFirst</td>
<td></td>
<td>获取头部元素</td>
</tr>
<tr>
<td>getLast</td>
<td></td>
<td>获取尾部元素</td>
</tr>
<tr>
<td>remove(Object o)</td>
<td></td>
<td>移除指定元素，如果队列中有重复的，移除最先入队列的</td>
</tr>
<tr>
<td>isEmpty</td>
<td></td>
<td>判断队列是否为空</td>
</tr>
<tr>
<td>Size</td>
<td></td>
<td>获取队列长度</td>
</tr>
</tbody></table>
<p><strong>PriorityQueue</strong></p>
<p>优先级队列</p>
<p>默认情况下是升序排序，并不是所有元素都按升序进行排序，只有队列头部是最小的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq); <span class="comment">//[-3, 6, 0, 9]</span></span><br></pre></td></tr></table></figure>

<p>如果想要所有元素都按照升序排序，将每一次排好序的首元素进行poll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">pq.offer(-<span class="number">3</span>);</span><br><span class="line">pq.offer(<span class="number">6</span>);</span><br><span class="line">pq.offer(<span class="number">0</span>);</span><br><span class="line">pq.offer(<span class="number">9</span>);</span><br><span class="line">System.out.println(pq);</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> pq.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>); <span class="comment">//-3 0 6 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要降序排序的话</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>优先队列 大顶堆</p>
<blockquote>
<p>首元素是最大的，其余的都比他小，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<p>小顶堆</p>
<blockquote>
<p>首元素是最小的，其余的都比他大，poll元素是从大到小，push是向末尾添加元素</p>
</blockquote>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h3 id="二叉树理论基础"><a href="#二叉树理论基础" class="headerlink" title="二叉树理论基础"></a>二叉树理论基础</h3><p>二叉树主要以两种形式出现</p>
<ul>
<li>完全二叉树</li>
<li>满二叉树</li>
</ul>
<p><strong>满二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/满二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>满二叉树每一层每一个节点的位置都占据满了，深度为k，有2^k-1个节点的二叉树。</p>
</blockquote>
<p><strong>完全二叉树</strong></p>
<img src="/Users/satrol_/Desktop/NotepadImg/完全二叉树.jpg" style="zoom:33%;" />

<blockquote>
<p>除了最后一层其余每一层的节点都占满了</p>
</blockquote>
<p><strong>二叉搜索树</strong></p>
<ul>
<li>左子树不为空，其左子树上的节点都小于左子树根结点的值</li>
<li>右子树不为空，其右子树上的节点都小于右子树根结点的值</li>
<li>左子树和右子树都会二叉排序树</li>
</ul>
<p><strong>平衡二叉搜索树</strong></p>
<p>又被称为AVL树，他可以是空树或者是左子树和右子树的绝对值不大于1的树</p>
<p>我们平时使用的map和set都是机遇平衡二叉搜索树来实现的</p>
<p><font size = "6">二叉树的存储方式</font></p>
<hr>
<p>存储方式主要分为两种链式存储和顺序存储</p>
<p><strong>链式存储主要用的就是指针，顺序存储主要用的就是数组</strong></p>
<p>链式存储用的左右指针来遍历子元素</p>
<p>那么顺序存储是如何拿到子元素的呢？</p>
<p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p><strong>所以大家要了解，用数组依然可以表示二叉树。</strong></p>
<p><font size = "6">二叉树的遍历方式</font></p>
<hr>
<p>二叉树主要有两种遍历方式</p>
<ol>
<li><p>深度优先遍历</p>
<blockquote>
<p>先往深走，遇到叶子节点再往回走</p>
</blockquote>
</li>
<li><p>广度优先遍历</p>
<blockquote>
<p>一层一层的去遍历</p>
</blockquote>
</li>
</ol>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先搜索<ul>
<li>层次遍历</li>
</ul>
</li>
</ul>
<p>如何快速分清前序遍历，中序遍历，后续遍历</p>
<p><strong>这里前中后，其实指的就是中间节点的遍历顺序</strong></p>
<p>前序遍历：中左右</p>
<p>中序遍历：左中右</p>
<p>后序遍历：左右中</p>
<p>图解分析</p>
<p><img src="/Users/satrol_/Desktop/NotepadImg/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.png"></p>
<p>在后面的习题中深度优先搜索都会接住递归来完成，广度优先搜索大部分都是借助队列来完成的，这个在后面慢慢说</p>
<p><font size = "6">如何定义二叉树</font></p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		TreeNode(<span class="type">int</span> val) &#123;<span class="built_in">this</span>.val = val&#125;;</span><br><span class="line">		TreeNode(TreeNode left,TreeNode right,<span class="type">int</span> val)&#123;</span><br><span class="line">				<span class="built_in">this</span>.left = left;</span><br><span class="line">				<span class="built_in">this</span>.right = right;</span><br><span class="line">				<span class="built_in">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h3><p>递归遍历主要分为三种遍历方式：前序遍历，中序遍历，后续遍历</p>
<p>书写递归要考虑一下三步</p>
<ul>
<li><p>确定递归函数的参数和返回值</p>
</li>
<li><p>确定终止条件</p>
</li>
<li><p>确定单层递归的逻辑</p>
</li>
</ul>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">题目入口</a></p>
<p>思路</p>
<ul>
<li>我们什么是否进行返回(当遍历到的值为空的时候进行返回)</li>
<li>遍历的顺序是什么</li>
</ul>
<p>递归法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        preOrder(node.left,result);</span><br><span class="line">        preOrder(node.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>迭代法</p>
<p>思路</p>
<p>我们可以通过栈来实现迭代，首先把根结点放入栈中然后通过stack pop出的根结点来将左右节点放入到栈中，但是一定要先放右后放左，这样pop出来的才是正序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midOrdered(root.left,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        midOrdered(root.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//将左边的元素全部放入栈中</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//接着判断右边是否为空</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">题目入口</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LastOrdered(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">LastOrdered</span><span class="params">(TreeNode root,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        LastOrdered(root.left,result);</span><br><span class="line">        LastOrdered(root.right,result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>后序迭代</p>
<p>思路</p>
<p>将前序遍历左右进行反转最后将整体进行一个反转效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(temp.val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><hr>
<h4 id="二叉树的层序遍历-1"><a href="#二叉树的层序遍历-1" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">题目入口</a></p>
<p>所谓层序遍历就是图论中的广度优先搜索</p>
<p>思路</p>
<p>我们可以用队列来解决这道题，为什么选择了队列而不是栈呢？</p>
<p>因为结果是从左到右的，队列正好也是先入先出，刚好满足题意</p>
<p><code>我们可以通过size来记录每一层中的元素的个数，记录好后遍历将所有本层中的元素pop出来，在这个过程中我们需要将他的子节点放入到队列中，从而保证下一次队列中的元素都是下一层的</code></p>
<p>广度优先搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的层次遍历-II"><a href="#二叉树的层次遍历-II" class="headerlink" title="二叉树的层次遍历 II"></a>二叉树的层次遍历 II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">题目入口</a></p>
<p>思路</p>
<p>反转第一道题的二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">题目入口</a></p>
<p>思路分析</p>
<p>使用层序遍历，在遍历到每一层的最后一个元素的时候将他放入到集合当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(temp.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历将求每一层的和最后求平均值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>,average = <span class="number">0</span>;;</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                sum += temp.val;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            average = sum / size;</span><br><span class="line">            result.add(average);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="N叉树的层序遍历"><a href="#N叉树的层序遍历" class="headerlink" title="N叉树的层序遍历"></a>N叉树的层序遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">题目入口</a></p>
<p>思路</p>
<p>思路和二叉树的层序遍历一样</p>
<p><code>Node里面定义的List&lt;Node&gt; children不是方法，是一个属性</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                List&lt;Node&gt; children = temp.children;</span><br><span class="line">                <span class="keyword">if</span>(children == <span class="literal">null</span> || children.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span>(Node each : children)&#123;</span><br><span class="line">                        que.offer(each);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">题目入口</a></p>
<p>思路</p>
<p>层序遍历找每一层的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) que.offer(root);</span><br><span class="line">        <span class="type">int</span> max;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                max = Math.max(max,temp.val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">题目入口</a></p>
<p>思路</p>
<p>由于需要将同层的两个相邻的元素通过next建立联系，所以我们先获取首元素，然后通过size来遍历剩余的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="comment">//获取首元素方便首元素调用next</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="comment">//i初始为不算首元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                <span class="comment">//首元素后移，并不断指向后面的元素</span></span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="填充每个节点的下一个右侧节点指针II"><a href="#填充每个节点的下一个右侧节点指针II" class="headerlink" title="填充每个节点的下一个右侧节点指针II"></a>填充每个节点的下一个右侧节点指针II</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/submissions/">题目入口</a></p>
<p>一样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Deque&lt;Node&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) que.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) que.offer(cur.right);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(next.left != <span class="literal">null</span>) que.offer(next.left);</span><br><span class="line">                <span class="keyword">if</span>(next.right != <span class="literal">null</span>) que.offer(next.right);</span><br><span class="line">                cur.next = next;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>层序遍历，每遍历一层deep++</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            deep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>当某一个节点的左右两边都是空的话就可以将高度进行返回了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deep</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            deep++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                <span class="keyword">if</span>(temp.left == <span class="literal">null</span> &amp;&amp; temp.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> deep;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑采用哪种遍历方式？</p>
<p>这道题前序遍历和后序遍历都行，中序遍历不行</p>
<p>中序遍历不行一会说</p>
<p>加入我们采取的遍历方式是前序遍历</p>
<p>中 左 右</p>
<p>相当于我们上来交换左子树和右子树，遍历左子树并交换，每一个节点交换左右节点，然后遍历右子树，同样的操作</p>
<p>为什么中序比哪里不行？</p>
<blockquote>
<p>因为如果你采用中序遍历，上来你确实是吧左子树的每一个节点的左右元素进行交换了，但是来到中这一步，我们将左右子树进行了一个交换，现在右子树是交换好的，左子树是没有交换过的，然后接着我们又去交换右子树，又把上来的右子树交换回去了，结果就是整个流程就把左右子树进行了交换其余什么都没有干</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        swap(root);</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>广度优先搜索</p>
<p>思路</p>
<p>每poll出一个节点将他的左右子节点进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                swap(temp);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">题目入口</a></p>
<p>思路</p>
<p>递归：考虑应该使用哪种遍历方式？</p>
<p>你可以把这道题形象的表达为处理左右两个二叉树的题，将最终的结果返回给中间</p>
<p>所以我们使用的肯定是后序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">      	<span class="comment">//四种考虑情况只要有一个不满足结果就是false</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断两边是否相等</span></span><br><span class="line">      	<span class="comment">//判断中间是否相等</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c1</span> <span class="operator">=</span> compare(left.left,right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c2</span> <span class="operator">=</span> compare(left.right,right.left);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> c1 &amp;&amp; c2;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的最大深度-1"><a href="#二叉树的最大深度-1" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">题目入口</a></p>
<p>在开始之前简单回顾一下高度和深度的概念</p>
<p><strong>深度</strong></p>
<blockquote>
<p>深度是到根结点的距离叫做深度，根结点的深度为1，依次递增</p>
</blockquote>
<p><strong>高度</strong></p>
<blockquote>
<p>高度是到达叶子节点的距离，和深度恰恰相反</p>
</blockquote>
<p><u>求高度用后续遍历，求深度用前序遍历</u></p>
<p>这道题为什么我们采用后续遍历呢？</p>
<p>因为根结点的高度就是二叉树的最大深度</p>
<p>解题思路</p>
<p>递归：我们可以通过后续遍历统计左孩子和右孩子的最大高度最后再加上根结点即为最大深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;    </span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Math.max(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="二叉树的最小深度-1"><a href="#二叉树的最小深度-1" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">题目入口</a></p>
<p>最小深度的概念是必须对应的那个结点的左右子树都是空，才是最小深度</p>
<p>思路</p>
<p>这道题和最大深度相似，但是其中有坑</p>
<p>我们也采用后续遍历，但是返回的时候，需要考虑有一边为空的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getLength(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> getLength(node.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftLength + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.min(leftLength,rightLength) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">题目入口</a></p>
<p>普通二叉树处理</p>
<p>思路</p>
<p>使用后序遍历对二叉树左边和右边进行遍历最后加上根结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNodeNum(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> getNodeNum(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLenght</span> <span class="operator">=</span> getNodeNum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftLength + rightLenght + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要求满二叉树的数量的话，通过2 ^ n - 1就可以轻松解决</p>
<p>完全二叉树处理</p>
<p>思路</p>
<ul>
<li><p>二叉树是否为空</p>
</li>
<li><p>完全二叉树是否为满二叉树</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getLength(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//考虑完全二叉树为满二叉树的情况</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>,rightLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left != <span class="literal">null</span>)&#123;</span><br><span class="line">            left = left.left;</span><br><span class="line">            leftLength++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right != <span class="literal">null</span>)&#123;</span><br><span class="line">            right = right.right;</span><br><span class="line">            rightLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftLength == rightLength)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftLength) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> getLength(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span> getLength(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum + rightNum + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于上述直接处理的情况明显处理的情况变少了，时间复杂度也低了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io">Satrol_</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sloplerol.github.io/2023/05/07/LeetCode_Note/">https://sloplerol.github.io/2023/05/07/LeetCode_Note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sloplerol.github.io" target="_blank">Freedom Coding</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/6d/wallhaven-6d5w67.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/10/Nodejs/" title="Exploit node flexible"><img class="cover" src="https://w.wallhaven.cc/full/rr/wallhaven-rrodj7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Exploit node flexible</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/CalculateForJava/" title="CalculateForJava"><img class="cover" src="https://w.wallhaven.cc/full/o5/wallhaven-o51259.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CalculateForJava</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E5%89%8D%E9%A1%BB%E7%9F%A5"><span class="toc-number">1.</span> <span class="toc-text">看前须知</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">数组理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number"></span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="toc-number"></span> <span class="toc-text">有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number"></span> <span class="toc-text">长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="toc-number"></span> <span class="toc-text">螺旋矩阵II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">总结篇</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">链表理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">如何定义链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">删除链表的倒数第N个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="toc-number"></span> <span class="toc-text">链表相交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">环形链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number"></span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">1.</span> <span class="toc-text">有效的字母异位词</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-number">2.</span> <span class="toc-text">两个数组的交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">快乐数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">4.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">5.</span> <span class="toc-text">四数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="toc-number">6.</span> <span class="toc-text">赎金信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-1"><span class="toc-number">8.</span> <span class="toc-text">四数之和</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="toc-number"></span> <span class="toc-text">反转字符串II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="toc-number"></span> <span class="toc-text">替换空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number"></span> <span class="toc-text">翻转字符串里的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">左旋转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number"></span> <span class="toc-text">KMP算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-strStr"><span class="toc-number"></span> <span class="toc-text">实现 strStr()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">重复的子字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">栈和队列理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">用栈实现队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="toc-number"></span> <span class="toc-text">用队列实现栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number"></span> <span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number"></span> <span class="toc-text">删除字符串中的所有相邻重复项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">逆波兰表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number"></span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number"></span> <span class="toc-text">前 K 个高频元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number"></span> <span class="toc-text">二叉树理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.</span> <span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number"></span> <span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-number">1.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86-II"><span class="toc-number">2.</span> <span class="toc-text">二叉树的层次遍历 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">4.</span> <span class="toc-text">二叉树的层平均值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">N叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">6.</span> <span class="toc-text">在每个树行中找最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">7.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II"><span class="toc-number">8.</span> <span class="toc-text">填充每个节点的下一个右侧节点指针II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">9.</span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">二叉树的最小深度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-1"><span class="toc-number"></span> <span class="toc-text">二叉树的最小深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">完全二叉树的节点个数</span></a></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By Satrol_</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to my site !!!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>